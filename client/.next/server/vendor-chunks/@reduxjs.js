"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@reduxjs";
exports.ids = ["vendor-chunks/@reduxjs"];
exports.modules = {

/***/ "(ssr)/./node_modules/@reduxjs/toolkit/dist/query/react/rtk-query-react.modern.mjs":
/*!***********************************************************************************!*\
  !*** ./node_modules/@reduxjs/toolkit/dist/query/react/rtk-query-react.modern.mjs ***!
  \***********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ApiProvider: () => (/* binding */ ApiProvider),\n/* harmony export */   QueryStatus: () => (/* reexport safe */ _reduxjs_toolkit_query__WEBPACK_IMPORTED_MODULE_3__.QueryStatus),\n/* harmony export */   UNINITIALIZED_VALUE: () => (/* binding */ UNINITIALIZED_VALUE),\n/* harmony export */   _NEVER: () => (/* reexport safe */ _reduxjs_toolkit_query__WEBPACK_IMPORTED_MODULE_3__._NEVER),\n/* harmony export */   buildCreateApi: () => (/* reexport safe */ _reduxjs_toolkit_query__WEBPACK_IMPORTED_MODULE_3__.buildCreateApi),\n/* harmony export */   copyWithStructuralSharing: () => (/* reexport safe */ _reduxjs_toolkit_query__WEBPACK_IMPORTED_MODULE_3__.copyWithStructuralSharing),\n/* harmony export */   coreModule: () => (/* reexport safe */ _reduxjs_toolkit_query__WEBPACK_IMPORTED_MODULE_3__.coreModule),\n/* harmony export */   coreModuleName: () => (/* reexport safe */ _reduxjs_toolkit_query__WEBPACK_IMPORTED_MODULE_3__.coreModuleName),\n/* harmony export */   createApi: () => (/* binding */ createApi),\n/* harmony export */   defaultSerializeQueryArgs: () => (/* reexport safe */ _reduxjs_toolkit_query__WEBPACK_IMPORTED_MODULE_3__.defaultSerializeQueryArgs),\n/* harmony export */   fakeBaseQuery: () => (/* reexport safe */ _reduxjs_toolkit_query__WEBPACK_IMPORTED_MODULE_3__.fakeBaseQuery),\n/* harmony export */   fetchBaseQuery: () => (/* reexport safe */ _reduxjs_toolkit_query__WEBPACK_IMPORTED_MODULE_3__.fetchBaseQuery),\n/* harmony export */   reactHooksModule: () => (/* binding */ reactHooksModule),\n/* harmony export */   reactHooksModuleName: () => (/* binding */ reactHooksModuleName),\n/* harmony export */   retry: () => (/* reexport safe */ _reduxjs_toolkit_query__WEBPACK_IMPORTED_MODULE_3__.retry),\n/* harmony export */   setupListeners: () => (/* reexport safe */ _reduxjs_toolkit_query__WEBPACK_IMPORTED_MODULE_3__.setupListeners),\n/* harmony export */   skipToken: () => (/* reexport safe */ _reduxjs_toolkit_query__WEBPACK_IMPORTED_MODULE_3__.skipToken)\n/* harmony export */ });\n/* harmony import */ var _reduxjs_toolkit_query__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @reduxjs/toolkit/query */ \"(ssr)/./node_modules/@reduxjs/toolkit/dist/query/rtk-query.modern.mjs\");\n/* harmony import */ var react_redux__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-redux */ \"(ssr)/./node_modules/react-redux/dist/react-redux.mjs\");\n/* harmony import */ var reselect__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! reselect */ \"(ssr)/./node_modules/reselect/dist/reselect.mjs\");\n/* harmony import */ var _reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @reduxjs/toolkit */ \"(ssr)/./node_modules/redux/dist/redux.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @reduxjs/toolkit */ \"(ssr)/./node_modules/@reduxjs/toolkit/dist/redux-toolkit.modern.mjs\");\n// src/query/react/index.ts\n\n\n// src/query/react/module.ts\n\n\n\n\n// src/query/endpointDefinitions.ts\nfunction isQueryDefinition(e) {\n  return e.type === \"query\" /* query */;\n}\nfunction isMutationDefinition(e) {\n  return e.type === \"mutation\" /* mutation */;\n}\n\n// src/query/tsHelpers.ts\nfunction safeAssign(target, ...args) {\n  return Object.assign(target, ...args);\n}\n\n// src/query/utils/capitalize.ts\nfunction capitalize(str) {\n  return str.replace(str[0], str[0].toUpperCase());\n}\n\n// src/query/core/rtkImports.ts\n\n\n// src/query/utils/countObjectKeys.ts\nfunction countObjectKeys(obj) {\n  let count = 0;\n  for (const _key in obj) {\n    count++;\n  }\n  return count;\n}\n\n// src/query/react/buildHooks.ts\n\n\n\n\n\n// src/query/defaultSerializeQueryArgs.ts\nvar cache = WeakMap ? /* @__PURE__ */ new WeakMap() : void 0;\nvar defaultSerializeQueryArgs = ({\n  endpointName,\n  queryArgs\n}) => {\n  let serialized = \"\";\n  const cached = cache?.get(queryArgs);\n  if (typeof cached === \"string\") {\n    serialized = cached;\n  } else {\n    const stringified = JSON.stringify(queryArgs, (key, value) => {\n      value = typeof value === \"bigint\" ? {\n        $bigint: value.toString()\n      } : value;\n      value = (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.isPlainObject)(value) ? Object.keys(value).sort().reduce((acc, key2) => {\n        acc[key2] = value[key2];\n        return acc;\n      }, {}) : value;\n      return value;\n    });\n    if ((0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.isPlainObject)(queryArgs)) {\n      cache?.set(queryArgs, stringified);\n    }\n    serialized = stringified;\n  }\n  return `${endpointName}(${serialized})`;\n};\n\n// src/query/react/constants.ts\nvar UNINITIALIZED_VALUE = Symbol();\n\n// src/query/react/useSerializedStableValue.ts\n\nfunction useStableQueryArgs(queryArgs, serialize, endpointDefinition, endpointName) {\n  const incoming = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => ({\n    queryArgs,\n    serialized: typeof queryArgs == \"object\" ? serialize({\n      queryArgs,\n      endpointDefinition,\n      endpointName\n    }) : queryArgs\n  }), [queryArgs, serialize, endpointDefinition, endpointName]);\n  const cache2 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(incoming);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (cache2.current.serialized !== incoming.serialized) {\n      cache2.current = incoming;\n    }\n  }, [incoming]);\n  return cache2.current.serialized === incoming.serialized ? cache2.current.queryArgs : queryArgs;\n}\n\n// src/query/react/useShallowStableValue.ts\n\n\nfunction useShallowStableValue(value) {\n  const cache2 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(value);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (!(0,react_redux__WEBPACK_IMPORTED_MODULE_2__.shallowEqual)(cache2.current, value)) {\n      cache2.current = value;\n    }\n  }, [value]);\n  return (0,react_redux__WEBPACK_IMPORTED_MODULE_2__.shallowEqual)(cache2.current, value) ? cache2.current : value;\n}\n\n// src/query/react/buildHooks.ts\nvar canUseDOM = () => !!(typeof window !== \"undefined\" && typeof window.document !== \"undefined\" && typeof window.document.createElement !== \"undefined\");\nvar isDOM = /* @__PURE__ */ canUseDOM();\nvar isRunningInReactNative = () => typeof navigator !== \"undefined\" && navigator.product === \"ReactNative\";\nvar isReactNative = /* @__PURE__ */ isRunningInReactNative();\nvar getUseIsomorphicLayoutEffect = () => isDOM || isReactNative ? react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect : react__WEBPACK_IMPORTED_MODULE_0__.useEffect;\nvar useIsomorphicLayoutEffect = /* @__PURE__ */ getUseIsomorphicLayoutEffect();\nvar noPendingQueryStateSelector = (selected) => {\n  if (selected.isUninitialized) {\n    return {\n      ...selected,\n      isUninitialized: false,\n      isFetching: true,\n      isLoading: selected.data !== void 0 ? false : true,\n      status: _reduxjs_toolkit_query__WEBPACK_IMPORTED_MODULE_3__.QueryStatus.pending\n    };\n  }\n  return selected;\n};\nfunction buildHooks({\n  api,\n  moduleOptions: {\n    batch,\n    hooks: {\n      useDispatch,\n      useSelector,\n      useStore\n    },\n    unstable__sideEffectsInRender,\n    createSelector: createSelector2\n  },\n  serializeQueryArgs,\n  context\n}) {\n  const usePossiblyImmediateEffect = unstable__sideEffectsInRender ? (cb) => cb() : react__WEBPACK_IMPORTED_MODULE_0__.useEffect;\n  return {\n    buildQueryHooks,\n    buildMutationHook,\n    usePrefetch\n  };\n  function queryStatePreSelector(currentState, lastResult, queryArgs) {\n    if (lastResult?.endpointName && currentState.isUninitialized) {\n      const {\n        endpointName\n      } = lastResult;\n      const endpointDefinition = context.endpointDefinitions[endpointName];\n      if (serializeQueryArgs({\n        queryArgs: lastResult.originalArgs,\n        endpointDefinition,\n        endpointName\n      }) === serializeQueryArgs({\n        queryArgs,\n        endpointDefinition,\n        endpointName\n      })) lastResult = void 0;\n    }\n    let data = currentState.isSuccess ? currentState.data : lastResult?.data;\n    if (data === void 0) data = currentState.data;\n    const hasData = data !== void 0;\n    const isFetching = currentState.isLoading;\n    const isLoading = (!lastResult || lastResult.isLoading || lastResult.isUninitialized) && !hasData && isFetching;\n    const isSuccess = currentState.isSuccess || isFetching && hasData;\n    return {\n      ...currentState,\n      data,\n      currentData: currentState.data,\n      isFetching,\n      isLoading,\n      isSuccess\n    };\n  }\n  function usePrefetch(endpointName, defaultOptions) {\n    const dispatch = useDispatch();\n    const stableDefaultOptions = useShallowStableValue(defaultOptions);\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((arg, options) => dispatch(api.util.prefetch(endpointName, arg, {\n      ...stableDefaultOptions,\n      ...options\n    })), [endpointName, dispatch, stableDefaultOptions]);\n  }\n  function buildQueryHooks(name) {\n    const useQuerySubscription = (arg, {\n      refetchOnReconnect,\n      refetchOnFocus,\n      refetchOnMountOrArgChange,\n      skip = false,\n      pollingInterval = 0,\n      skipPollingIfUnfocused = false\n    } = {}) => {\n      const {\n        initiate\n      } = api.endpoints[name];\n      const dispatch = useDispatch();\n      const subscriptionSelectorsRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(void 0);\n      if (!subscriptionSelectorsRef.current) {\n        const returnedValue = dispatch(api.internalActions.internal_getRTKQSubscriptions());\n        if (true) {\n          if (typeof returnedValue !== \"object\" || typeof returnedValue?.type === \"string\") {\n            throw new Error( false ? 0 : `Warning: Middleware for RTK-Query API at reducerPath \"${api.reducerPath}\" has not been added to the store.\n    You must add the middleware for RTK-Query to function correctly!`);\n          }\n        }\n        subscriptionSelectorsRef.current = returnedValue;\n      }\n      const stableArg = useStableQueryArgs(\n        skip ? _reduxjs_toolkit_query__WEBPACK_IMPORTED_MODULE_3__.skipToken : arg,\n        // Even if the user provided a per-endpoint `serializeQueryArgs` with\n        // a consistent return value, _here_ we want to use the default behavior\n        // so we can tell if _anything_ actually changed. Otherwise, we can end up\n        // with a case where the query args did change but the serialization doesn't,\n        // and then we never try to initiate a refetch.\n        defaultSerializeQueryArgs,\n        context.endpointDefinitions[name],\n        name\n      );\n      const stableSubscriptionOptions = useShallowStableValue({\n        refetchOnReconnect,\n        refetchOnFocus,\n        pollingInterval,\n        skipPollingIfUnfocused\n      });\n      const lastRenderHadSubscription = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n      const promiseRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(void 0);\n      let {\n        queryCacheKey,\n        requestId\n      } = promiseRef.current || {};\n      let currentRenderHasSubscription = false;\n      if (queryCacheKey && requestId) {\n        currentRenderHasSubscription = subscriptionSelectorsRef.current.isRequestSubscribed(queryCacheKey, requestId);\n      }\n      const subscriptionRemoved = !currentRenderHasSubscription && lastRenderHadSubscription.current;\n      usePossiblyImmediateEffect(() => {\n        lastRenderHadSubscription.current = currentRenderHasSubscription;\n      });\n      usePossiblyImmediateEffect(() => {\n        if (subscriptionRemoved) {\n          promiseRef.current = void 0;\n        }\n      }, [subscriptionRemoved]);\n      usePossiblyImmediateEffect(() => {\n        const lastPromise = promiseRef.current;\n        if (typeof process !== \"undefined\" && \"development\" === \"removeMeOnCompilation\") {}\n        if (stableArg === _reduxjs_toolkit_query__WEBPACK_IMPORTED_MODULE_3__.skipToken) {\n          lastPromise?.unsubscribe();\n          promiseRef.current = void 0;\n          return;\n        }\n        const lastSubscriptionOptions = promiseRef.current?.subscriptionOptions;\n        if (!lastPromise || lastPromise.arg !== stableArg) {\n          lastPromise?.unsubscribe();\n          const promise = dispatch(initiate(stableArg, {\n            subscriptionOptions: stableSubscriptionOptions,\n            forceRefetch: refetchOnMountOrArgChange\n          }));\n          promiseRef.current = promise;\n        } else if (stableSubscriptionOptions !== lastSubscriptionOptions) {\n          lastPromise.updateSubscriptionOptions(stableSubscriptionOptions);\n        }\n      }, [dispatch, initiate, refetchOnMountOrArgChange, stableArg, stableSubscriptionOptions, subscriptionRemoved]);\n      (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        return () => {\n          promiseRef.current?.unsubscribe();\n          promiseRef.current = void 0;\n        };\n      }, []);\n      return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => ({\n        /**\n         * A method to manually refetch data for the query\n         */\n        refetch: () => {\n          if (!promiseRef.current) throw new Error( false ? 0 : \"Cannot refetch a query that has not been started yet.\");\n          return promiseRef.current?.refetch();\n        }\n      }), []);\n    };\n    const useLazyQuerySubscription = ({\n      refetchOnReconnect,\n      refetchOnFocus,\n      pollingInterval = 0,\n      skipPollingIfUnfocused = false\n    } = {}) => {\n      const {\n        initiate\n      } = api.endpoints[name];\n      const dispatch = useDispatch();\n      const [arg, setArg] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(UNINITIALIZED_VALUE);\n      const promiseRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(void 0);\n      const stableSubscriptionOptions = useShallowStableValue({\n        refetchOnReconnect,\n        refetchOnFocus,\n        pollingInterval,\n        skipPollingIfUnfocused\n      });\n      usePossiblyImmediateEffect(() => {\n        const lastSubscriptionOptions = promiseRef.current?.subscriptionOptions;\n        if (stableSubscriptionOptions !== lastSubscriptionOptions) {\n          promiseRef.current?.updateSubscriptionOptions(stableSubscriptionOptions);\n        }\n      }, [stableSubscriptionOptions]);\n      const subscriptionOptionsRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(stableSubscriptionOptions);\n      usePossiblyImmediateEffect(() => {\n        subscriptionOptionsRef.current = stableSubscriptionOptions;\n      }, [stableSubscriptionOptions]);\n      const trigger = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(function(arg2, preferCacheValue = false) {\n        let promise;\n        batch(() => {\n          promiseRef.current?.unsubscribe();\n          promiseRef.current = promise = dispatch(initiate(arg2, {\n            subscriptionOptions: subscriptionOptionsRef.current,\n            forceRefetch: !preferCacheValue\n          }));\n          setArg(arg2);\n        });\n        return promise;\n      }, [dispatch, initiate]);\n      (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        return () => {\n          promiseRef?.current?.unsubscribe();\n        };\n      }, []);\n      (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        if (arg !== UNINITIALIZED_VALUE && !promiseRef.current) {\n          trigger(arg, true);\n        }\n      }, [arg, trigger]);\n      return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => [trigger, arg], [trigger, arg]);\n    };\n    const useQueryState = (arg, {\n      skip = false,\n      selectFromResult\n    } = {}) => {\n      const {\n        select\n      } = api.endpoints[name];\n      const stableArg = useStableQueryArgs(skip ? _reduxjs_toolkit_query__WEBPACK_IMPORTED_MODULE_3__.skipToken : arg, serializeQueryArgs, context.endpointDefinitions[name], name);\n      const lastValue = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(void 0);\n      const selectDefaultResult = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => createSelector2([select(stableArg), (_, lastResult) => lastResult, (_) => stableArg], queryStatePreSelector, {\n        memoizeOptions: {\n          resultEqualityCheck: react_redux__WEBPACK_IMPORTED_MODULE_2__.shallowEqual\n        }\n      }), [select, stableArg]);\n      const querySelector = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => selectFromResult ? createSelector2([selectDefaultResult], selectFromResult, {\n        devModeChecks: {\n          identityFunctionCheck: \"never\"\n        }\n      }) : selectDefaultResult, [selectDefaultResult, selectFromResult]);\n      const currentState = useSelector((state) => querySelector(state, lastValue.current), react_redux__WEBPACK_IMPORTED_MODULE_2__.shallowEqual);\n      const store = useStore();\n      const newLastValue = selectDefaultResult(store.getState(), lastValue.current);\n      useIsomorphicLayoutEffect(() => {\n        lastValue.current = newLastValue;\n      }, [newLastValue]);\n      return currentState;\n    };\n    return {\n      useQueryState,\n      useQuerySubscription,\n      useLazyQuerySubscription,\n      useLazyQuery(options) {\n        const [trigger, arg] = useLazyQuerySubscription(options);\n        const queryStateResults = useQueryState(arg, {\n          ...options,\n          skip: arg === UNINITIALIZED_VALUE\n        });\n        const info = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => ({\n          lastArg: arg\n        }), [arg]);\n        return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => [trigger, queryStateResults, info], [trigger, queryStateResults, info]);\n      },\n      useQuery(arg, options) {\n        const querySubscriptionResults = useQuerySubscription(arg, options);\n        const queryStateResults = useQueryState(arg, {\n          selectFromResult: arg === _reduxjs_toolkit_query__WEBPACK_IMPORTED_MODULE_3__.skipToken || options?.skip ? void 0 : noPendingQueryStateSelector,\n          ...options\n        });\n        const {\n          data,\n          status,\n          isLoading,\n          isSuccess,\n          isError,\n          error\n        } = queryStateResults;\n        (0,react__WEBPACK_IMPORTED_MODULE_0__.useDebugValue)({\n          data,\n          status,\n          isLoading,\n          isSuccess,\n          isError,\n          error\n        });\n        return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => ({\n          ...queryStateResults,\n          ...querySubscriptionResults\n        }), [queryStateResults, querySubscriptionResults]);\n      }\n    };\n  }\n  function buildMutationHook(name) {\n    return ({\n      selectFromResult,\n      fixedCacheKey\n    } = {}) => {\n      const {\n        select,\n        initiate\n      } = api.endpoints[name];\n      const dispatch = useDispatch();\n      const [promise, setPromise] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)();\n      (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => () => {\n        if (!promise?.arg.fixedCacheKey) {\n          promise?.reset();\n        }\n      }, [promise]);\n      const triggerMutation = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(function(arg) {\n        const promise2 = dispatch(initiate(arg, {\n          fixedCacheKey\n        }));\n        setPromise(promise2);\n        return promise2;\n      }, [dispatch, initiate, fixedCacheKey]);\n      const {\n        requestId\n      } = promise || {};\n      const selectDefaultResult = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => select({\n        fixedCacheKey,\n        requestId: promise?.requestId\n      }), [fixedCacheKey, promise, select]);\n      const mutationSelector = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => selectFromResult ? createSelector2([selectDefaultResult], selectFromResult) : selectDefaultResult, [selectFromResult, selectDefaultResult]);\n      const currentState = useSelector(mutationSelector, react_redux__WEBPACK_IMPORTED_MODULE_2__.shallowEqual);\n      const originalArgs = fixedCacheKey == null ? promise?.arg.originalArgs : void 0;\n      const reset = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n        batch(() => {\n          if (promise) {\n            setPromise(void 0);\n          }\n          if (fixedCacheKey) {\n            dispatch(api.internalActions.removeMutationResult({\n              requestId,\n              fixedCacheKey\n            }));\n          }\n        });\n      }, [dispatch, fixedCacheKey, promise, requestId]);\n      const {\n        endpointName,\n        data,\n        status,\n        isLoading,\n        isSuccess,\n        isError,\n        error\n      } = currentState;\n      (0,react__WEBPACK_IMPORTED_MODULE_0__.useDebugValue)({\n        endpointName,\n        data,\n        status,\n        isLoading,\n        isSuccess,\n        isError,\n        error\n      });\n      const finalState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => ({\n        ...currentState,\n        originalArgs,\n        reset\n      }), [currentState, originalArgs, reset]);\n      return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => [triggerMutation, finalState], [triggerMutation, finalState]);\n    };\n  }\n}\n\n// src/query/react/module.ts\nvar reactHooksModuleName = /* @__PURE__ */ Symbol();\nvar reactHooksModule = ({\n  batch = react_redux__WEBPACK_IMPORTED_MODULE_2__.batch,\n  hooks = {\n    useDispatch: react_redux__WEBPACK_IMPORTED_MODULE_2__.useDispatch,\n    useSelector: react_redux__WEBPACK_IMPORTED_MODULE_2__.useSelector,\n    useStore: react_redux__WEBPACK_IMPORTED_MODULE_2__.useStore\n  },\n  createSelector: createSelector2 = reselect__WEBPACK_IMPORTED_MODULE_4__.createSelector,\n  unstable__sideEffectsInRender = false,\n  ...rest\n} = {}) => {\n  if (true) {\n    const hookNames = [\"useDispatch\", \"useSelector\", \"useStore\"];\n    let warned = false;\n    for (const hookName of hookNames) {\n      if (countObjectKeys(rest) > 0) {\n        if (rest[hookName]) {\n          if (!warned) {\n            console.warn(\"As of RTK 2.0, the hooks now need to be specified as one object, provided under a `hooks` key:\\n`reactHooksModule({ hooks: { useDispatch, useSelector, useStore } })`\");\n            warned = true;\n          }\n        }\n        hooks[hookName] = rest[hookName];\n      }\n      if (typeof hooks[hookName] !== \"function\") {\n        throw new Error( false ? 0 : `When using custom hooks for context, all ${hookNames.length} hooks need to be provided: ${hookNames.join(\", \")}.\nHook ${hookName} was either not provided or not a function.`);\n      }\n    }\n  }\n  return {\n    name: reactHooksModuleName,\n    init(api, {\n      serializeQueryArgs\n    }, context) {\n      const anyApi = api;\n      const {\n        buildQueryHooks,\n        buildMutationHook,\n        usePrefetch\n      } = buildHooks({\n        api,\n        moduleOptions: {\n          batch,\n          hooks,\n          unstable__sideEffectsInRender,\n          createSelector: createSelector2\n        },\n        serializeQueryArgs,\n        context\n      });\n      safeAssign(anyApi, {\n        usePrefetch\n      });\n      safeAssign(context, {\n        batch\n      });\n      return {\n        injectEndpoint(endpointName, definition) {\n          if (isQueryDefinition(definition)) {\n            const {\n              useQuery,\n              useLazyQuery,\n              useLazyQuerySubscription,\n              useQueryState,\n              useQuerySubscription\n            } = buildQueryHooks(endpointName);\n            safeAssign(anyApi.endpoints[endpointName], {\n              useQuery,\n              useLazyQuery,\n              useLazyQuerySubscription,\n              useQueryState,\n              useQuerySubscription\n            });\n            api[`use${capitalize(endpointName)}Query`] = useQuery;\n            api[`useLazy${capitalize(endpointName)}Query`] = useLazyQuery;\n          } else if (isMutationDefinition(definition)) {\n            const useMutation = buildMutationHook(endpointName);\n            safeAssign(anyApi.endpoints[endpointName], {\n              useMutation\n            });\n            api[`use${capitalize(endpointName)}Mutation`] = useMutation;\n          }\n        }\n      };\n    }\n  };\n};\n\n// src/query/react/index.ts\n\n\n// src/query/react/ApiProvider.tsx\n\n\n\n\n\n\nfunction ApiProvider(props) {\n  const context = props.context || react_redux__WEBPACK_IMPORTED_MODULE_2__.ReactReduxContext;\n  const existingContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(context);\n  if (existingContext) {\n    throw new Error( false ? 0 : \"Existing Redux context detected. If you already have a store set up, please use the traditional Redux setup.\");\n  }\n  const [store] = react__WEBPACK_IMPORTED_MODULE_0__.useState(() => (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_5__.configureStore)({\n    reducer: {\n      [props.api.reducerPath]: props.api.reducer\n    },\n    middleware: (gDM) => gDM().concat(props.api.middleware)\n  }));\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => props.setupListeners === false ? void 0 : (0,_reduxjs_toolkit_query__WEBPACK_IMPORTED_MODULE_3__.setupListeners)(store.dispatch, props.setupListeners), [props.setupListeners, store.dispatch]);\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_redux__WEBPACK_IMPORTED_MODULE_2__.Provider, { store, context }, props.children);\n}\n\n// src/query/react/index.ts\nvar createApi = /* @__PURE__ */ (0,_reduxjs_toolkit_query__WEBPACK_IMPORTED_MODULE_3__.buildCreateApi)((0,_reduxjs_toolkit_query__WEBPACK_IMPORTED_MODULE_3__.coreModule)(), reactHooksModule());\n\n//# sourceMappingURL=rtk-query-react.modern.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlZHV4anMvdG9vbGtpdC9kaXN0L3F1ZXJ5L3JlYWN0L3J0ay1xdWVyeS1yZWFjdC5tb2Rlcm4ubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDb0U7O0FBRXBFO0FBQ3NGO0FBQzZDO0FBQ3RFOztBQUU3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUN1Uzs7QUFFdlM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUN5STtBQUN6RTtBQUMrRTtBQUNuRjs7QUFFNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsY0FBYywrREFBYTtBQUMzQjtBQUNBO0FBQ0EsT0FBTyxJQUFJO0FBQ1g7QUFDQSxLQUFLO0FBQ0wsUUFBUSwrREFBYTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksYUFBYSxHQUFHLFdBQVc7QUFDdkM7O0FBRUE7QUFDQTs7QUFFQTtBQUNtRDtBQUNuRDtBQUNBLG1CQUFtQiw4Q0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSCxpQkFBaUIsNkNBQU07QUFDdkIsRUFBRSxnREFBUztBQUNYO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ21FO0FBQ3hCO0FBQzNDO0FBQ0EsaUJBQWlCLDZDQUFPO0FBQ3hCLEVBQUUsZ0RBQVU7QUFDWixTQUFTLHlEQUFZO0FBQ3JCO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsU0FBUyx5REFBWTtBQUNyQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLGtEQUFlLEdBQUcsNENBQVU7QUFDOUY7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O0FBQ3JEO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0gsRUFBRSxnREFBVSxpREFBaUQsc0VBQWM7QUFDM0UseUJBQXlCLGdEQUFtQixDQUFDLGlEQUFRLElBQUksZ0JBQWdCO0FBQ3pFOztBQUVBO0FBQ0EsZ0NBQWdDLHNFQUFjLENBQUMsa0VBQVU7QUFPdkQ7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uL25vZGVfbW9kdWxlcy9AcmVkdXhqcy90b29sa2l0L2Rpc3QvcXVlcnkvcmVhY3QvcnRrLXF1ZXJ5LXJlYWN0Lm1vZGVybi5tanM/MWNlNCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvcXVlcnkvcmVhY3QvaW5kZXgudHNcbmltcG9ydCB7IGJ1aWxkQ3JlYXRlQXBpLCBjb3JlTW9kdWxlIH0gZnJvbSBcIkByZWR1eGpzL3Rvb2xraXQvcXVlcnlcIjtcblxuLy8gc3JjL3F1ZXJ5L3JlYWN0L21vZHVsZS50c1xuaW1wb3J0IHsgZm9ybWF0UHJvZEVycm9yTWVzc2FnZSBhcyBfZm9ybWF0UHJvZEVycm9yTWVzc2FnZTMgfSBmcm9tIFwiQHJlZHV4anMvdG9vbGtpdFwiO1xuaW1wb3J0IHsgYmF0Y2ggYXMgcnJCYXRjaCwgdXNlRGlzcGF0Y2ggYXMgcnJVc2VEaXNwYXRjaCwgdXNlU2VsZWN0b3IgYXMgcnJVc2VTZWxlY3RvciwgdXNlU3RvcmUgYXMgcnJVc2VTdG9yZSB9IGZyb20gXCJyZWFjdC1yZWR1eFwiO1xuaW1wb3J0IHsgY3JlYXRlU2VsZWN0b3IgYXMgX2NyZWF0ZVNlbGVjdG9yIH0gZnJvbSBcInJlc2VsZWN0XCI7XG5cbi8vIHNyYy9xdWVyeS9lbmRwb2ludERlZmluaXRpb25zLnRzXG5mdW5jdGlvbiBpc1F1ZXJ5RGVmaW5pdGlvbihlKSB7XG4gIHJldHVybiBlLnR5cGUgPT09IFwicXVlcnlcIiAvKiBxdWVyeSAqLztcbn1cbmZ1bmN0aW9uIGlzTXV0YXRpb25EZWZpbml0aW9uKGUpIHtcbiAgcmV0dXJuIGUudHlwZSA9PT0gXCJtdXRhdGlvblwiIC8qIG11dGF0aW9uICovO1xufVxuXG4vLyBzcmMvcXVlcnkvdHNIZWxwZXJzLnRzXG5mdW5jdGlvbiBzYWZlQXNzaWduKHRhcmdldCwgLi4uYXJncykge1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbih0YXJnZXQsIC4uLmFyZ3MpO1xufVxuXG4vLyBzcmMvcXVlcnkvdXRpbHMvY2FwaXRhbGl6ZS50c1xuZnVuY3Rpb24gY2FwaXRhbGl6ZShzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKHN0clswXSwgc3RyWzBdLnRvVXBwZXJDYXNlKCkpO1xufVxuXG4vLyBzcmMvcXVlcnkvY29yZS9ydGtJbXBvcnRzLnRzXG5pbXBvcnQgeyBjcmVhdGVBY3Rpb24sIGNyZWF0ZVNsaWNlLCBjcmVhdGVTZWxlY3RvciwgY3JlYXRlQXN5bmNUaHVuaywgY29tYmluZVJlZHVjZXJzLCBjcmVhdGVOZXh0U3RhdGUsIGlzQW55T2YsIGlzQWxsT2YsIGlzQWN0aW9uLCBpc1BlbmRpbmcsIGlzUmVqZWN0ZWQsIGlzRnVsZmlsbGVkLCBpc1JlamVjdGVkV2l0aFZhbHVlLCBpc0FzeW5jVGh1bmtBY3Rpb24sIHByZXBhcmVBdXRvQmF0Y2hlZCwgU0hPVUxEX0FVVE9CQVRDSCwgaXNQbGFpbk9iamVjdCwgbmFub2lkIH0gZnJvbSBcIkByZWR1eGpzL3Rvb2xraXRcIjtcblxuLy8gc3JjL3F1ZXJ5L3V0aWxzL2NvdW50T2JqZWN0S2V5cy50c1xuZnVuY3Rpb24gY291bnRPYmplY3RLZXlzKG9iaikge1xuICBsZXQgY291bnQgPSAwO1xuICBmb3IgKGNvbnN0IF9rZXkgaW4gb2JqKSB7XG4gICAgY291bnQrKztcbiAgfVxuICByZXR1cm4gY291bnQ7XG59XG5cbi8vIHNyYy9xdWVyeS9yZWFjdC9idWlsZEhvb2tzLnRzXG5pbXBvcnQgeyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlIGFzIF9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlLCBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlIGFzIF9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlMiB9IGZyb20gXCJAcmVkdXhqcy90b29sa2l0XCI7XG5pbXBvcnQgeyBRdWVyeVN0YXR1cywgc2tpcFRva2VuIH0gZnJvbSBcIkByZWR1eGpzL3Rvb2xraXQvcXVlcnlcIjtcbmltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VEZWJ1Z1ZhbHVlLCB1c2VFZmZlY3QgYXMgdXNlRWZmZWN0MywgdXNlTGF5b3V0RWZmZWN0LCB1c2VNZW1vIGFzIHVzZU1lbW8yLCB1c2VSZWYgYXMgdXNlUmVmMywgdXNlU3RhdGUgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IHNoYWxsb3dFcXVhbCBhcyBzaGFsbG93RXF1YWwyIH0gZnJvbSBcInJlYWN0LXJlZHV4XCI7XG5cbi8vIHNyYy9xdWVyeS9kZWZhdWx0U2VyaWFsaXplUXVlcnlBcmdzLnRzXG52YXIgY2FjaGUgPSBXZWFrTWFwID8gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCkgOiB2b2lkIDA7XG52YXIgZGVmYXVsdFNlcmlhbGl6ZVF1ZXJ5QXJncyA9ICh7XG4gIGVuZHBvaW50TmFtZSxcbiAgcXVlcnlBcmdzXG59KSA9PiB7XG4gIGxldCBzZXJpYWxpemVkID0gXCJcIjtcbiAgY29uc3QgY2FjaGVkID0gY2FjaGU/LmdldChxdWVyeUFyZ3MpO1xuICBpZiAodHlwZW9mIGNhY2hlZCA9PT0gXCJzdHJpbmdcIikge1xuICAgIHNlcmlhbGl6ZWQgPSBjYWNoZWQ7XG4gIH0gZWxzZSB7XG4gICAgY29uc3Qgc3RyaW5naWZpZWQgPSBKU09OLnN0cmluZ2lmeShxdWVyeUFyZ3MsIChrZXksIHZhbHVlKSA9PiB7XG4gICAgICB2YWx1ZSA9IHR5cGVvZiB2YWx1ZSA9PT0gXCJiaWdpbnRcIiA/IHtcbiAgICAgICAgJGJpZ2ludDogdmFsdWUudG9TdHJpbmcoKVxuICAgICAgfSA6IHZhbHVlO1xuICAgICAgdmFsdWUgPSBpc1BsYWluT2JqZWN0KHZhbHVlKSA/IE9iamVjdC5rZXlzKHZhbHVlKS5zb3J0KCkucmVkdWNlKChhY2MsIGtleTIpID0+IHtcbiAgICAgICAgYWNjW2tleTJdID0gdmFsdWVba2V5Ml07XG4gICAgICAgIHJldHVybiBhY2M7XG4gICAgICB9LCB7fSkgOiB2YWx1ZTtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9KTtcbiAgICBpZiAoaXNQbGFpbk9iamVjdChxdWVyeUFyZ3MpKSB7XG4gICAgICBjYWNoZT8uc2V0KHF1ZXJ5QXJncywgc3RyaW5naWZpZWQpO1xuICAgIH1cbiAgICBzZXJpYWxpemVkID0gc3RyaW5naWZpZWQ7XG4gIH1cbiAgcmV0dXJuIGAke2VuZHBvaW50TmFtZX0oJHtzZXJpYWxpemVkfSlgO1xufTtcblxuLy8gc3JjL3F1ZXJ5L3JlYWN0L2NvbnN0YW50cy50c1xudmFyIFVOSU5JVElBTElaRURfVkFMVUUgPSBTeW1ib2woKTtcblxuLy8gc3JjL3F1ZXJ5L3JlYWN0L3VzZVNlcmlhbGl6ZWRTdGFibGVWYWx1ZS50c1xuaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VSZWYsIHVzZU1lbW8gfSBmcm9tIFwicmVhY3RcIjtcbmZ1bmN0aW9uIHVzZVN0YWJsZVF1ZXJ5QXJncyhxdWVyeUFyZ3MsIHNlcmlhbGl6ZSwgZW5kcG9pbnREZWZpbml0aW9uLCBlbmRwb2ludE5hbWUpIHtcbiAgY29uc3QgaW5jb21pbmcgPSB1c2VNZW1vKCgpID0+ICh7XG4gICAgcXVlcnlBcmdzLFxuICAgIHNlcmlhbGl6ZWQ6IHR5cGVvZiBxdWVyeUFyZ3MgPT0gXCJvYmplY3RcIiA/IHNlcmlhbGl6ZSh7XG4gICAgICBxdWVyeUFyZ3MsXG4gICAgICBlbmRwb2ludERlZmluaXRpb24sXG4gICAgICBlbmRwb2ludE5hbWVcbiAgICB9KSA6IHF1ZXJ5QXJnc1xuICB9KSwgW3F1ZXJ5QXJncywgc2VyaWFsaXplLCBlbmRwb2ludERlZmluaXRpb24sIGVuZHBvaW50TmFtZV0pO1xuICBjb25zdCBjYWNoZTIgPSB1c2VSZWYoaW5jb21pbmcpO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChjYWNoZTIuY3VycmVudC5zZXJpYWxpemVkICE9PSBpbmNvbWluZy5zZXJpYWxpemVkKSB7XG4gICAgICBjYWNoZTIuY3VycmVudCA9IGluY29taW5nO1xuICAgIH1cbiAgfSwgW2luY29taW5nXSk7XG4gIHJldHVybiBjYWNoZTIuY3VycmVudC5zZXJpYWxpemVkID09PSBpbmNvbWluZy5zZXJpYWxpemVkID8gY2FjaGUyLmN1cnJlbnQucXVlcnlBcmdzIDogcXVlcnlBcmdzO1xufVxuXG4vLyBzcmMvcXVlcnkvcmVhY3QvdXNlU2hhbGxvd1N0YWJsZVZhbHVlLnRzXG5pbXBvcnQgeyB1c2VFZmZlY3QgYXMgdXNlRWZmZWN0MiwgdXNlUmVmIGFzIHVzZVJlZjIgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IHNoYWxsb3dFcXVhbCB9IGZyb20gXCJyZWFjdC1yZWR1eFwiO1xuZnVuY3Rpb24gdXNlU2hhbGxvd1N0YWJsZVZhbHVlKHZhbHVlKSB7XG4gIGNvbnN0IGNhY2hlMiA9IHVzZVJlZjIodmFsdWUpO1xuICB1c2VFZmZlY3QyKCgpID0+IHtcbiAgICBpZiAoIXNoYWxsb3dFcXVhbChjYWNoZTIuY3VycmVudCwgdmFsdWUpKSB7XG4gICAgICBjYWNoZTIuY3VycmVudCA9IHZhbHVlO1xuICAgIH1cbiAgfSwgW3ZhbHVlXSk7XG4gIHJldHVybiBzaGFsbG93RXF1YWwoY2FjaGUyLmN1cnJlbnQsIHZhbHVlKSA/IGNhY2hlMi5jdXJyZW50IDogdmFsdWU7XG59XG5cbi8vIHNyYy9xdWVyeS9yZWFjdC9idWlsZEhvb2tzLnRzXG52YXIgY2FuVXNlRE9NID0gKCkgPT4gISEodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2Ygd2luZG93LmRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCAhPT0gXCJ1bmRlZmluZWRcIik7XG52YXIgaXNET00gPSAvKiBAX19QVVJFX18gKi8gY2FuVXNlRE9NKCk7XG52YXIgaXNSdW5uaW5nSW5SZWFjdE5hdGl2ZSA9ICgpID0+IHR5cGVvZiBuYXZpZ2F0b3IgIT09IFwidW5kZWZpbmVkXCIgJiYgbmF2aWdhdG9yLnByb2R1Y3QgPT09IFwiUmVhY3ROYXRpdmVcIjtcbnZhciBpc1JlYWN0TmF0aXZlID0gLyogQF9fUFVSRV9fICovIGlzUnVubmluZ0luUmVhY3ROYXRpdmUoKTtcbnZhciBnZXRVc2VJc29tb3JwaGljTGF5b3V0RWZmZWN0ID0gKCkgPT4gaXNET00gfHwgaXNSZWFjdE5hdGl2ZSA/IHVzZUxheW91dEVmZmVjdCA6IHVzZUVmZmVjdDM7XG52YXIgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCA9IC8qIEBfX1BVUkVfXyAqLyBnZXRVc2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCk7XG52YXIgbm9QZW5kaW5nUXVlcnlTdGF0ZVNlbGVjdG9yID0gKHNlbGVjdGVkKSA9PiB7XG4gIGlmIChzZWxlY3RlZC5pc1VuaW5pdGlhbGl6ZWQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uc2VsZWN0ZWQsXG4gICAgICBpc1VuaW5pdGlhbGl6ZWQ6IGZhbHNlLFxuICAgICAgaXNGZXRjaGluZzogdHJ1ZSxcbiAgICAgIGlzTG9hZGluZzogc2VsZWN0ZWQuZGF0YSAhPT0gdm9pZCAwID8gZmFsc2UgOiB0cnVlLFxuICAgICAgc3RhdHVzOiBRdWVyeVN0YXR1cy5wZW5kaW5nXG4gICAgfTtcbiAgfVxuICByZXR1cm4gc2VsZWN0ZWQ7XG59O1xuZnVuY3Rpb24gYnVpbGRIb29rcyh7XG4gIGFwaSxcbiAgbW9kdWxlT3B0aW9uczoge1xuICAgIGJhdGNoLFxuICAgIGhvb2tzOiB7XG4gICAgICB1c2VEaXNwYXRjaCxcbiAgICAgIHVzZVNlbGVjdG9yLFxuICAgICAgdXNlU3RvcmVcbiAgICB9LFxuICAgIHVuc3RhYmxlX19zaWRlRWZmZWN0c0luUmVuZGVyLFxuICAgIGNyZWF0ZVNlbGVjdG9yOiBjcmVhdGVTZWxlY3RvcjJcbiAgfSxcbiAgc2VyaWFsaXplUXVlcnlBcmdzLFxuICBjb250ZXh0XG59KSB7XG4gIGNvbnN0IHVzZVBvc3NpYmx5SW1tZWRpYXRlRWZmZWN0ID0gdW5zdGFibGVfX3NpZGVFZmZlY3RzSW5SZW5kZXIgPyAoY2IpID0+IGNiKCkgOiB1c2VFZmZlY3QzO1xuICByZXR1cm4ge1xuICAgIGJ1aWxkUXVlcnlIb29rcyxcbiAgICBidWlsZE11dGF0aW9uSG9vayxcbiAgICB1c2VQcmVmZXRjaFxuICB9O1xuICBmdW5jdGlvbiBxdWVyeVN0YXRlUHJlU2VsZWN0b3IoY3VycmVudFN0YXRlLCBsYXN0UmVzdWx0LCBxdWVyeUFyZ3MpIHtcbiAgICBpZiAobGFzdFJlc3VsdD8uZW5kcG9pbnROYW1lICYmIGN1cnJlbnRTdGF0ZS5pc1VuaW5pdGlhbGl6ZWQpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZW5kcG9pbnROYW1lXG4gICAgICB9ID0gbGFzdFJlc3VsdDtcbiAgICAgIGNvbnN0IGVuZHBvaW50RGVmaW5pdGlvbiA9IGNvbnRleHQuZW5kcG9pbnREZWZpbml0aW9uc1tlbmRwb2ludE5hbWVdO1xuICAgICAgaWYgKHNlcmlhbGl6ZVF1ZXJ5QXJncyh7XG4gICAgICAgIHF1ZXJ5QXJnczogbGFzdFJlc3VsdC5vcmlnaW5hbEFyZ3MsXG4gICAgICAgIGVuZHBvaW50RGVmaW5pdGlvbixcbiAgICAgICAgZW5kcG9pbnROYW1lXG4gICAgICB9KSA9PT0gc2VyaWFsaXplUXVlcnlBcmdzKHtcbiAgICAgICAgcXVlcnlBcmdzLFxuICAgICAgICBlbmRwb2ludERlZmluaXRpb24sXG4gICAgICAgIGVuZHBvaW50TmFtZVxuICAgICAgfSkpIGxhc3RSZXN1bHQgPSB2b2lkIDA7XG4gICAgfVxuICAgIGxldCBkYXRhID0gY3VycmVudFN0YXRlLmlzU3VjY2VzcyA/IGN1cnJlbnRTdGF0ZS5kYXRhIDogbGFzdFJlc3VsdD8uZGF0YTtcbiAgICBpZiAoZGF0YSA9PT0gdm9pZCAwKSBkYXRhID0gY3VycmVudFN0YXRlLmRhdGE7XG4gICAgY29uc3QgaGFzRGF0YSA9IGRhdGEgIT09IHZvaWQgMDtcbiAgICBjb25zdCBpc0ZldGNoaW5nID0gY3VycmVudFN0YXRlLmlzTG9hZGluZztcbiAgICBjb25zdCBpc0xvYWRpbmcgPSAoIWxhc3RSZXN1bHQgfHwgbGFzdFJlc3VsdC5pc0xvYWRpbmcgfHwgbGFzdFJlc3VsdC5pc1VuaW5pdGlhbGl6ZWQpICYmICFoYXNEYXRhICYmIGlzRmV0Y2hpbmc7XG4gICAgY29uc3QgaXNTdWNjZXNzID0gY3VycmVudFN0YXRlLmlzU3VjY2VzcyB8fCBpc0ZldGNoaW5nICYmIGhhc0RhdGE7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmN1cnJlbnRTdGF0ZSxcbiAgICAgIGRhdGEsXG4gICAgICBjdXJyZW50RGF0YTogY3VycmVudFN0YXRlLmRhdGEsXG4gICAgICBpc0ZldGNoaW5nLFxuICAgICAgaXNMb2FkaW5nLFxuICAgICAgaXNTdWNjZXNzXG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiB1c2VQcmVmZXRjaChlbmRwb2ludE5hbWUsIGRlZmF1bHRPcHRpb25zKSB7XG4gICAgY29uc3QgZGlzcGF0Y2ggPSB1c2VEaXNwYXRjaCgpO1xuICAgIGNvbnN0IHN0YWJsZURlZmF1bHRPcHRpb25zID0gdXNlU2hhbGxvd1N0YWJsZVZhbHVlKGRlZmF1bHRPcHRpb25zKTtcbiAgICByZXR1cm4gdXNlQ2FsbGJhY2soKGFyZywgb3B0aW9ucykgPT4gZGlzcGF0Y2goYXBpLnV0aWwucHJlZmV0Y2goZW5kcG9pbnROYW1lLCBhcmcsIHtcbiAgICAgIC4uLnN0YWJsZURlZmF1bHRPcHRpb25zLFxuICAgICAgLi4ub3B0aW9uc1xuICAgIH0pKSwgW2VuZHBvaW50TmFtZSwgZGlzcGF0Y2gsIHN0YWJsZURlZmF1bHRPcHRpb25zXSk7XG4gIH1cbiAgZnVuY3Rpb24gYnVpbGRRdWVyeUhvb2tzKG5hbWUpIHtcbiAgICBjb25zdCB1c2VRdWVyeVN1YnNjcmlwdGlvbiA9IChhcmcsIHtcbiAgICAgIHJlZmV0Y2hPblJlY29ubmVjdCxcbiAgICAgIHJlZmV0Y2hPbkZvY3VzLFxuICAgICAgcmVmZXRjaE9uTW91bnRPckFyZ0NoYW5nZSxcbiAgICAgIHNraXAgPSBmYWxzZSxcbiAgICAgIHBvbGxpbmdJbnRlcnZhbCA9IDAsXG4gICAgICBza2lwUG9sbGluZ0lmVW5mb2N1c2VkID0gZmFsc2VcbiAgICB9ID0ge30pID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgaW5pdGlhdGVcbiAgICAgIH0gPSBhcGkuZW5kcG9pbnRzW25hbWVdO1xuICAgICAgY29uc3QgZGlzcGF0Y2ggPSB1c2VEaXNwYXRjaCgpO1xuICAgICAgY29uc3Qgc3Vic2NyaXB0aW9uU2VsZWN0b3JzUmVmID0gdXNlUmVmMyh2b2lkIDApO1xuICAgICAgaWYgKCFzdWJzY3JpcHRpb25TZWxlY3RvcnNSZWYuY3VycmVudCkge1xuICAgICAgICBjb25zdCByZXR1cm5lZFZhbHVlID0gZGlzcGF0Y2goYXBpLmludGVybmFsQWN0aW9ucy5pbnRlcm5hbF9nZXRSVEtRU3Vic2NyaXB0aW9ucygpKTtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgIGlmICh0eXBlb2YgcmV0dXJuZWRWYWx1ZSAhPT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgcmV0dXJuZWRWYWx1ZT8udHlwZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IF9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDM3KSA6IGBXYXJuaW5nOiBNaWRkbGV3YXJlIGZvciBSVEstUXVlcnkgQVBJIGF0IHJlZHVjZXJQYXRoIFwiJHthcGkucmVkdWNlclBhdGh9XCIgaGFzIG5vdCBiZWVuIGFkZGVkIHRvIHRoZSBzdG9yZS5cbiAgICBZb3UgbXVzdCBhZGQgdGhlIG1pZGRsZXdhcmUgZm9yIFJUSy1RdWVyeSB0byBmdW5jdGlvbiBjb3JyZWN0bHkhYCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN1YnNjcmlwdGlvblNlbGVjdG9yc1JlZi5jdXJyZW50ID0gcmV0dXJuZWRWYWx1ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHN0YWJsZUFyZyA9IHVzZVN0YWJsZVF1ZXJ5QXJncyhcbiAgICAgICAgc2tpcCA/IHNraXBUb2tlbiA6IGFyZyxcbiAgICAgICAgLy8gRXZlbiBpZiB0aGUgdXNlciBwcm92aWRlZCBhIHBlci1lbmRwb2ludCBgc2VyaWFsaXplUXVlcnlBcmdzYCB3aXRoXG4gICAgICAgIC8vIGEgY29uc2lzdGVudCByZXR1cm4gdmFsdWUsIF9oZXJlXyB3ZSB3YW50IHRvIHVzZSB0aGUgZGVmYXVsdCBiZWhhdmlvclxuICAgICAgICAvLyBzbyB3ZSBjYW4gdGVsbCBpZiBfYW55dGhpbmdfIGFjdHVhbGx5IGNoYW5nZWQuIE90aGVyd2lzZSwgd2UgY2FuIGVuZCB1cFxuICAgICAgICAvLyB3aXRoIGEgY2FzZSB3aGVyZSB0aGUgcXVlcnkgYXJncyBkaWQgY2hhbmdlIGJ1dCB0aGUgc2VyaWFsaXphdGlvbiBkb2Vzbid0LFxuICAgICAgICAvLyBhbmQgdGhlbiB3ZSBuZXZlciB0cnkgdG8gaW5pdGlhdGUgYSByZWZldGNoLlxuICAgICAgICBkZWZhdWx0U2VyaWFsaXplUXVlcnlBcmdzLFxuICAgICAgICBjb250ZXh0LmVuZHBvaW50RGVmaW5pdGlvbnNbbmFtZV0sXG4gICAgICAgIG5hbWVcbiAgICAgICk7XG4gICAgICBjb25zdCBzdGFibGVTdWJzY3JpcHRpb25PcHRpb25zID0gdXNlU2hhbGxvd1N0YWJsZVZhbHVlKHtcbiAgICAgICAgcmVmZXRjaE9uUmVjb25uZWN0LFxuICAgICAgICByZWZldGNoT25Gb2N1cyxcbiAgICAgICAgcG9sbGluZ0ludGVydmFsLFxuICAgICAgICBza2lwUG9sbGluZ0lmVW5mb2N1c2VkXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IGxhc3RSZW5kZXJIYWRTdWJzY3JpcHRpb24gPSB1c2VSZWYzKGZhbHNlKTtcbiAgICAgIGNvbnN0IHByb21pc2VSZWYgPSB1c2VSZWYzKHZvaWQgMCk7XG4gICAgICBsZXQge1xuICAgICAgICBxdWVyeUNhY2hlS2V5LFxuICAgICAgICByZXF1ZXN0SWRcbiAgICAgIH0gPSBwcm9taXNlUmVmLmN1cnJlbnQgfHwge307XG4gICAgICBsZXQgY3VycmVudFJlbmRlckhhc1N1YnNjcmlwdGlvbiA9IGZhbHNlO1xuICAgICAgaWYgKHF1ZXJ5Q2FjaGVLZXkgJiYgcmVxdWVzdElkKSB7XG4gICAgICAgIGN1cnJlbnRSZW5kZXJIYXNTdWJzY3JpcHRpb24gPSBzdWJzY3JpcHRpb25TZWxlY3RvcnNSZWYuY3VycmVudC5pc1JlcXVlc3RTdWJzY3JpYmVkKHF1ZXJ5Q2FjaGVLZXksIHJlcXVlc3RJZCk7XG4gICAgICB9XG4gICAgICBjb25zdCBzdWJzY3JpcHRpb25SZW1vdmVkID0gIWN1cnJlbnRSZW5kZXJIYXNTdWJzY3JpcHRpb24gJiYgbGFzdFJlbmRlckhhZFN1YnNjcmlwdGlvbi5jdXJyZW50O1xuICAgICAgdXNlUG9zc2libHlJbW1lZGlhdGVFZmZlY3QoKCkgPT4ge1xuICAgICAgICBsYXN0UmVuZGVySGFkU3Vic2NyaXB0aW9uLmN1cnJlbnQgPSBjdXJyZW50UmVuZGVySGFzU3Vic2NyaXB0aW9uO1xuICAgICAgfSk7XG4gICAgICB1c2VQb3NzaWJseUltbWVkaWF0ZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmIChzdWJzY3JpcHRpb25SZW1vdmVkKSB7XG4gICAgICAgICAgcHJvbWlzZVJlZi5jdXJyZW50ID0gdm9pZCAwO1xuICAgICAgICB9XG4gICAgICB9LCBbc3Vic2NyaXB0aW9uUmVtb3ZlZF0pO1xuICAgICAgdXNlUG9zc2libHlJbW1lZGlhdGVFZmZlY3QoKCkgPT4ge1xuICAgICAgICBjb25zdCBsYXN0UHJvbWlzZSA9IHByb21pc2VSZWYuY3VycmVudDtcbiAgICAgICAgaWYgKHR5cGVvZiBwcm9jZXNzICE9PSBcInVuZGVmaW5lZFwiICYmIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInJlbW92ZU1lT25Db21waWxhdGlvblwiKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coc3Vic2NyaXB0aW9uUmVtb3ZlZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YWJsZUFyZyA9PT0gc2tpcFRva2VuKSB7XG4gICAgICAgICAgbGFzdFByb21pc2U/LnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgcHJvbWlzZVJlZi5jdXJyZW50ID0gdm9pZCAwO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsYXN0U3Vic2NyaXB0aW9uT3B0aW9ucyA9IHByb21pc2VSZWYuY3VycmVudD8uc3Vic2NyaXB0aW9uT3B0aW9ucztcbiAgICAgICAgaWYgKCFsYXN0UHJvbWlzZSB8fCBsYXN0UHJvbWlzZS5hcmcgIT09IHN0YWJsZUFyZykge1xuICAgICAgICAgIGxhc3RQcm9taXNlPy51bnN1YnNjcmliZSgpO1xuICAgICAgICAgIGNvbnN0IHByb21pc2UgPSBkaXNwYXRjaChpbml0aWF0ZShzdGFibGVBcmcsIHtcbiAgICAgICAgICAgIHN1YnNjcmlwdGlvbk9wdGlvbnM6IHN0YWJsZVN1YnNjcmlwdGlvbk9wdGlvbnMsXG4gICAgICAgICAgICBmb3JjZVJlZmV0Y2g6IHJlZmV0Y2hPbk1vdW50T3JBcmdDaGFuZ2VcbiAgICAgICAgICB9KSk7XG4gICAgICAgICAgcHJvbWlzZVJlZi5jdXJyZW50ID0gcHJvbWlzZTtcbiAgICAgICAgfSBlbHNlIGlmIChzdGFibGVTdWJzY3JpcHRpb25PcHRpb25zICE9PSBsYXN0U3Vic2NyaXB0aW9uT3B0aW9ucykge1xuICAgICAgICAgIGxhc3RQcm9taXNlLnVwZGF0ZVN1YnNjcmlwdGlvbk9wdGlvbnMoc3RhYmxlU3Vic2NyaXB0aW9uT3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgIH0sIFtkaXNwYXRjaCwgaW5pdGlhdGUsIHJlZmV0Y2hPbk1vdW50T3JBcmdDaGFuZ2UsIHN0YWJsZUFyZywgc3RhYmxlU3Vic2NyaXB0aW9uT3B0aW9ucywgc3Vic2NyaXB0aW9uUmVtb3ZlZF0pO1xuICAgICAgdXNlRWZmZWN0MygoKSA9PiB7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgcHJvbWlzZVJlZi5jdXJyZW50Py51bnN1YnNjcmliZSgpO1xuICAgICAgICAgIHByb21pc2VSZWYuY3VycmVudCA9IHZvaWQgMDtcbiAgICAgICAgfTtcbiAgICAgIH0sIFtdKTtcbiAgICAgIHJldHVybiB1c2VNZW1vMigoKSA9PiAoe1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBtZXRob2QgdG8gbWFudWFsbHkgcmVmZXRjaCBkYXRhIGZvciB0aGUgcXVlcnlcbiAgICAgICAgICovXG4gICAgICAgIHJlZmV0Y2g6ICgpID0+IHtcbiAgICAgICAgICBpZiAoIXByb21pc2VSZWYuY3VycmVudCkgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IF9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlMigzOCkgOiBcIkNhbm5vdCByZWZldGNoIGEgcXVlcnkgdGhhdCBoYXMgbm90IGJlZW4gc3RhcnRlZCB5ZXQuXCIpO1xuICAgICAgICAgIHJldHVybiBwcm9taXNlUmVmLmN1cnJlbnQ/LnJlZmV0Y2goKTtcbiAgICAgICAgfVxuICAgICAgfSksIFtdKTtcbiAgICB9O1xuICAgIGNvbnN0IHVzZUxhenlRdWVyeVN1YnNjcmlwdGlvbiA9ICh7XG4gICAgICByZWZldGNoT25SZWNvbm5lY3QsXG4gICAgICByZWZldGNoT25Gb2N1cyxcbiAgICAgIHBvbGxpbmdJbnRlcnZhbCA9IDAsXG4gICAgICBza2lwUG9sbGluZ0lmVW5mb2N1c2VkID0gZmFsc2VcbiAgICB9ID0ge30pID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgaW5pdGlhdGVcbiAgICAgIH0gPSBhcGkuZW5kcG9pbnRzW25hbWVdO1xuICAgICAgY29uc3QgZGlzcGF0Y2ggPSB1c2VEaXNwYXRjaCgpO1xuICAgICAgY29uc3QgW2FyZywgc2V0QXJnXSA9IHVzZVN0YXRlKFVOSU5JVElBTElaRURfVkFMVUUpO1xuICAgICAgY29uc3QgcHJvbWlzZVJlZiA9IHVzZVJlZjModm9pZCAwKTtcbiAgICAgIGNvbnN0IHN0YWJsZVN1YnNjcmlwdGlvbk9wdGlvbnMgPSB1c2VTaGFsbG93U3RhYmxlVmFsdWUoe1xuICAgICAgICByZWZldGNoT25SZWNvbm5lY3QsXG4gICAgICAgIHJlZmV0Y2hPbkZvY3VzLFxuICAgICAgICBwb2xsaW5nSW50ZXJ2YWwsXG4gICAgICAgIHNraXBQb2xsaW5nSWZVbmZvY3VzZWRcbiAgICAgIH0pO1xuICAgICAgdXNlUG9zc2libHlJbW1lZGlhdGVFZmZlY3QoKCkgPT4ge1xuICAgICAgICBjb25zdCBsYXN0U3Vic2NyaXB0aW9uT3B0aW9ucyA9IHByb21pc2VSZWYuY3VycmVudD8uc3Vic2NyaXB0aW9uT3B0aW9ucztcbiAgICAgICAgaWYgKHN0YWJsZVN1YnNjcmlwdGlvbk9wdGlvbnMgIT09IGxhc3RTdWJzY3JpcHRpb25PcHRpb25zKSB7XG4gICAgICAgICAgcHJvbWlzZVJlZi5jdXJyZW50Py51cGRhdGVTdWJzY3JpcHRpb25PcHRpb25zKHN0YWJsZVN1YnNjcmlwdGlvbk9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICB9LCBbc3RhYmxlU3Vic2NyaXB0aW9uT3B0aW9uc10pO1xuICAgICAgY29uc3Qgc3Vic2NyaXB0aW9uT3B0aW9uc1JlZiA9IHVzZVJlZjMoc3RhYmxlU3Vic2NyaXB0aW9uT3B0aW9ucyk7XG4gICAgICB1c2VQb3NzaWJseUltbWVkaWF0ZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIHN1YnNjcmlwdGlvbk9wdGlvbnNSZWYuY3VycmVudCA9IHN0YWJsZVN1YnNjcmlwdGlvbk9wdGlvbnM7XG4gICAgICB9LCBbc3RhYmxlU3Vic2NyaXB0aW9uT3B0aW9uc10pO1xuICAgICAgY29uc3QgdHJpZ2dlciA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uKGFyZzIsIHByZWZlckNhY2hlVmFsdWUgPSBmYWxzZSkge1xuICAgICAgICBsZXQgcHJvbWlzZTtcbiAgICAgICAgYmF0Y2goKCkgPT4ge1xuICAgICAgICAgIHByb21pc2VSZWYuY3VycmVudD8udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICBwcm9taXNlUmVmLmN1cnJlbnQgPSBwcm9taXNlID0gZGlzcGF0Y2goaW5pdGlhdGUoYXJnMiwge1xuICAgICAgICAgICAgc3Vic2NyaXB0aW9uT3B0aW9uczogc3Vic2NyaXB0aW9uT3B0aW9uc1JlZi5jdXJyZW50LFxuICAgICAgICAgICAgZm9yY2VSZWZldGNoOiAhcHJlZmVyQ2FjaGVWYWx1ZVxuICAgICAgICAgIH0pKTtcbiAgICAgICAgICBzZXRBcmcoYXJnMik7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICAgIH0sIFtkaXNwYXRjaCwgaW5pdGlhdGVdKTtcbiAgICAgIHVzZUVmZmVjdDMoKCkgPT4ge1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgIHByb21pc2VSZWY/LmN1cnJlbnQ/LnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH07XG4gICAgICB9LCBbXSk7XG4gICAgICB1c2VFZmZlY3QzKCgpID0+IHtcbiAgICAgICAgaWYgKGFyZyAhPT0gVU5JTklUSUFMSVpFRF9WQUxVRSAmJiAhcHJvbWlzZVJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgdHJpZ2dlcihhcmcsIHRydWUpO1xuICAgICAgICB9XG4gICAgICB9LCBbYXJnLCB0cmlnZ2VyXSk7XG4gICAgICByZXR1cm4gdXNlTWVtbzIoKCkgPT4gW3RyaWdnZXIsIGFyZ10sIFt0cmlnZ2VyLCBhcmddKTtcbiAgICB9O1xuICAgIGNvbnN0IHVzZVF1ZXJ5U3RhdGUgPSAoYXJnLCB7XG4gICAgICBza2lwID0gZmFsc2UsXG4gICAgICBzZWxlY3RGcm9tUmVzdWx0XG4gICAgfSA9IHt9KSA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHNlbGVjdFxuICAgICAgfSA9IGFwaS5lbmRwb2ludHNbbmFtZV07XG4gICAgICBjb25zdCBzdGFibGVBcmcgPSB1c2VTdGFibGVRdWVyeUFyZ3Moc2tpcCA/IHNraXBUb2tlbiA6IGFyZywgc2VyaWFsaXplUXVlcnlBcmdzLCBjb250ZXh0LmVuZHBvaW50RGVmaW5pdGlvbnNbbmFtZV0sIG5hbWUpO1xuICAgICAgY29uc3QgbGFzdFZhbHVlID0gdXNlUmVmMyh2b2lkIDApO1xuICAgICAgY29uc3Qgc2VsZWN0RGVmYXVsdFJlc3VsdCA9IHVzZU1lbW8yKCgpID0+IGNyZWF0ZVNlbGVjdG9yMihbc2VsZWN0KHN0YWJsZUFyZyksIChfLCBsYXN0UmVzdWx0KSA9PiBsYXN0UmVzdWx0LCAoXykgPT4gc3RhYmxlQXJnXSwgcXVlcnlTdGF0ZVByZVNlbGVjdG9yLCB7XG4gICAgICAgIG1lbW9pemVPcHRpb25zOiB7XG4gICAgICAgICAgcmVzdWx0RXF1YWxpdHlDaGVjazogc2hhbGxvd0VxdWFsMlxuICAgICAgICB9XG4gICAgICB9KSwgW3NlbGVjdCwgc3RhYmxlQXJnXSk7XG4gICAgICBjb25zdCBxdWVyeVNlbGVjdG9yID0gdXNlTWVtbzIoKCkgPT4gc2VsZWN0RnJvbVJlc3VsdCA/IGNyZWF0ZVNlbGVjdG9yMihbc2VsZWN0RGVmYXVsdFJlc3VsdF0sIHNlbGVjdEZyb21SZXN1bHQsIHtcbiAgICAgICAgZGV2TW9kZUNoZWNrczoge1xuICAgICAgICAgIGlkZW50aXR5RnVuY3Rpb25DaGVjazogXCJuZXZlclwiXG4gICAgICAgIH1cbiAgICAgIH0pIDogc2VsZWN0RGVmYXVsdFJlc3VsdCwgW3NlbGVjdERlZmF1bHRSZXN1bHQsIHNlbGVjdEZyb21SZXN1bHRdKTtcbiAgICAgIGNvbnN0IGN1cnJlbnRTdGF0ZSA9IHVzZVNlbGVjdG9yKChzdGF0ZSkgPT4gcXVlcnlTZWxlY3RvcihzdGF0ZSwgbGFzdFZhbHVlLmN1cnJlbnQpLCBzaGFsbG93RXF1YWwyKTtcbiAgICAgIGNvbnN0IHN0b3JlID0gdXNlU3RvcmUoKTtcbiAgICAgIGNvbnN0IG5ld0xhc3RWYWx1ZSA9IHNlbGVjdERlZmF1bHRSZXN1bHQoc3RvcmUuZ2V0U3RhdGUoKSwgbGFzdFZhbHVlLmN1cnJlbnQpO1xuICAgICAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGxhc3RWYWx1ZS5jdXJyZW50ID0gbmV3TGFzdFZhbHVlO1xuICAgICAgfSwgW25ld0xhc3RWYWx1ZV0pO1xuICAgICAgcmV0dXJuIGN1cnJlbnRTdGF0ZTtcbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICB1c2VRdWVyeVN0YXRlLFxuICAgICAgdXNlUXVlcnlTdWJzY3JpcHRpb24sXG4gICAgICB1c2VMYXp5UXVlcnlTdWJzY3JpcHRpb24sXG4gICAgICB1c2VMYXp5UXVlcnkob3B0aW9ucykge1xuICAgICAgICBjb25zdCBbdHJpZ2dlciwgYXJnXSA9IHVzZUxhenlRdWVyeVN1YnNjcmlwdGlvbihvcHRpb25zKTtcbiAgICAgICAgY29uc3QgcXVlcnlTdGF0ZVJlc3VsdHMgPSB1c2VRdWVyeVN0YXRlKGFyZywge1xuICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgc2tpcDogYXJnID09PSBVTklOSVRJQUxJWkVEX1ZBTFVFXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBpbmZvID0gdXNlTWVtbzIoKCkgPT4gKHtcbiAgICAgICAgICBsYXN0QXJnOiBhcmdcbiAgICAgICAgfSksIFthcmddKTtcbiAgICAgICAgcmV0dXJuIHVzZU1lbW8yKCgpID0+IFt0cmlnZ2VyLCBxdWVyeVN0YXRlUmVzdWx0cywgaW5mb10sIFt0cmlnZ2VyLCBxdWVyeVN0YXRlUmVzdWx0cywgaW5mb10pO1xuICAgICAgfSxcbiAgICAgIHVzZVF1ZXJ5KGFyZywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBxdWVyeVN1YnNjcmlwdGlvblJlc3VsdHMgPSB1c2VRdWVyeVN1YnNjcmlwdGlvbihhcmcsIG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBxdWVyeVN0YXRlUmVzdWx0cyA9IHVzZVF1ZXJ5U3RhdGUoYXJnLCB7XG4gICAgICAgICAgc2VsZWN0RnJvbVJlc3VsdDogYXJnID09PSBza2lwVG9rZW4gfHwgb3B0aW9ucz8uc2tpcCA/IHZvaWQgMCA6IG5vUGVuZGluZ1F1ZXJ5U3RhdGVTZWxlY3RvcixcbiAgICAgICAgICAuLi5vcHRpb25zXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgZGF0YSxcbiAgICAgICAgICBzdGF0dXMsXG4gICAgICAgICAgaXNMb2FkaW5nLFxuICAgICAgICAgIGlzU3VjY2VzcyxcbiAgICAgICAgICBpc0Vycm9yLFxuICAgICAgICAgIGVycm9yXG4gICAgICAgIH0gPSBxdWVyeVN0YXRlUmVzdWx0cztcbiAgICAgICAgdXNlRGVidWdWYWx1ZSh7XG4gICAgICAgICAgZGF0YSxcbiAgICAgICAgICBzdGF0dXMsXG4gICAgICAgICAgaXNMb2FkaW5nLFxuICAgICAgICAgIGlzU3VjY2VzcyxcbiAgICAgICAgICBpc0Vycm9yLFxuICAgICAgICAgIGVycm9yXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdXNlTWVtbzIoKCkgPT4gKHtcbiAgICAgICAgICAuLi5xdWVyeVN0YXRlUmVzdWx0cyxcbiAgICAgICAgICAuLi5xdWVyeVN1YnNjcmlwdGlvblJlc3VsdHNcbiAgICAgICAgfSksIFtxdWVyeVN0YXRlUmVzdWx0cywgcXVlcnlTdWJzY3JpcHRpb25SZXN1bHRzXSk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBidWlsZE11dGF0aW9uSG9vayhuYW1lKSB7XG4gICAgcmV0dXJuICh7XG4gICAgICBzZWxlY3RGcm9tUmVzdWx0LFxuICAgICAgZml4ZWRDYWNoZUtleVxuICAgIH0gPSB7fSkgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICBzZWxlY3QsXG4gICAgICAgIGluaXRpYXRlXG4gICAgICB9ID0gYXBpLmVuZHBvaW50c1tuYW1lXTtcbiAgICAgIGNvbnN0IGRpc3BhdGNoID0gdXNlRGlzcGF0Y2goKTtcbiAgICAgIGNvbnN0IFtwcm9taXNlLCBzZXRQcm9taXNlXSA9IHVzZVN0YXRlKCk7XG4gICAgICB1c2VFZmZlY3QzKCgpID0+ICgpID0+IHtcbiAgICAgICAgaWYgKCFwcm9taXNlPy5hcmcuZml4ZWRDYWNoZUtleSkge1xuICAgICAgICAgIHByb21pc2U/LnJlc2V0KCk7XG4gICAgICAgIH1cbiAgICAgIH0sIFtwcm9taXNlXSk7XG4gICAgICBjb25zdCB0cmlnZ2VyTXV0YXRpb24gPSB1c2VDYWxsYmFjayhmdW5jdGlvbihhcmcpIHtcbiAgICAgICAgY29uc3QgcHJvbWlzZTIgPSBkaXNwYXRjaChpbml0aWF0ZShhcmcsIHtcbiAgICAgICAgICBmaXhlZENhY2hlS2V5XG4gICAgICAgIH0pKTtcbiAgICAgICAgc2V0UHJvbWlzZShwcm9taXNlMik7XG4gICAgICAgIHJldHVybiBwcm9taXNlMjtcbiAgICAgIH0sIFtkaXNwYXRjaCwgaW5pdGlhdGUsIGZpeGVkQ2FjaGVLZXldKTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcmVxdWVzdElkXG4gICAgICB9ID0gcHJvbWlzZSB8fCB7fTtcbiAgICAgIGNvbnN0IHNlbGVjdERlZmF1bHRSZXN1bHQgPSB1c2VNZW1vMigoKSA9PiBzZWxlY3Qoe1xuICAgICAgICBmaXhlZENhY2hlS2V5LFxuICAgICAgICByZXF1ZXN0SWQ6IHByb21pc2U/LnJlcXVlc3RJZFxuICAgICAgfSksIFtmaXhlZENhY2hlS2V5LCBwcm9taXNlLCBzZWxlY3RdKTtcbiAgICAgIGNvbnN0IG11dGF0aW9uU2VsZWN0b3IgPSB1c2VNZW1vMigoKSA9PiBzZWxlY3RGcm9tUmVzdWx0ID8gY3JlYXRlU2VsZWN0b3IyKFtzZWxlY3REZWZhdWx0UmVzdWx0XSwgc2VsZWN0RnJvbVJlc3VsdCkgOiBzZWxlY3REZWZhdWx0UmVzdWx0LCBbc2VsZWN0RnJvbVJlc3VsdCwgc2VsZWN0RGVmYXVsdFJlc3VsdF0pO1xuICAgICAgY29uc3QgY3VycmVudFN0YXRlID0gdXNlU2VsZWN0b3IobXV0YXRpb25TZWxlY3Rvciwgc2hhbGxvd0VxdWFsMik7XG4gICAgICBjb25zdCBvcmlnaW5hbEFyZ3MgPSBmaXhlZENhY2hlS2V5ID09IG51bGwgPyBwcm9taXNlPy5hcmcub3JpZ2luYWxBcmdzIDogdm9pZCAwO1xuICAgICAgY29uc3QgcmVzZXQgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIGJhdGNoKCgpID0+IHtcbiAgICAgICAgICBpZiAocHJvbWlzZSkge1xuICAgICAgICAgICAgc2V0UHJvbWlzZSh2b2lkIDApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZml4ZWRDYWNoZUtleSkge1xuICAgICAgICAgICAgZGlzcGF0Y2goYXBpLmludGVybmFsQWN0aW9ucy5yZW1vdmVNdXRhdGlvblJlc3VsdCh7XG4gICAgICAgICAgICAgIHJlcXVlc3RJZCxcbiAgICAgICAgICAgICAgZml4ZWRDYWNoZUtleVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9LCBbZGlzcGF0Y2gsIGZpeGVkQ2FjaGVLZXksIHByb21pc2UsIHJlcXVlc3RJZF0pO1xuICAgICAgY29uc3Qge1xuICAgICAgICBlbmRwb2ludE5hbWUsXG4gICAgICAgIGRhdGEsXG4gICAgICAgIHN0YXR1cyxcbiAgICAgICAgaXNMb2FkaW5nLFxuICAgICAgICBpc1N1Y2Nlc3MsXG4gICAgICAgIGlzRXJyb3IsXG4gICAgICAgIGVycm9yXG4gICAgICB9ID0gY3VycmVudFN0YXRlO1xuICAgICAgdXNlRGVidWdWYWx1ZSh7XG4gICAgICAgIGVuZHBvaW50TmFtZSxcbiAgICAgICAgZGF0YSxcbiAgICAgICAgc3RhdHVzLFxuICAgICAgICBpc0xvYWRpbmcsXG4gICAgICAgIGlzU3VjY2VzcyxcbiAgICAgICAgaXNFcnJvcixcbiAgICAgICAgZXJyb3JcbiAgICAgIH0pO1xuICAgICAgY29uc3QgZmluYWxTdGF0ZSA9IHVzZU1lbW8yKCgpID0+ICh7XG4gICAgICAgIC4uLmN1cnJlbnRTdGF0ZSxcbiAgICAgICAgb3JpZ2luYWxBcmdzLFxuICAgICAgICByZXNldFxuICAgICAgfSksIFtjdXJyZW50U3RhdGUsIG9yaWdpbmFsQXJncywgcmVzZXRdKTtcbiAgICAgIHJldHVybiB1c2VNZW1vMigoKSA9PiBbdHJpZ2dlck11dGF0aW9uLCBmaW5hbFN0YXRlXSwgW3RyaWdnZXJNdXRhdGlvbiwgZmluYWxTdGF0ZV0pO1xuICAgIH07XG4gIH1cbn1cblxuLy8gc3JjL3F1ZXJ5L3JlYWN0L21vZHVsZS50c1xudmFyIHJlYWN0SG9va3NNb2R1bGVOYW1lID0gLyogQF9fUFVSRV9fICovIFN5bWJvbCgpO1xudmFyIHJlYWN0SG9va3NNb2R1bGUgPSAoe1xuICBiYXRjaCA9IHJyQmF0Y2gsXG4gIGhvb2tzID0ge1xuICAgIHVzZURpc3BhdGNoOiByclVzZURpc3BhdGNoLFxuICAgIHVzZVNlbGVjdG9yOiByclVzZVNlbGVjdG9yLFxuICAgIHVzZVN0b3JlOiByclVzZVN0b3JlXG4gIH0sXG4gIGNyZWF0ZVNlbGVjdG9yOiBjcmVhdGVTZWxlY3RvcjIgPSBfY3JlYXRlU2VsZWN0b3IsXG4gIHVuc3RhYmxlX19zaWRlRWZmZWN0c0luUmVuZGVyID0gZmFsc2UsXG4gIC4uLnJlc3Rcbn0gPSB7fSkgPT4ge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgY29uc3QgaG9va05hbWVzID0gW1widXNlRGlzcGF0Y2hcIiwgXCJ1c2VTZWxlY3RvclwiLCBcInVzZVN0b3JlXCJdO1xuICAgIGxldCB3YXJuZWQgPSBmYWxzZTtcbiAgICBmb3IgKGNvbnN0IGhvb2tOYW1lIG9mIGhvb2tOYW1lcykge1xuICAgICAgaWYgKGNvdW50T2JqZWN0S2V5cyhyZXN0KSA+IDApIHtcbiAgICAgICAgaWYgKHJlc3RbaG9va05hbWVdKSB7XG4gICAgICAgICAgaWYgKCF3YXJuZWQpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIkFzIG9mIFJUSyAyLjAsIHRoZSBob29rcyBub3cgbmVlZCB0byBiZSBzcGVjaWZpZWQgYXMgb25lIG9iamVjdCwgcHJvdmlkZWQgdW5kZXIgYSBgaG9va3NgIGtleTpcXG5gcmVhY3RIb29rc01vZHVsZSh7IGhvb2tzOiB7IHVzZURpc3BhdGNoLCB1c2VTZWxlY3RvciwgdXNlU3RvcmUgfSB9KWBcIik7XG4gICAgICAgICAgICB3YXJuZWQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBob29rc1tob29rTmFtZV0gPSByZXN0W2hvb2tOYW1lXTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgaG9va3NbaG9va05hbWVdICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IF9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlMygzNikgOiBgV2hlbiB1c2luZyBjdXN0b20gaG9va3MgZm9yIGNvbnRleHQsIGFsbCAke2hvb2tOYW1lcy5sZW5ndGh9IGhvb2tzIG5lZWQgdG8gYmUgcHJvdmlkZWQ6ICR7aG9va05hbWVzLmpvaW4oXCIsIFwiKX0uXG5Ib29rICR7aG9va05hbWV9IHdhcyBlaXRoZXIgbm90IHByb3ZpZGVkIG9yIG5vdCBhIGZ1bmN0aW9uLmApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIG5hbWU6IHJlYWN0SG9va3NNb2R1bGVOYW1lLFxuICAgIGluaXQoYXBpLCB7XG4gICAgICBzZXJpYWxpemVRdWVyeUFyZ3NcbiAgICB9LCBjb250ZXh0KSB7XG4gICAgICBjb25zdCBhbnlBcGkgPSBhcGk7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGJ1aWxkUXVlcnlIb29rcyxcbiAgICAgICAgYnVpbGRNdXRhdGlvbkhvb2ssXG4gICAgICAgIHVzZVByZWZldGNoXG4gICAgICB9ID0gYnVpbGRIb29rcyh7XG4gICAgICAgIGFwaSxcbiAgICAgICAgbW9kdWxlT3B0aW9uczoge1xuICAgICAgICAgIGJhdGNoLFxuICAgICAgICAgIGhvb2tzLFxuICAgICAgICAgIHVuc3RhYmxlX19zaWRlRWZmZWN0c0luUmVuZGVyLFxuICAgICAgICAgIGNyZWF0ZVNlbGVjdG9yOiBjcmVhdGVTZWxlY3RvcjJcbiAgICAgICAgfSxcbiAgICAgICAgc2VyaWFsaXplUXVlcnlBcmdzLFxuICAgICAgICBjb250ZXh0XG4gICAgICB9KTtcbiAgICAgIHNhZmVBc3NpZ24oYW55QXBpLCB7XG4gICAgICAgIHVzZVByZWZldGNoXG4gICAgICB9KTtcbiAgICAgIHNhZmVBc3NpZ24oY29udGV4dCwge1xuICAgICAgICBiYXRjaFxuICAgICAgfSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpbmplY3RFbmRwb2ludChlbmRwb2ludE5hbWUsIGRlZmluaXRpb24pIHtcbiAgICAgICAgICBpZiAoaXNRdWVyeURlZmluaXRpb24oZGVmaW5pdGlvbikpIHtcbiAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAgdXNlUXVlcnksXG4gICAgICAgICAgICAgIHVzZUxhenlRdWVyeSxcbiAgICAgICAgICAgICAgdXNlTGF6eVF1ZXJ5U3Vic2NyaXB0aW9uLFxuICAgICAgICAgICAgICB1c2VRdWVyeVN0YXRlLFxuICAgICAgICAgICAgICB1c2VRdWVyeVN1YnNjcmlwdGlvblxuICAgICAgICAgICAgfSA9IGJ1aWxkUXVlcnlIb29rcyhlbmRwb2ludE5hbWUpO1xuICAgICAgICAgICAgc2FmZUFzc2lnbihhbnlBcGkuZW5kcG9pbnRzW2VuZHBvaW50TmFtZV0sIHtcbiAgICAgICAgICAgICAgdXNlUXVlcnksXG4gICAgICAgICAgICAgIHVzZUxhenlRdWVyeSxcbiAgICAgICAgICAgICAgdXNlTGF6eVF1ZXJ5U3Vic2NyaXB0aW9uLFxuICAgICAgICAgICAgICB1c2VRdWVyeVN0YXRlLFxuICAgICAgICAgICAgICB1c2VRdWVyeVN1YnNjcmlwdGlvblxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhcGlbYHVzZSR7Y2FwaXRhbGl6ZShlbmRwb2ludE5hbWUpfVF1ZXJ5YF0gPSB1c2VRdWVyeTtcbiAgICAgICAgICAgIGFwaVtgdXNlTGF6eSR7Y2FwaXRhbGl6ZShlbmRwb2ludE5hbWUpfVF1ZXJ5YF0gPSB1c2VMYXp5UXVlcnk7XG4gICAgICAgICAgfSBlbHNlIGlmIChpc011dGF0aW9uRGVmaW5pdGlvbihkZWZpbml0aW9uKSkge1xuICAgICAgICAgICAgY29uc3QgdXNlTXV0YXRpb24gPSBidWlsZE11dGF0aW9uSG9vayhlbmRwb2ludE5hbWUpO1xuICAgICAgICAgICAgc2FmZUFzc2lnbihhbnlBcGkuZW5kcG9pbnRzW2VuZHBvaW50TmFtZV0sIHtcbiAgICAgICAgICAgICAgdXNlTXV0YXRpb25cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYXBpW2B1c2Uke2NhcGl0YWxpemUoZW5kcG9pbnROYW1lKX1NdXRhdGlvbmBdID0gdXNlTXV0YXRpb247XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgfTtcbn07XG5cbi8vIHNyYy9xdWVyeS9yZWFjdC9pbmRleC50c1xuZXhwb3J0ICogZnJvbSBcIkByZWR1eGpzL3Rvb2xraXQvcXVlcnlcIjtcblxuLy8gc3JjL3F1ZXJ5L3JlYWN0L0FwaVByb3ZpZGVyLnRzeFxuaW1wb3J0IHsgY29uZmlndXJlU3RvcmUsIGZvcm1hdFByb2RFcnJvck1lc3NhZ2UgYXMgX2Zvcm1hdFByb2RFcnJvck1lc3NhZ2U0IH0gZnJvbSBcIkByZWR1eGpzL3Rvb2xraXRcIjtcbmltcG9ydCB7IHVzZUNvbnRleHQgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IHVzZUVmZmVjdCBhcyB1c2VFZmZlY3Q0IH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IFByb3ZpZGVyLCBSZWFjdFJlZHV4Q29udGV4dCB9IGZyb20gXCJyZWFjdC1yZWR1eFwiO1xuaW1wb3J0IHsgc2V0dXBMaXN0ZW5lcnMgfSBmcm9tIFwiQHJlZHV4anMvdG9vbGtpdC9xdWVyeVwiO1xuZnVuY3Rpb24gQXBpUHJvdmlkZXIocHJvcHMpIHtcbiAgY29uc3QgY29udGV4dCA9IHByb3BzLmNvbnRleHQgfHwgUmVhY3RSZWR1eENvbnRleHQ7XG4gIGNvbnN0IGV4aXN0aW5nQ29udGV4dCA9IHVzZUNvbnRleHQoY29udGV4dCk7XG4gIGlmIChleGlzdGluZ0NvbnRleHQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gX2Zvcm1hdFByb2RFcnJvck1lc3NhZ2U0KDM1KSA6IFwiRXhpc3RpbmcgUmVkdXggY29udGV4dCBkZXRlY3RlZC4gSWYgeW91IGFscmVhZHkgaGF2ZSBhIHN0b3JlIHNldCB1cCwgcGxlYXNlIHVzZSB0aGUgdHJhZGl0aW9uYWwgUmVkdXggc2V0dXAuXCIpO1xuICB9XG4gIGNvbnN0IFtzdG9yZV0gPSBSZWFjdC51c2VTdGF0ZSgoKSA9PiBjb25maWd1cmVTdG9yZSh7XG4gICAgcmVkdWNlcjoge1xuICAgICAgW3Byb3BzLmFwaS5yZWR1Y2VyUGF0aF06IHByb3BzLmFwaS5yZWR1Y2VyXG4gICAgfSxcbiAgICBtaWRkbGV3YXJlOiAoZ0RNKSA9PiBnRE0oKS5jb25jYXQocHJvcHMuYXBpLm1pZGRsZXdhcmUpXG4gIH0pKTtcbiAgdXNlRWZmZWN0NCgoKSA9PiBwcm9wcy5zZXR1cExpc3RlbmVycyA9PT0gZmFsc2UgPyB2b2lkIDAgOiBzZXR1cExpc3RlbmVycyhzdG9yZS5kaXNwYXRjaCwgcHJvcHMuc2V0dXBMaXN0ZW5lcnMpLCBbcHJvcHMuc2V0dXBMaXN0ZW5lcnMsIHN0b3JlLmRpc3BhdGNoXSk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QuY3JlYXRlRWxlbWVudChQcm92aWRlciwgeyBzdG9yZSwgY29udGV4dCB9LCBwcm9wcy5jaGlsZHJlbik7XG59XG5cbi8vIHNyYy9xdWVyeS9yZWFjdC9pbmRleC50c1xudmFyIGNyZWF0ZUFwaSA9IC8qIEBfX1BVUkVfXyAqLyBidWlsZENyZWF0ZUFwaShjb3JlTW9kdWxlKCksIHJlYWN0SG9va3NNb2R1bGUoKSk7XG5leHBvcnQge1xuICBBcGlQcm92aWRlcixcbiAgVU5JTklUSUFMSVpFRF9WQUxVRSxcbiAgY3JlYXRlQXBpLFxuICByZWFjdEhvb2tzTW9kdWxlLFxuICByZWFjdEhvb2tzTW9kdWxlTmFtZVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJ0ay1xdWVyeS1yZWFjdC5tb2Rlcm4ubWpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@reduxjs/toolkit/dist/query/react/rtk-query-react.modern.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@reduxjs/toolkit/dist/query/rtk-query.modern.mjs":
/*!***********************************************************************!*\
  !*** ./node_modules/@reduxjs/toolkit/dist/query/rtk-query.modern.mjs ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   QueryStatus: () => (/* binding */ QueryStatus),\n/* harmony export */   _NEVER: () => (/* binding */ _NEVER),\n/* harmony export */   buildCreateApi: () => (/* binding */ buildCreateApi),\n/* harmony export */   copyWithStructuralSharing: () => (/* binding */ copyWithStructuralSharing),\n/* harmony export */   coreModule: () => (/* binding */ coreModule),\n/* harmony export */   coreModuleName: () => (/* binding */ coreModuleName),\n/* harmony export */   createApi: () => (/* binding */ createApi),\n/* harmony export */   defaultSerializeQueryArgs: () => (/* binding */ defaultSerializeQueryArgs),\n/* harmony export */   fakeBaseQuery: () => (/* binding */ fakeBaseQuery),\n/* harmony export */   fetchBaseQuery: () => (/* binding */ fetchBaseQuery),\n/* harmony export */   retry: () => (/* binding */ retry),\n/* harmony export */   setupListeners: () => (/* binding */ setupListeners),\n/* harmony export */   skipToken: () => (/* binding */ skipToken)\n/* harmony export */ });\n/* harmony import */ var _reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @reduxjs/toolkit */ \"(ssr)/./node_modules/redux/dist/redux.mjs\");\n/* harmony import */ var _reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @reduxjs/toolkit */ \"(ssr)/./node_modules/@reduxjs/toolkit/dist/redux-toolkit.modern.mjs\");\n/* harmony import */ var immer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! immer */ \"(ssr)/./node_modules/immer/dist/immer.mjs\");\n/* harmony import */ var reselect__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! reselect */ \"(ssr)/./node_modules/reselect/dist/reselect.mjs\");\n// src/query/core/apiState.ts\nvar QueryStatus = /* @__PURE__ */ ((QueryStatus2) => {\n  QueryStatus2[\"uninitialized\"] = \"uninitialized\";\n  QueryStatus2[\"pending\"] = \"pending\";\n  QueryStatus2[\"fulfilled\"] = \"fulfilled\";\n  QueryStatus2[\"rejected\"] = \"rejected\";\n  return QueryStatus2;\n})(QueryStatus || {});\nfunction getRequestStatusFlags(status) {\n  return {\n    status,\n    isUninitialized: status === \"uninitialized\" /* uninitialized */,\n    isLoading: status === \"pending\" /* pending */,\n    isSuccess: status === \"fulfilled\" /* fulfilled */,\n    isError: status === \"rejected\" /* rejected */\n  };\n}\n\n// src/query/core/rtkImports.ts\n\n\n// src/query/utils/copyWithStructuralSharing.ts\nvar isPlainObject2 = _reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__.isPlainObject;\nfunction copyWithStructuralSharing(oldObj, newObj) {\n  if (oldObj === newObj || !(isPlainObject2(oldObj) && isPlainObject2(newObj) || Array.isArray(oldObj) && Array.isArray(newObj))) {\n    return newObj;\n  }\n  const newKeys = Object.keys(newObj);\n  const oldKeys = Object.keys(oldObj);\n  let isSameObject = newKeys.length === oldKeys.length;\n  const mergeObj = Array.isArray(newObj) ? [] : {};\n  for (const key of newKeys) {\n    mergeObj[key] = copyWithStructuralSharing(oldObj[key], newObj[key]);\n    if (isSameObject) isSameObject = oldObj[key] === mergeObj[key];\n  }\n  return isSameObject ? oldObj : mergeObj;\n}\n\n// src/query/utils/countObjectKeys.ts\nfunction countObjectKeys(obj) {\n  let count = 0;\n  for (const _key in obj) {\n    count++;\n  }\n  return count;\n}\n\n// src/query/utils/flatten.ts\nvar flatten = (arr) => [].concat(...arr);\n\n// src/query/utils/isAbsoluteUrl.ts\nfunction isAbsoluteUrl(url) {\n  return new RegExp(`(^|:)//`).test(url);\n}\n\n// src/query/utils/isDocumentVisible.ts\nfunction isDocumentVisible() {\n  if (typeof document === \"undefined\") {\n    return true;\n  }\n  return document.visibilityState !== \"hidden\";\n}\n\n// src/query/utils/isNotNullish.ts\nfunction isNotNullish(v) {\n  return v != null;\n}\n\n// src/query/utils/isOnline.ts\nfunction isOnline() {\n  return typeof navigator === \"undefined\" ? true : navigator.onLine === void 0 ? true : navigator.onLine;\n}\n\n// src/query/utils/joinUrls.ts\nvar withoutTrailingSlash = (url) => url.replace(/\\/$/, \"\");\nvar withoutLeadingSlash = (url) => url.replace(/^\\//, \"\");\nfunction joinUrls(base, url) {\n  if (!base) {\n    return url;\n  }\n  if (!url) {\n    return base;\n  }\n  if (isAbsoluteUrl(url)) {\n    return url;\n  }\n  const delimiter = base.endsWith(\"/\") || !url.startsWith(\"?\") ? \"/\" : \"\";\n  base = withoutTrailingSlash(base);\n  url = withoutLeadingSlash(url);\n  return `${base}${delimiter}${url}`;\n}\n\n// src/query/fetchBaseQuery.ts\nvar defaultFetchFn = (...args) => fetch(...args);\nvar defaultValidateStatus = (response) => response.status >= 200 && response.status <= 299;\nvar defaultIsJsonContentType = (headers) => (\n  /*applicat*/\n  /ion\\/(vnd\\.api\\+)?json/.test(headers.get(\"content-type\") || \"\")\n);\nfunction stripUndefined(obj) {\n  if (!(0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(obj)) {\n    return obj;\n  }\n  const copy = {\n    ...obj\n  };\n  for (const [k, v] of Object.entries(copy)) {\n    if (v === void 0) delete copy[k];\n  }\n  return copy;\n}\nfunction fetchBaseQuery({\n  baseUrl,\n  prepareHeaders = (x) => x,\n  fetchFn = defaultFetchFn,\n  paramsSerializer,\n  isJsonContentType = defaultIsJsonContentType,\n  jsonContentType = \"application/json\",\n  jsonReplacer,\n  timeout: defaultTimeout,\n  responseHandler: globalResponseHandler,\n  validateStatus: globalValidateStatus,\n  ...baseFetchOptions\n} = {}) {\n  if (typeof fetch === \"undefined\" && fetchFn === defaultFetchFn) {\n    console.warn(\"Warning: `fetch` is not available. Please supply a custom `fetchFn` property to use `fetchBaseQuery` on SSR environments.\");\n  }\n  return async (arg, api) => {\n    const {\n      signal,\n      getState,\n      extra,\n      endpoint,\n      forced,\n      type\n    } = api;\n    let meta;\n    let {\n      url,\n      headers = new Headers(baseFetchOptions.headers),\n      params = void 0,\n      responseHandler = globalResponseHandler ?? \"json\",\n      validateStatus = globalValidateStatus ?? defaultValidateStatus,\n      timeout = defaultTimeout,\n      ...rest\n    } = typeof arg == \"string\" ? {\n      url: arg\n    } : arg;\n    let config = {\n      ...baseFetchOptions,\n      signal,\n      ...rest\n    };\n    headers = new Headers(stripUndefined(headers));\n    config.headers = await prepareHeaders(headers, {\n      getState,\n      extra,\n      endpoint,\n      forced,\n      type\n    }) || headers;\n    const isJsonifiable = (body) => typeof body === \"object\" && ((0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(body) || Array.isArray(body) || typeof body.toJSON === \"function\");\n    if (!config.headers.has(\"content-type\") && isJsonifiable(config.body)) {\n      config.headers.set(\"content-type\", jsonContentType);\n    }\n    if (isJsonifiable(config.body) && isJsonContentType(config.headers)) {\n      config.body = JSON.stringify(config.body, jsonReplacer);\n    }\n    if (params) {\n      const divider = ~url.indexOf(\"?\") ? \"&\" : \"?\";\n      const query = paramsSerializer ? paramsSerializer(params) : new URLSearchParams(stripUndefined(params));\n      url += divider + query;\n    }\n    url = joinUrls(baseUrl, url);\n    const request = new Request(url, config);\n    const requestClone = new Request(url, config);\n    meta = {\n      request: requestClone\n    };\n    let response, timedOut = false, timeoutId = timeout && setTimeout(() => {\n      timedOut = true;\n      api.abort();\n    }, timeout);\n    try {\n      response = await fetchFn(request);\n    } catch (e) {\n      return {\n        error: {\n          status: timedOut ? \"TIMEOUT_ERROR\" : \"FETCH_ERROR\",\n          error: String(e)\n        },\n        meta\n      };\n    } finally {\n      if (timeoutId) clearTimeout(timeoutId);\n    }\n    const responseClone = response.clone();\n    meta.response = responseClone;\n    let resultData;\n    let responseText = \"\";\n    try {\n      let handleResponseError;\n      await Promise.all([\n        handleResponse(response, responseHandler).then((r) => resultData = r, (e) => handleResponseError = e),\n        // see https://github.com/node-fetch/node-fetch/issues/665#issuecomment-538995182\n        // we *have* to \"use up\" both streams at the same time or they will stop running in node-fetch scenarios\n        responseClone.text().then((r) => responseText = r, () => {\n        })\n      ]);\n      if (handleResponseError) throw handleResponseError;\n    } catch (e) {\n      return {\n        error: {\n          status: \"PARSING_ERROR\",\n          originalStatus: response.status,\n          data: responseText,\n          error: String(e)\n        },\n        meta\n      };\n    }\n    return validateStatus(response, resultData) ? {\n      data: resultData,\n      meta\n    } : {\n      error: {\n        status: response.status,\n        data: resultData\n      },\n      meta\n    };\n  };\n  async function handleResponse(response, responseHandler) {\n    if (typeof responseHandler === \"function\") {\n      return responseHandler(response);\n    }\n    if (responseHandler === \"content-type\") {\n      responseHandler = isJsonContentType(response.headers) ? \"json\" : \"text\";\n    }\n    if (responseHandler === \"json\") {\n      const text = await response.text();\n      return text.length ? JSON.parse(text) : null;\n    }\n    return response.text();\n  }\n}\n\n// src/query/HandledError.ts\nvar HandledError = class {\n  constructor(value, meta = void 0) {\n    this.value = value;\n    this.meta = meta;\n  }\n};\n\n// src/query/retry.ts\nasync function defaultBackoff(attempt = 0, maxRetries = 5) {\n  const attempts = Math.min(attempt, maxRetries);\n  const timeout = ~~((Math.random() + 0.4) * (300 << attempts));\n  await new Promise((resolve) => setTimeout((res) => resolve(res), timeout));\n}\nfunction fail(e) {\n  throw Object.assign(new HandledError({\n    error: e\n  }), {\n    throwImmediately: true\n  });\n}\nvar EMPTY_OPTIONS = {};\nvar retryWithBackoff = (baseQuery, defaultOptions) => async (args, api, extraOptions) => {\n  const possibleMaxRetries = [5, (defaultOptions || EMPTY_OPTIONS).maxRetries, (extraOptions || EMPTY_OPTIONS).maxRetries].filter((x) => x !== void 0);\n  const [maxRetries] = possibleMaxRetries.slice(-1);\n  const defaultRetryCondition = (_, __, {\n    attempt\n  }) => attempt <= maxRetries;\n  const options = {\n    maxRetries,\n    backoff: defaultBackoff,\n    retryCondition: defaultRetryCondition,\n    ...defaultOptions,\n    ...extraOptions\n  };\n  let retry2 = 0;\n  while (true) {\n    try {\n      const result = await baseQuery(args, api, extraOptions);\n      if (result.error) {\n        throw new HandledError(result);\n      }\n      return result;\n    } catch (e) {\n      retry2++;\n      if (e.throwImmediately) {\n        if (e instanceof HandledError) {\n          return e.value;\n        }\n        throw e;\n      }\n      if (e instanceof HandledError && !options.retryCondition(e.value.error, args, {\n        attempt: retry2,\n        baseQueryApi: api,\n        extraOptions\n      })) {\n        return e.value;\n      }\n      await options.backoff(retry2, options.maxRetries);\n    }\n  }\n};\nvar retry = /* @__PURE__ */ Object.assign(retryWithBackoff, {\n  fail\n});\n\n// src/query/core/setupListeners.ts\nvar onFocus = /* @__PURE__ */ (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.createAction)(\"__rtkq/focused\");\nvar onFocusLost = /* @__PURE__ */ (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.createAction)(\"__rtkq/unfocused\");\nvar onOnline = /* @__PURE__ */ (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.createAction)(\"__rtkq/online\");\nvar onOffline = /* @__PURE__ */ (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.createAction)(\"__rtkq/offline\");\nvar initialized = false;\nfunction setupListeners(dispatch, customHandler) {\n  function defaultHandler() {\n    const handleFocus = () => dispatch(onFocus());\n    const handleFocusLost = () => dispatch(onFocusLost());\n    const handleOnline = () => dispatch(onOnline());\n    const handleOffline = () => dispatch(onOffline());\n    const handleVisibilityChange = () => {\n      if (window.document.visibilityState === \"visible\") {\n        handleFocus();\n      } else {\n        handleFocusLost();\n      }\n    };\n    if (!initialized) {\n      if (typeof window !== \"undefined\" && window.addEventListener) {\n        window.addEventListener(\"visibilitychange\", handleVisibilityChange, false);\n        window.addEventListener(\"focus\", handleFocus, false);\n        window.addEventListener(\"online\", handleOnline, false);\n        window.addEventListener(\"offline\", handleOffline, false);\n        initialized = true;\n      }\n    }\n    const unsubscribe = () => {\n      window.removeEventListener(\"focus\", handleFocus);\n      window.removeEventListener(\"visibilitychange\", handleVisibilityChange);\n      window.removeEventListener(\"online\", handleOnline);\n      window.removeEventListener(\"offline\", handleOffline);\n      initialized = false;\n    };\n    return unsubscribe;\n  }\n  return customHandler ? customHandler(dispatch, {\n    onFocus,\n    onFocusLost,\n    onOffline,\n    onOnline\n  }) : defaultHandler();\n}\n\n// src/query/endpointDefinitions.ts\nfunction isQueryDefinition(e) {\n  return e.type === \"query\" /* query */;\n}\nfunction isMutationDefinition(e) {\n  return e.type === \"mutation\" /* mutation */;\n}\nfunction calculateProvidedBy(description, result, error, queryArg, meta, assertTagTypes) {\n  if (isFunction(description)) {\n    return description(result, error, queryArg, meta).map(expandTagDescription).map(assertTagTypes);\n  }\n  if (Array.isArray(description)) {\n    return description.map(expandTagDescription).map(assertTagTypes);\n  }\n  return [];\n}\nfunction isFunction(t) {\n  return typeof t === \"function\";\n}\nfunction expandTagDescription(description) {\n  return typeof description === \"string\" ? {\n    type: description\n  } : description;\n}\n\n// src/query/core/buildThunks.ts\n\n\n// src/query/core/buildInitiate.ts\n\n\n// src/tsHelpers.ts\nfunction asSafePromise(promise, fallback) {\n  return promise.catch(fallback);\n}\n\n// src/query/core/buildInitiate.ts\nvar forceQueryFnSymbol = Symbol(\"forceQueryFn\");\nvar isUpsertQuery = (arg) => typeof arg[forceQueryFnSymbol] === \"function\";\nfunction buildInitiate({\n  serializeQueryArgs,\n  queryThunk,\n  mutationThunk,\n  api,\n  context\n}) {\n  const runningQueries = /* @__PURE__ */ new Map();\n  const runningMutations = /* @__PURE__ */ new Map();\n  const {\n    unsubscribeQueryResult,\n    removeMutationResult,\n    updateSubscriptionOptions\n  } = api.internalActions;\n  return {\n    buildInitiateQuery,\n    buildInitiateMutation,\n    getRunningQueryThunk,\n    getRunningMutationThunk,\n    getRunningQueriesThunk,\n    getRunningMutationsThunk\n  };\n  function getRunningQueryThunk(endpointName, queryArgs) {\n    return (dispatch) => {\n      const endpointDefinition = context.endpointDefinitions[endpointName];\n      const queryCacheKey = serializeQueryArgs({\n        queryArgs,\n        endpointDefinition,\n        endpointName\n      });\n      return runningQueries.get(dispatch)?.[queryCacheKey];\n    };\n  }\n  function getRunningMutationThunk(_endpointName, fixedCacheKeyOrRequestId) {\n    return (dispatch) => {\n      return runningMutations.get(dispatch)?.[fixedCacheKeyOrRequestId];\n    };\n  }\n  function getRunningQueriesThunk() {\n    return (dispatch) => Object.values(runningQueries.get(dispatch) || {}).filter(isNotNullish);\n  }\n  function getRunningMutationsThunk() {\n    return (dispatch) => Object.values(runningMutations.get(dispatch) || {}).filter(isNotNullish);\n  }\n  function middlewareWarning(dispatch) {\n    if (true) {\n      if (middlewareWarning.triggered) return;\n      const returnedValue = dispatch(api.internalActions.internal_getRTKQSubscriptions());\n      middlewareWarning.triggered = true;\n      if (typeof returnedValue !== \"object\" || typeof returnedValue?.type === \"string\") {\n        throw new Error( false ? 0 : `Warning: Middleware for RTK-Query API at reducerPath \"${api.reducerPath}\" has not been added to the store.\nYou must add the middleware for RTK-Query to function correctly!`);\n      }\n    }\n  }\n  function buildInitiateQuery(endpointName, endpointDefinition) {\n    const queryAction = (arg, {\n      subscribe = true,\n      forceRefetch,\n      subscriptionOptions,\n      [forceQueryFnSymbol]: forceQueryFn,\n      ...rest\n    } = {}) => (dispatch, getState) => {\n      const queryCacheKey = serializeQueryArgs({\n        queryArgs: arg,\n        endpointDefinition,\n        endpointName\n      });\n      const thunk = queryThunk({\n        ...rest,\n        type: \"query\",\n        subscribe,\n        forceRefetch,\n        subscriptionOptions,\n        endpointName,\n        originalArgs: arg,\n        queryCacheKey,\n        [forceQueryFnSymbol]: forceQueryFn\n      });\n      const selector = api.endpoints[endpointName].select(arg);\n      const thunkResult = dispatch(thunk);\n      const stateAfter = selector(getState());\n      middlewareWarning(dispatch);\n      const {\n        requestId,\n        abort\n      } = thunkResult;\n      const skippedSynchronously = stateAfter.requestId !== requestId;\n      const runningQuery = runningQueries.get(dispatch)?.[queryCacheKey];\n      const selectFromState = () => selector(getState());\n      const statePromise = Object.assign(forceQueryFn ? (\n        // a query has been forced (upsertQueryData)\n        // -> we want to resolve it once data has been written with the data that will be written\n        thunkResult.then(selectFromState)\n      ) : skippedSynchronously && !runningQuery ? (\n        // a query has been skipped due to a condition and we do not have any currently running query\n        // -> we want to resolve it immediately with the current data\n        Promise.resolve(stateAfter)\n      ) : (\n        // query just started or one is already in flight\n        // -> wait for the running query, then resolve with data from after that\n        Promise.all([runningQuery, thunkResult]).then(selectFromState)\n      ), {\n        arg,\n        requestId,\n        subscriptionOptions,\n        queryCacheKey,\n        abort,\n        async unwrap() {\n          const result = await statePromise;\n          if (result.isError) {\n            throw result.error;\n          }\n          return result.data;\n        },\n        refetch: () => dispatch(queryAction(arg, {\n          subscribe: false,\n          forceRefetch: true\n        })),\n        unsubscribe() {\n          if (subscribe) dispatch(unsubscribeQueryResult({\n            queryCacheKey,\n            requestId\n          }));\n        },\n        updateSubscriptionOptions(options) {\n          statePromise.subscriptionOptions = options;\n          dispatch(updateSubscriptionOptions({\n            endpointName,\n            requestId,\n            queryCacheKey,\n            options\n          }));\n        }\n      });\n      if (!runningQuery && !skippedSynchronously && !forceQueryFn) {\n        const running = runningQueries.get(dispatch) || {};\n        running[queryCacheKey] = statePromise;\n        runningQueries.set(dispatch, running);\n        statePromise.then(() => {\n          delete running[queryCacheKey];\n          if (!countObjectKeys(running)) {\n            runningQueries.delete(dispatch);\n          }\n        });\n      }\n      return statePromise;\n    };\n    return queryAction;\n  }\n  function buildInitiateMutation(endpointName) {\n    return (arg, {\n      track = true,\n      fixedCacheKey\n    } = {}) => (dispatch, getState) => {\n      const thunk = mutationThunk({\n        type: \"mutation\",\n        endpointName,\n        originalArgs: arg,\n        track,\n        fixedCacheKey\n      });\n      const thunkResult = dispatch(thunk);\n      middlewareWarning(dispatch);\n      const {\n        requestId,\n        abort,\n        unwrap\n      } = thunkResult;\n      const returnValuePromise = asSafePromise(thunkResult.unwrap().then((data) => ({\n        data\n      })), (error) => ({\n        error\n      }));\n      const reset = () => {\n        dispatch(removeMutationResult({\n          requestId,\n          fixedCacheKey\n        }));\n      };\n      const ret = Object.assign(returnValuePromise, {\n        arg: thunkResult.arg,\n        requestId,\n        abort,\n        unwrap,\n        reset\n      });\n      const running = runningMutations.get(dispatch) || {};\n      runningMutations.set(dispatch, running);\n      running[requestId] = ret;\n      ret.then(() => {\n        delete running[requestId];\n        if (!countObjectKeys(running)) {\n          runningMutations.delete(dispatch);\n        }\n      });\n      if (fixedCacheKey) {\n        running[fixedCacheKey] = ret;\n        ret.then(() => {\n          if (running[fixedCacheKey] === ret) {\n            delete running[fixedCacheKey];\n            if (!countObjectKeys(running)) {\n              runningMutations.delete(dispatch);\n            }\n          }\n        });\n      }\n      return ret;\n    };\n  }\n}\n\n// src/query/core/buildThunks.ts\nfunction defaultTransformResponse(baseQueryReturnValue) {\n  return baseQueryReturnValue;\n}\nfunction buildThunks({\n  reducerPath,\n  baseQuery,\n  context: {\n    endpointDefinitions\n  },\n  serializeQueryArgs,\n  api,\n  assertTagType\n}) {\n  const patchQueryData = (endpointName, args, patches, updateProvided) => (dispatch, getState) => {\n    const endpointDefinition = endpointDefinitions[endpointName];\n    const queryCacheKey = serializeQueryArgs({\n      queryArgs: args,\n      endpointDefinition,\n      endpointName\n    });\n    dispatch(api.internalActions.queryResultPatched({\n      queryCacheKey,\n      patches\n    }));\n    if (!updateProvided) {\n      return;\n    }\n    const newValue = api.endpoints[endpointName].select(args)(\n      // Work around TS 4.1 mismatch\n      getState()\n    );\n    const providedTags = calculateProvidedBy(endpointDefinition.providesTags, newValue.data, void 0, args, {}, assertTagType);\n    dispatch(api.internalActions.updateProvidedBy({\n      queryCacheKey,\n      providedTags\n    }));\n  };\n  const updateQueryData = (endpointName, args, updateRecipe, updateProvided = true) => (dispatch, getState) => {\n    const endpointDefinition = api.endpoints[endpointName];\n    const currentState = endpointDefinition.select(args)(\n      // Work around TS 4.1 mismatch\n      getState()\n    );\n    const ret = {\n      patches: [],\n      inversePatches: [],\n      undo: () => dispatch(api.util.patchQueryData(endpointName, args, ret.inversePatches, updateProvided))\n    };\n    if (currentState.status === \"uninitialized\" /* uninitialized */) {\n      return ret;\n    }\n    let newValue;\n    if (\"data\" in currentState) {\n      if ((0,immer__WEBPACK_IMPORTED_MODULE_2__.isDraftable)(currentState.data)) {\n        const [value, patches, inversePatches] = (0,immer__WEBPACK_IMPORTED_MODULE_2__.produceWithPatches)(currentState.data, updateRecipe);\n        ret.patches.push(...patches);\n        ret.inversePatches.push(...inversePatches);\n        newValue = value;\n      } else {\n        newValue = updateRecipe(currentState.data);\n        ret.patches.push({\n          op: \"replace\",\n          path: [],\n          value: newValue\n        });\n        ret.inversePatches.push({\n          op: \"replace\",\n          path: [],\n          value: currentState.data\n        });\n      }\n    }\n    if (ret.patches.length === 0) {\n      return ret;\n    }\n    dispatch(api.util.patchQueryData(endpointName, args, ret.patches, updateProvided));\n    return ret;\n  };\n  const upsertQueryData = (endpointName, args, value) => (dispatch) => {\n    return dispatch(api.endpoints[endpointName].initiate(args, {\n      subscribe: false,\n      forceRefetch: true,\n      [forceQueryFnSymbol]: () => ({\n        data: value\n      })\n    }));\n  };\n  const executeEndpoint = async (arg, {\n    signal,\n    abort,\n    rejectWithValue,\n    fulfillWithValue,\n    dispatch,\n    getState,\n    extra\n  }) => {\n    const endpointDefinition = endpointDefinitions[arg.endpointName];\n    try {\n      let transformResponse = defaultTransformResponse;\n      let result;\n      const baseQueryApi = {\n        signal,\n        abort,\n        dispatch,\n        getState,\n        extra,\n        endpoint: arg.endpointName,\n        type: arg.type,\n        forced: arg.type === \"query\" ? isForcedQuery(arg, getState()) : void 0\n      };\n      const forceQueryFn = arg.type === \"query\" ? arg[forceQueryFnSymbol] : void 0;\n      if (forceQueryFn) {\n        result = forceQueryFn();\n      } else if (endpointDefinition.query) {\n        result = await baseQuery(endpointDefinition.query(arg.originalArgs), baseQueryApi, endpointDefinition.extraOptions);\n        if (endpointDefinition.transformResponse) {\n          transformResponse = endpointDefinition.transformResponse;\n        }\n      } else {\n        result = await endpointDefinition.queryFn(arg.originalArgs, baseQueryApi, endpointDefinition.extraOptions, (arg2) => baseQuery(arg2, baseQueryApi, endpointDefinition.extraOptions));\n      }\n      if (typeof process !== \"undefined\" && \"development\" === \"development\") {\n        const what = endpointDefinition.query ? \"`baseQuery`\" : \"`queryFn`\";\n        let err;\n        if (!result) {\n          err = `${what} did not return anything.`;\n        } else if (typeof result !== \"object\") {\n          err = `${what} did not return an object.`;\n        } else if (result.error && result.data) {\n          err = `${what} returned an object containing both \\`error\\` and \\`result\\`.`;\n        } else if (result.error === void 0 && result.data === void 0) {\n          err = `${what} returned an object containing neither a valid \\`error\\` and \\`result\\`. At least one of them should not be \\`undefined\\``;\n        } else {\n          for (const key of Object.keys(result)) {\n            if (key !== \"error\" && key !== \"data\" && key !== \"meta\") {\n              err = `The object returned by ${what} has the unknown property ${key}.`;\n              break;\n            }\n          }\n        }\n        if (err) {\n          console.error(`Error encountered handling the endpoint ${arg.endpointName}.\n              ${err}\n              It needs to return an object with either the shape \\`{ data: <value> }\\` or \\`{ error: <value> }\\` that may contain an optional \\`meta\\` property.\n              Object returned was:`, result);\n        }\n      }\n      if (result.error) throw new HandledError(result.error, result.meta);\n      return fulfillWithValue(await transformResponse(result.data, result.meta, arg.originalArgs), {\n        fulfilledTimeStamp: Date.now(),\n        baseQueryMeta: result.meta,\n        [_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.SHOULD_AUTOBATCH]: true\n      });\n    } catch (error) {\n      let catchedError = error;\n      if (catchedError instanceof HandledError) {\n        let transformErrorResponse = defaultTransformResponse;\n        if (endpointDefinition.query && endpointDefinition.transformErrorResponse) {\n          transformErrorResponse = endpointDefinition.transformErrorResponse;\n        }\n        try {\n          return rejectWithValue(await transformErrorResponse(catchedError.value, catchedError.meta, arg.originalArgs), {\n            baseQueryMeta: catchedError.meta,\n            [_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.SHOULD_AUTOBATCH]: true\n          });\n        } catch (e) {\n          catchedError = e;\n        }\n      }\n      if (typeof process !== \"undefined\" && \"development\" !== \"production\") {\n        console.error(`An unhandled error occurred processing a request for the endpoint \"${arg.endpointName}\".\nIn the case of an unhandled error, no tags will be \"provided\" or \"invalidated\".`, catchedError);\n      } else {\n        console.error(catchedError);\n      }\n      throw catchedError;\n    }\n  };\n  function isForcedQuery(arg, state) {\n    const requestState = state[reducerPath]?.queries?.[arg.queryCacheKey];\n    const baseFetchOnMountOrArgChange = state[reducerPath]?.config.refetchOnMountOrArgChange;\n    const fulfilledVal = requestState?.fulfilledTimeStamp;\n    const refetchVal = arg.forceRefetch ?? (arg.subscribe && baseFetchOnMountOrArgChange);\n    if (refetchVal) {\n      return refetchVal === true || (Number(/* @__PURE__ */ new Date()) - Number(fulfilledVal)) / 1e3 >= refetchVal;\n    }\n    return false;\n  }\n  const queryThunk = (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.createAsyncThunk)(`${reducerPath}/executeQuery`, executeEndpoint, {\n    getPendingMeta() {\n      return {\n        startedTimeStamp: Date.now(),\n        [_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.SHOULD_AUTOBATCH]: true\n      };\n    },\n    condition(queryThunkArgs, {\n      getState\n    }) {\n      const state = getState();\n      const requestState = state[reducerPath]?.queries?.[queryThunkArgs.queryCacheKey];\n      const fulfilledVal = requestState?.fulfilledTimeStamp;\n      const currentArg = queryThunkArgs.originalArgs;\n      const previousArg = requestState?.originalArgs;\n      const endpointDefinition = endpointDefinitions[queryThunkArgs.endpointName];\n      if (isUpsertQuery(queryThunkArgs)) {\n        return true;\n      }\n      if (requestState?.status === \"pending\") {\n        return false;\n      }\n      if (isForcedQuery(queryThunkArgs, state)) {\n        return true;\n      }\n      if (isQueryDefinition(endpointDefinition) && endpointDefinition?.forceRefetch?.({\n        currentArg,\n        previousArg,\n        endpointState: requestState,\n        state\n      })) {\n        return true;\n      }\n      if (fulfilledVal) {\n        return false;\n      }\n      return true;\n    },\n    dispatchConditionRejection: true\n  });\n  const mutationThunk = (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.createAsyncThunk)(`${reducerPath}/executeMutation`, executeEndpoint, {\n    getPendingMeta() {\n      return {\n        startedTimeStamp: Date.now(),\n        [_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.SHOULD_AUTOBATCH]: true\n      };\n    }\n  });\n  const hasTheForce = (options) => \"force\" in options;\n  const hasMaxAge = (options) => \"ifOlderThan\" in options;\n  const prefetch = (endpointName, arg, options) => (dispatch, getState) => {\n    const force = hasTheForce(options) && options.force;\n    const maxAge = hasMaxAge(options) && options.ifOlderThan;\n    const queryAction = (force2 = true) => {\n      const options2 = {\n        forceRefetch: force2,\n        isPrefetch: true\n      };\n      return api.endpoints[endpointName].initiate(arg, options2);\n    };\n    const latestStateValue = api.endpoints[endpointName].select(arg)(getState());\n    if (force) {\n      dispatch(queryAction());\n    } else if (maxAge) {\n      const lastFulfilledTs = latestStateValue?.fulfilledTimeStamp;\n      if (!lastFulfilledTs) {\n        dispatch(queryAction());\n        return;\n      }\n      const shouldRetrigger = (Number(/* @__PURE__ */ new Date()) - Number(new Date(lastFulfilledTs))) / 1e3 >= maxAge;\n      if (shouldRetrigger) {\n        dispatch(queryAction());\n      }\n    } else {\n      dispatch(queryAction(false));\n    }\n  };\n  function matchesEndpoint(endpointName) {\n    return (action) => action?.meta?.arg?.endpointName === endpointName;\n  }\n  function buildMatchThunkActions(thunk, endpointName) {\n    return {\n      matchPending: (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.isAllOf)((0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.isPending)(thunk), matchesEndpoint(endpointName)),\n      matchFulfilled: (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.isAllOf)((0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.isFulfilled)(thunk), matchesEndpoint(endpointName)),\n      matchRejected: (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.isAllOf)((0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.isRejected)(thunk), matchesEndpoint(endpointName))\n    };\n  }\n  return {\n    queryThunk,\n    mutationThunk,\n    prefetch,\n    updateQueryData,\n    upsertQueryData,\n    patchQueryData,\n    buildMatchThunkActions\n  };\n}\nfunction calculateProvidedByThunk(action, type, endpointDefinitions, assertTagType) {\n  return calculateProvidedBy(endpointDefinitions[action.meta.arg.endpointName][type], (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.isFulfilled)(action) ? action.payload : void 0, (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.isRejectedWithValue)(action) ? action.payload : void 0, action.meta.arg.originalArgs, \"baseQueryMeta\" in action.meta ? action.meta.baseQueryMeta : void 0, assertTagType);\n}\n\n// src/query/core/buildSlice.ts\n\n\nfunction updateQuerySubstateIfExists(state, queryCacheKey, update) {\n  const substate = state[queryCacheKey];\n  if (substate) {\n    update(substate);\n  }\n}\nfunction getMutationCacheKey(id) {\n  return (\"arg\" in id ? id.arg.fixedCacheKey : id.fixedCacheKey) ?? id.requestId;\n}\nfunction updateMutationSubstateIfExists(state, id, update) {\n  const substate = state[getMutationCacheKey(id)];\n  if (substate) {\n    update(substate);\n  }\n}\nvar initialState = {};\nfunction buildSlice({\n  reducerPath,\n  queryThunk,\n  mutationThunk,\n  context: {\n    endpointDefinitions: definitions,\n    apiUid,\n    extractRehydrationInfo,\n    hasRehydrationInfo\n  },\n  assertTagType,\n  config\n}) {\n  const resetApiState = (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.createAction)(`${reducerPath}/resetApiState`);\n  const querySlice = (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.createSlice)({\n    name: `${reducerPath}/queries`,\n    initialState,\n    reducers: {\n      removeQueryResult: {\n        reducer(draft, {\n          payload: {\n            queryCacheKey\n          }\n        }) {\n          delete draft[queryCacheKey];\n        },\n        prepare: (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.prepareAutoBatched)()\n      },\n      queryResultPatched: {\n        reducer(draft, {\n          payload: {\n            queryCacheKey,\n            patches\n          }\n        }) {\n          updateQuerySubstateIfExists(draft, queryCacheKey, (substate) => {\n            substate.data = (0,immer__WEBPACK_IMPORTED_MODULE_2__.applyPatches)(substate.data, patches.concat());\n          });\n        },\n        prepare: (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.prepareAutoBatched)()\n      }\n    },\n    extraReducers(builder) {\n      builder.addCase(queryThunk.pending, (draft, {\n        meta,\n        meta: {\n          arg\n        }\n      }) => {\n        const upserting = isUpsertQuery(arg);\n        draft[arg.queryCacheKey] ??= {\n          status: \"uninitialized\" /* uninitialized */,\n          endpointName: arg.endpointName\n        };\n        updateQuerySubstateIfExists(draft, arg.queryCacheKey, (substate) => {\n          substate.status = \"pending\" /* pending */;\n          substate.requestId = upserting && substate.requestId ? (\n            // for `upsertQuery` **updates**, keep the current `requestId`\n            substate.requestId\n          ) : (\n            // for normal queries or `upsertQuery` **inserts** always update the `requestId`\n            meta.requestId\n          );\n          if (arg.originalArgs !== void 0) {\n            substate.originalArgs = arg.originalArgs;\n          }\n          substate.startedTimeStamp = meta.startedTimeStamp;\n        });\n      }).addCase(queryThunk.fulfilled, (draft, {\n        meta,\n        payload\n      }) => {\n        updateQuerySubstateIfExists(draft, meta.arg.queryCacheKey, (substate) => {\n          if (substate.requestId !== meta.requestId && !isUpsertQuery(meta.arg)) return;\n          const {\n            merge\n          } = definitions[meta.arg.endpointName];\n          substate.status = \"fulfilled\" /* fulfilled */;\n          if (merge) {\n            if (substate.data !== void 0) {\n              const {\n                fulfilledTimeStamp,\n                arg,\n                baseQueryMeta,\n                requestId\n              } = meta;\n              let newData = (0,immer__WEBPACK_IMPORTED_MODULE_2__.produce)(substate.data, (draftSubstateData) => {\n                return merge(draftSubstateData, payload, {\n                  arg: arg.originalArgs,\n                  baseQueryMeta,\n                  fulfilledTimeStamp,\n                  requestId\n                });\n              });\n              substate.data = newData;\n            } else {\n              substate.data = payload;\n            }\n          } else {\n            substate.data = definitions[meta.arg.endpointName].structuralSharing ?? true ? copyWithStructuralSharing((0,immer__WEBPACK_IMPORTED_MODULE_2__.isDraft)(substate.data) ? (0,immer__WEBPACK_IMPORTED_MODULE_2__.original)(substate.data) : substate.data, payload) : payload;\n          }\n          delete substate.error;\n          substate.fulfilledTimeStamp = meta.fulfilledTimeStamp;\n        });\n      }).addCase(queryThunk.rejected, (draft, {\n        meta: {\n          condition,\n          arg,\n          requestId\n        },\n        error,\n        payload\n      }) => {\n        updateQuerySubstateIfExists(draft, arg.queryCacheKey, (substate) => {\n          if (condition) {\n          } else {\n            if (substate.requestId !== requestId) return;\n            substate.status = \"rejected\" /* rejected */;\n            substate.error = payload ?? error;\n          }\n        });\n      }).addMatcher(hasRehydrationInfo, (draft, action) => {\n        const {\n          queries\n        } = extractRehydrationInfo(action);\n        for (const [key, entry] of Object.entries(queries)) {\n          if (\n            // do not rehydrate entries that were currently in flight.\n            entry?.status === \"fulfilled\" /* fulfilled */ || entry?.status === \"rejected\" /* rejected */\n          ) {\n            draft[key] = entry;\n          }\n        }\n      });\n    }\n  });\n  const mutationSlice = (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.createSlice)({\n    name: `${reducerPath}/mutations`,\n    initialState,\n    reducers: {\n      removeMutationResult: {\n        reducer(draft, {\n          payload\n        }) {\n          const cacheKey = getMutationCacheKey(payload);\n          if (cacheKey in draft) {\n            delete draft[cacheKey];\n          }\n        },\n        prepare: (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.prepareAutoBatched)()\n      }\n    },\n    extraReducers(builder) {\n      builder.addCase(mutationThunk.pending, (draft, {\n        meta,\n        meta: {\n          requestId,\n          arg,\n          startedTimeStamp\n        }\n      }) => {\n        if (!arg.track) return;\n        draft[getMutationCacheKey(meta)] = {\n          requestId,\n          status: \"pending\" /* pending */,\n          endpointName: arg.endpointName,\n          startedTimeStamp\n        };\n      }).addCase(mutationThunk.fulfilled, (draft, {\n        payload,\n        meta\n      }) => {\n        if (!meta.arg.track) return;\n        updateMutationSubstateIfExists(draft, meta, (substate) => {\n          if (substate.requestId !== meta.requestId) return;\n          substate.status = \"fulfilled\" /* fulfilled */;\n          substate.data = payload;\n          substate.fulfilledTimeStamp = meta.fulfilledTimeStamp;\n        });\n      }).addCase(mutationThunk.rejected, (draft, {\n        payload,\n        error,\n        meta\n      }) => {\n        if (!meta.arg.track) return;\n        updateMutationSubstateIfExists(draft, meta, (substate) => {\n          if (substate.requestId !== meta.requestId) return;\n          substate.status = \"rejected\" /* rejected */;\n          substate.error = payload ?? error;\n        });\n      }).addMatcher(hasRehydrationInfo, (draft, action) => {\n        const {\n          mutations\n        } = extractRehydrationInfo(action);\n        for (const [key, entry] of Object.entries(mutations)) {\n          if (\n            // do not rehydrate entries that were currently in flight.\n            (entry?.status === \"fulfilled\" /* fulfilled */ || entry?.status === \"rejected\" /* rejected */) && // only rehydrate endpoints that were persisted using a `fixedCacheKey`\n            key !== entry?.requestId\n          ) {\n            draft[key] = entry;\n          }\n        }\n      });\n    }\n  });\n  const invalidationSlice = (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.createSlice)({\n    name: `${reducerPath}/invalidation`,\n    initialState,\n    reducers: {\n      updateProvidedBy: {\n        reducer(draft, action) {\n          const {\n            queryCacheKey,\n            providedTags\n          } = action.payload;\n          for (const tagTypeSubscriptions of Object.values(draft)) {\n            for (const idSubscriptions of Object.values(tagTypeSubscriptions)) {\n              const foundAt = idSubscriptions.indexOf(queryCacheKey);\n              if (foundAt !== -1) {\n                idSubscriptions.splice(foundAt, 1);\n              }\n            }\n          }\n          for (const {\n            type,\n            id\n          } of providedTags) {\n            const subscribedQueries = (draft[type] ??= {})[id || \"__internal_without_id\"] ??= [];\n            const alreadySubscribed = subscribedQueries.includes(queryCacheKey);\n            if (!alreadySubscribed) {\n              subscribedQueries.push(queryCacheKey);\n            }\n          }\n        },\n        prepare: (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.prepareAutoBatched)()\n      }\n    },\n    extraReducers(builder) {\n      builder.addCase(querySlice.actions.removeQueryResult, (draft, {\n        payload: {\n          queryCacheKey\n        }\n      }) => {\n        for (const tagTypeSubscriptions of Object.values(draft)) {\n          for (const idSubscriptions of Object.values(tagTypeSubscriptions)) {\n            const foundAt = idSubscriptions.indexOf(queryCacheKey);\n            if (foundAt !== -1) {\n              idSubscriptions.splice(foundAt, 1);\n            }\n          }\n        }\n      }).addMatcher(hasRehydrationInfo, (draft, action) => {\n        const {\n          provided\n        } = extractRehydrationInfo(action);\n        for (const [type, incomingTags] of Object.entries(provided)) {\n          for (const [id, cacheKeys] of Object.entries(incomingTags)) {\n            const subscribedQueries = (draft[type] ??= {})[id || \"__internal_without_id\"] ??= [];\n            for (const queryCacheKey of cacheKeys) {\n              const alreadySubscribed = subscribedQueries.includes(queryCacheKey);\n              if (!alreadySubscribed) {\n                subscribedQueries.push(queryCacheKey);\n              }\n            }\n          }\n        }\n      }).addMatcher((0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.isAnyOf)((0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.isFulfilled)(queryThunk), (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.isRejectedWithValue)(queryThunk)), (draft, action) => {\n        const providedTags = calculateProvidedByThunk(action, \"providesTags\", definitions, assertTagType);\n        const {\n          queryCacheKey\n        } = action.meta.arg;\n        invalidationSlice.caseReducers.updateProvidedBy(draft, invalidationSlice.actions.updateProvidedBy({\n          queryCacheKey,\n          providedTags\n        }));\n      });\n    }\n  });\n  const subscriptionSlice = (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.createSlice)({\n    name: `${reducerPath}/subscriptions`,\n    initialState,\n    reducers: {\n      updateSubscriptionOptions(d, a) {\n      },\n      unsubscribeQueryResult(d, a) {\n      },\n      internal_getRTKQSubscriptions() {\n      }\n    }\n  });\n  const internalSubscriptionsSlice = (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.createSlice)({\n    name: `${reducerPath}/internalSubscriptions`,\n    initialState,\n    reducers: {\n      subscriptionsUpdated: {\n        reducer(state, action) {\n          return (0,immer__WEBPACK_IMPORTED_MODULE_2__.applyPatches)(state, action.payload);\n        },\n        prepare: (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.prepareAutoBatched)()\n      }\n    }\n  });\n  const configSlice = (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.createSlice)({\n    name: `${reducerPath}/config`,\n    initialState: {\n      online: isOnline(),\n      focused: isDocumentVisible(),\n      middlewareRegistered: false,\n      ...config\n    },\n    reducers: {\n      middlewareRegistered(state, {\n        payload\n      }) {\n        state.middlewareRegistered = state.middlewareRegistered === \"conflict\" || apiUid !== payload ? \"conflict\" : true;\n      }\n    },\n    extraReducers: (builder) => {\n      builder.addCase(onOnline, (state) => {\n        state.online = true;\n      }).addCase(onOffline, (state) => {\n        state.online = false;\n      }).addCase(onFocus, (state) => {\n        state.focused = true;\n      }).addCase(onFocusLost, (state) => {\n        state.focused = false;\n      }).addMatcher(hasRehydrationInfo, (draft) => ({\n        ...draft\n      }));\n    }\n  });\n  const combinedReducer = (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__.combineReducers)({\n    queries: querySlice.reducer,\n    mutations: mutationSlice.reducer,\n    provided: invalidationSlice.reducer,\n    subscriptions: internalSubscriptionsSlice.reducer,\n    config: configSlice.reducer\n  });\n  const reducer = (state, action) => combinedReducer(resetApiState.match(action) ? void 0 : state, action);\n  const actions = {\n    ...configSlice.actions,\n    ...querySlice.actions,\n    ...subscriptionSlice.actions,\n    ...internalSubscriptionsSlice.actions,\n    ...mutationSlice.actions,\n    ...invalidationSlice.actions,\n    resetApiState\n  };\n  return {\n    reducer,\n    actions\n  };\n}\n\n// src/query/core/buildSelectors.ts\nvar skipToken = /* @__PURE__ */ Symbol.for(\"RTKQ/skipToken\");\nvar initialSubState = {\n  status: \"uninitialized\" /* uninitialized */\n};\nvar defaultQuerySubState = /* @__PURE__ */ (0,immer__WEBPACK_IMPORTED_MODULE_2__.produce)(initialSubState, () => {\n});\nvar defaultMutationSubState = /* @__PURE__ */ (0,immer__WEBPACK_IMPORTED_MODULE_2__.produce)(initialSubState, () => {\n});\nfunction buildSelectors({\n  serializeQueryArgs,\n  reducerPath,\n  createSelector: createSelector2\n}) {\n  const selectSkippedQuery = (state) => defaultQuerySubState;\n  const selectSkippedMutation = (state) => defaultMutationSubState;\n  return {\n    buildQuerySelector,\n    buildMutationSelector,\n    selectInvalidatedBy,\n    selectCachedArgsForQuery\n  };\n  function withRequestFlags(substate) {\n    return {\n      ...substate,\n      ...getRequestStatusFlags(substate.status)\n    };\n  }\n  function selectInternalState(rootState) {\n    const state = rootState[reducerPath];\n    if (true) {\n      if (!state) {\n        if (selectInternalState.triggered) return state;\n        selectInternalState.triggered = true;\n        console.error(`Error: No data found at \\`state.${reducerPath}\\`. Did you forget to add the reducer to the store?`);\n      }\n    }\n    return state;\n  }\n  function buildQuerySelector(endpointName, endpointDefinition) {\n    return (queryArgs) => {\n      const serializedArgs = serializeQueryArgs({\n        queryArgs,\n        endpointDefinition,\n        endpointName\n      });\n      const selectQuerySubstate = (state) => selectInternalState(state)?.queries?.[serializedArgs] ?? defaultQuerySubState;\n      const finalSelectQuerySubState = queryArgs === skipToken ? selectSkippedQuery : selectQuerySubstate;\n      return createSelector2(finalSelectQuerySubState, withRequestFlags);\n    };\n  }\n  function buildMutationSelector() {\n    return (id) => {\n      let mutationId;\n      if (typeof id === \"object\") {\n        mutationId = getMutationCacheKey(id) ?? skipToken;\n      } else {\n        mutationId = id;\n      }\n      const selectMutationSubstate = (state) => selectInternalState(state)?.mutations?.[mutationId] ?? defaultMutationSubState;\n      const finalSelectMutationSubstate = mutationId === skipToken ? selectSkippedMutation : selectMutationSubstate;\n      return createSelector2(finalSelectMutationSubstate, withRequestFlags);\n    };\n  }\n  function selectInvalidatedBy(state, tags) {\n    const apiState = state[reducerPath];\n    const toInvalidate = /* @__PURE__ */ new Set();\n    for (const tag of tags.map(expandTagDescription)) {\n      const provided = apiState.provided[tag.type];\n      if (!provided) {\n        continue;\n      }\n      let invalidateSubscriptions = (tag.id !== void 0 ? (\n        // id given: invalidate all queries that provide this type & id\n        provided[tag.id]\n      ) : (\n        // no id: invalidate all queries that provide this type\n        flatten(Object.values(provided))\n      )) ?? [];\n      for (const invalidate of invalidateSubscriptions) {\n        toInvalidate.add(invalidate);\n      }\n    }\n    return flatten(Array.from(toInvalidate.values()).map((queryCacheKey) => {\n      const querySubState = apiState.queries[queryCacheKey];\n      return querySubState ? [{\n        queryCacheKey,\n        endpointName: querySubState.endpointName,\n        originalArgs: querySubState.originalArgs\n      }] : [];\n    }));\n  }\n  function selectCachedArgsForQuery(state, queryName) {\n    return Object.values(state[reducerPath].queries).filter((entry) => entry?.endpointName === queryName && entry.status !== \"uninitialized\" /* uninitialized */).map((entry) => entry.originalArgs);\n  }\n}\n\n// src/query/createApi.ts\n\n\n// src/query/defaultSerializeQueryArgs.ts\nvar cache = WeakMap ? /* @__PURE__ */ new WeakMap() : void 0;\nvar defaultSerializeQueryArgs = ({\n  endpointName,\n  queryArgs\n}) => {\n  let serialized = \"\";\n  const cached = cache?.get(queryArgs);\n  if (typeof cached === \"string\") {\n    serialized = cached;\n  } else {\n    const stringified = JSON.stringify(queryArgs, (key, value) => {\n      value = typeof value === \"bigint\" ? {\n        $bigint: value.toString()\n      } : value;\n      value = (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(value) ? Object.keys(value).sort().reduce((acc, key2) => {\n        acc[key2] = value[key2];\n        return acc;\n      }, {}) : value;\n      return value;\n    });\n    if ((0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(queryArgs)) {\n      cache?.set(queryArgs, stringified);\n    }\n    serialized = stringified;\n  }\n  return `${endpointName}(${serialized})`;\n};\n\n// src/query/createApi.ts\n\nfunction buildCreateApi(...modules) {\n  return function baseCreateApi(options) {\n    const extractRehydrationInfo = (0,reselect__WEBPACK_IMPORTED_MODULE_3__.weakMapMemoize)((action) => options.extractRehydrationInfo?.(action, {\n      reducerPath: options.reducerPath ?? \"api\"\n    }));\n    const optionsWithDefaults = {\n      reducerPath: \"api\",\n      keepUnusedDataFor: 60,\n      refetchOnMountOrArgChange: false,\n      refetchOnFocus: false,\n      refetchOnReconnect: false,\n      invalidationBehavior: \"delayed\",\n      ...options,\n      extractRehydrationInfo,\n      serializeQueryArgs(queryArgsApi) {\n        let finalSerializeQueryArgs = defaultSerializeQueryArgs;\n        if (\"serializeQueryArgs\" in queryArgsApi.endpointDefinition) {\n          const endpointSQA = queryArgsApi.endpointDefinition.serializeQueryArgs;\n          finalSerializeQueryArgs = (queryArgsApi2) => {\n            const initialResult = endpointSQA(queryArgsApi2);\n            if (typeof initialResult === \"string\") {\n              return initialResult;\n            } else {\n              return defaultSerializeQueryArgs({\n                ...queryArgsApi2,\n                queryArgs: initialResult\n              });\n            }\n          };\n        } else if (options.serializeQueryArgs) {\n          finalSerializeQueryArgs = options.serializeQueryArgs;\n        }\n        return finalSerializeQueryArgs(queryArgsApi);\n      },\n      tagTypes: [...options.tagTypes || []]\n    };\n    const context = {\n      endpointDefinitions: {},\n      batch(fn) {\n        fn();\n      },\n      apiUid: (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.nanoid)(),\n      extractRehydrationInfo,\n      hasRehydrationInfo: (0,reselect__WEBPACK_IMPORTED_MODULE_3__.weakMapMemoize)((action) => extractRehydrationInfo(action) != null)\n    };\n    const api = {\n      injectEndpoints,\n      enhanceEndpoints({\n        addTagTypes,\n        endpoints\n      }) {\n        if (addTagTypes) {\n          for (const eT of addTagTypes) {\n            if (!optionsWithDefaults.tagTypes.includes(eT)) {\n              ;\n              optionsWithDefaults.tagTypes.push(eT);\n            }\n          }\n        }\n        if (endpoints) {\n          for (const [endpointName, partialDefinition] of Object.entries(endpoints)) {\n            if (typeof partialDefinition === \"function\") {\n              partialDefinition(context.endpointDefinitions[endpointName]);\n            } else {\n              Object.assign(context.endpointDefinitions[endpointName] || {}, partialDefinition);\n            }\n          }\n        }\n        return api;\n      }\n    };\n    const initializedModules = modules.map((m) => m.init(api, optionsWithDefaults, context));\n    function injectEndpoints(inject) {\n      const evaluatedEndpoints = inject.endpoints({\n        query: (x) => ({\n          ...x,\n          type: \"query\" /* query */\n        }),\n        mutation: (x) => ({\n          ...x,\n          type: \"mutation\" /* mutation */\n        })\n      });\n      for (const [endpointName, definition] of Object.entries(evaluatedEndpoints)) {\n        if (inject.overrideExisting !== true && endpointName in context.endpointDefinitions) {\n          if (inject.overrideExisting === \"throw\") {\n            throw new Error( false ? 0 : `called \\`injectEndpoints\\` to override already-existing endpointName ${endpointName} without specifying \\`overrideExisting: true\\``);\n          } else if (typeof process !== \"undefined\" && \"development\" === \"development\") {\n            console.error(`called \\`injectEndpoints\\` to override already-existing endpointName ${endpointName} without specifying \\`overrideExisting: true\\``);\n          }\n          continue;\n        }\n        context.endpointDefinitions[endpointName] = definition;\n        for (const m of initializedModules) {\n          m.injectEndpoint(endpointName, definition);\n        }\n      }\n      return api;\n    }\n    return api.injectEndpoints({\n      endpoints: options.endpoints\n    });\n  };\n}\n\n// src/query/fakeBaseQuery.ts\n\nvar _NEVER = /* @__PURE__ */ Symbol();\nfunction fakeBaseQuery() {\n  return function() {\n    throw new Error( false ? 0 : \"When using `fakeBaseQuery`, all queries & mutations must use the `queryFn` definition syntax.\");\n  };\n}\n\n// src/query/core/module.ts\n\n\n// src/query/tsHelpers.ts\nfunction assertCast(v) {\n}\nfunction safeAssign(target, ...args) {\n  return Object.assign(target, ...args);\n}\n\n// src/query/core/buildMiddleware/batchActions.ts\n\nvar buildBatchedActionsHandler = ({\n  api,\n  queryThunk,\n  internalState\n}) => {\n  const subscriptionsPrefix = `${api.reducerPath}/subscriptions`;\n  let previousSubscriptions = null;\n  let updateSyncTimer = null;\n  const {\n    updateSubscriptionOptions,\n    unsubscribeQueryResult\n  } = api.internalActions;\n  const actuallyMutateSubscriptions = (mutableState, action) => {\n    if (updateSubscriptionOptions.match(action)) {\n      const {\n        queryCacheKey,\n        requestId,\n        options\n      } = action.payload;\n      if (mutableState?.[queryCacheKey]?.[requestId]) {\n        mutableState[queryCacheKey][requestId] = options;\n      }\n      return true;\n    }\n    if (unsubscribeQueryResult.match(action)) {\n      const {\n        queryCacheKey,\n        requestId\n      } = action.payload;\n      if (mutableState[queryCacheKey]) {\n        delete mutableState[queryCacheKey][requestId];\n      }\n      return true;\n    }\n    if (api.internalActions.removeQueryResult.match(action)) {\n      delete mutableState[action.payload.queryCacheKey];\n      return true;\n    }\n    if (queryThunk.pending.match(action)) {\n      const {\n        meta: {\n          arg,\n          requestId\n        }\n      } = action;\n      const substate = mutableState[arg.queryCacheKey] ??= {};\n      substate[`${requestId}_running`] = {};\n      if (arg.subscribe) {\n        substate[requestId] = arg.subscriptionOptions ?? substate[requestId] ?? {};\n      }\n      return true;\n    }\n    let mutated = false;\n    if (queryThunk.fulfilled.match(action) || queryThunk.rejected.match(action)) {\n      const state = mutableState[action.meta.arg.queryCacheKey] || {};\n      const key = `${action.meta.requestId}_running`;\n      mutated ||= !!state[key];\n      delete state[key];\n    }\n    if (queryThunk.rejected.match(action)) {\n      const {\n        meta: {\n          condition,\n          arg,\n          requestId\n        }\n      } = action;\n      if (condition && arg.subscribe) {\n        const substate = mutableState[arg.queryCacheKey] ??= {};\n        substate[requestId] = arg.subscriptionOptions ?? substate[requestId] ?? {};\n        mutated = true;\n      }\n    }\n    return mutated;\n  };\n  const getSubscriptions = () => internalState.currentSubscriptions;\n  const getSubscriptionCount = (queryCacheKey) => {\n    const subscriptions = getSubscriptions();\n    const subscriptionsForQueryArg = subscriptions[queryCacheKey] ?? {};\n    return countObjectKeys(subscriptionsForQueryArg);\n  };\n  const isRequestSubscribed = (queryCacheKey, requestId) => {\n    const subscriptions = getSubscriptions();\n    return !!subscriptions?.[queryCacheKey]?.[requestId];\n  };\n  const subscriptionSelectors = {\n    getSubscriptions,\n    getSubscriptionCount,\n    isRequestSubscribed\n  };\n  return (action, mwApi) => {\n    if (!previousSubscriptions) {\n      previousSubscriptions = JSON.parse(JSON.stringify(internalState.currentSubscriptions));\n    }\n    if (api.util.resetApiState.match(action)) {\n      previousSubscriptions = internalState.currentSubscriptions = {};\n      updateSyncTimer = null;\n      return [true, false];\n    }\n    if (api.internalActions.internal_getRTKQSubscriptions.match(action)) {\n      return [false, subscriptionSelectors];\n    }\n    const didMutate = actuallyMutateSubscriptions(internalState.currentSubscriptions, action);\n    let actionShouldContinue = true;\n    if (didMutate) {\n      if (!updateSyncTimer) {\n        updateSyncTimer = setTimeout(() => {\n          const newSubscriptions = JSON.parse(JSON.stringify(internalState.currentSubscriptions));\n          const [, patches] = (0,immer__WEBPACK_IMPORTED_MODULE_2__.produceWithPatches)(previousSubscriptions, () => newSubscriptions);\n          mwApi.next(api.internalActions.subscriptionsUpdated(patches));\n          previousSubscriptions = newSubscriptions;\n          updateSyncTimer = null;\n        }, 500);\n      }\n      const isSubscriptionSliceAction = typeof action.type == \"string\" && !!action.type.startsWith(subscriptionsPrefix);\n      const isAdditionalSubscriptionAction = queryThunk.rejected.match(action) && action.meta.condition && !!action.meta.arg.subscribe;\n      actionShouldContinue = !isSubscriptionSliceAction && !isAdditionalSubscriptionAction;\n    }\n    return [actionShouldContinue, false];\n  };\n};\n\n// src/query/core/buildMiddleware/cacheCollection.ts\nfunction isObjectEmpty(obj) {\n  for (const k in obj) {\n    return false;\n  }\n  return true;\n}\nvar THIRTY_TWO_BIT_MAX_TIMER_SECONDS = 2147483647 / 1e3 - 1;\nvar buildCacheCollectionHandler = ({\n  reducerPath,\n  api,\n  queryThunk,\n  context,\n  internalState\n}) => {\n  const {\n    removeQueryResult,\n    unsubscribeQueryResult\n  } = api.internalActions;\n  const canTriggerUnsubscribe = (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.isAnyOf)(unsubscribeQueryResult.match, queryThunk.fulfilled, queryThunk.rejected);\n  function anySubscriptionsRemainingForKey(queryCacheKey) {\n    const subscriptions = internalState.currentSubscriptions[queryCacheKey];\n    return !!subscriptions && !isObjectEmpty(subscriptions);\n  }\n  const currentRemovalTimeouts = {};\n  const handler = (action, mwApi, internalState2) => {\n    if (canTriggerUnsubscribe(action)) {\n      const state = mwApi.getState()[reducerPath];\n      const {\n        queryCacheKey\n      } = unsubscribeQueryResult.match(action) ? action.payload : action.meta.arg;\n      handleUnsubscribe(queryCacheKey, state.queries[queryCacheKey]?.endpointName, mwApi, state.config);\n    }\n    if (api.util.resetApiState.match(action)) {\n      for (const [key, timeout] of Object.entries(currentRemovalTimeouts)) {\n        if (timeout) clearTimeout(timeout);\n        delete currentRemovalTimeouts[key];\n      }\n    }\n    if (context.hasRehydrationInfo(action)) {\n      const state = mwApi.getState()[reducerPath];\n      const {\n        queries\n      } = context.extractRehydrationInfo(action);\n      for (const [queryCacheKey, queryState] of Object.entries(queries)) {\n        handleUnsubscribe(queryCacheKey, queryState?.endpointName, mwApi, state.config);\n      }\n    }\n  };\n  function handleUnsubscribe(queryCacheKey, endpointName, api2, config) {\n    const endpointDefinition = context.endpointDefinitions[endpointName];\n    const keepUnusedDataFor = endpointDefinition?.keepUnusedDataFor ?? config.keepUnusedDataFor;\n    if (keepUnusedDataFor === Infinity) {\n      return;\n    }\n    const finalKeepUnusedDataFor = Math.max(0, Math.min(keepUnusedDataFor, THIRTY_TWO_BIT_MAX_TIMER_SECONDS));\n    if (!anySubscriptionsRemainingForKey(queryCacheKey)) {\n      const currentTimeout = currentRemovalTimeouts[queryCacheKey];\n      if (currentTimeout) {\n        clearTimeout(currentTimeout);\n      }\n      currentRemovalTimeouts[queryCacheKey] = setTimeout(() => {\n        if (!anySubscriptionsRemainingForKey(queryCacheKey)) {\n          api2.dispatch(removeQueryResult({\n            queryCacheKey\n          }));\n        }\n        delete currentRemovalTimeouts[queryCacheKey];\n      }, finalKeepUnusedDataFor * 1e3);\n    }\n  }\n  return handler;\n};\n\n// src/query/core/buildMiddleware/cacheLifecycle.ts\nvar neverResolvedError = new Error(\"Promise never resolved before cacheEntryRemoved.\");\nvar buildCacheLifecycleHandler = ({\n  api,\n  reducerPath,\n  context,\n  queryThunk,\n  mutationThunk,\n  internalState\n}) => {\n  const isQueryThunk = (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.isAsyncThunkAction)(queryThunk);\n  const isMutationThunk = (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.isAsyncThunkAction)(mutationThunk);\n  const isFulfilledThunk = (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.isFulfilled)(queryThunk, mutationThunk);\n  const lifecycleMap = {};\n  const handler = (action, mwApi, stateBefore) => {\n    const cacheKey = getCacheKey(action);\n    if (queryThunk.pending.match(action)) {\n      const oldState = stateBefore[reducerPath].queries[cacheKey];\n      const state = mwApi.getState()[reducerPath].queries[cacheKey];\n      if (!oldState && state) {\n        handleNewKey(action.meta.arg.endpointName, action.meta.arg.originalArgs, cacheKey, mwApi, action.meta.requestId);\n      }\n    } else if (mutationThunk.pending.match(action)) {\n      const state = mwApi.getState()[reducerPath].mutations[cacheKey];\n      if (state) {\n        handleNewKey(action.meta.arg.endpointName, action.meta.arg.originalArgs, cacheKey, mwApi, action.meta.requestId);\n      }\n    } else if (isFulfilledThunk(action)) {\n      const lifecycle = lifecycleMap[cacheKey];\n      if (lifecycle?.valueResolved) {\n        lifecycle.valueResolved({\n          data: action.payload,\n          meta: action.meta.baseQueryMeta\n        });\n        delete lifecycle.valueResolved;\n      }\n    } else if (api.internalActions.removeQueryResult.match(action) || api.internalActions.removeMutationResult.match(action)) {\n      const lifecycle = lifecycleMap[cacheKey];\n      if (lifecycle) {\n        delete lifecycleMap[cacheKey];\n        lifecycle.cacheEntryRemoved();\n      }\n    } else if (api.util.resetApiState.match(action)) {\n      for (const [cacheKey2, lifecycle] of Object.entries(lifecycleMap)) {\n        delete lifecycleMap[cacheKey2];\n        lifecycle.cacheEntryRemoved();\n      }\n    }\n  };\n  function getCacheKey(action) {\n    if (isQueryThunk(action)) return action.meta.arg.queryCacheKey;\n    if (isMutationThunk(action)) {\n      return action.meta.arg.fixedCacheKey ?? action.meta.requestId;\n    }\n    if (api.internalActions.removeQueryResult.match(action)) return action.payload.queryCacheKey;\n    if (api.internalActions.removeMutationResult.match(action)) return getMutationCacheKey(action.payload);\n    return \"\";\n  }\n  function handleNewKey(endpointName, originalArgs, queryCacheKey, mwApi, requestId) {\n    const endpointDefinition = context.endpointDefinitions[endpointName];\n    const onCacheEntryAdded = endpointDefinition?.onCacheEntryAdded;\n    if (!onCacheEntryAdded) return;\n    const lifecycle = {};\n    const cacheEntryRemoved = new Promise((resolve) => {\n      lifecycle.cacheEntryRemoved = resolve;\n    });\n    const cacheDataLoaded = Promise.race([new Promise((resolve) => {\n      lifecycle.valueResolved = resolve;\n    }), cacheEntryRemoved.then(() => {\n      throw neverResolvedError;\n    })]);\n    cacheDataLoaded.catch(() => {\n    });\n    lifecycleMap[queryCacheKey] = lifecycle;\n    const selector = api.endpoints[endpointName].select(endpointDefinition.type === \"query\" /* query */ ? originalArgs : queryCacheKey);\n    const extra = mwApi.dispatch((_, __, extra2) => extra2);\n    const lifecycleApi = {\n      ...mwApi,\n      getCacheEntry: () => selector(mwApi.getState()),\n      requestId,\n      extra,\n      updateCachedData: endpointDefinition.type === \"query\" /* query */ ? (updateRecipe) => mwApi.dispatch(api.util.updateQueryData(endpointName, originalArgs, updateRecipe)) : void 0,\n      cacheDataLoaded,\n      cacheEntryRemoved\n    };\n    const runningHandler = onCacheEntryAdded(originalArgs, lifecycleApi);\n    Promise.resolve(runningHandler).catch((e) => {\n      if (e === neverResolvedError) return;\n      throw e;\n    });\n  }\n  return handler;\n};\n\n// src/query/core/buildMiddleware/devMiddleware.ts\nvar buildDevCheckHandler = ({\n  api,\n  context: {\n    apiUid\n  },\n  reducerPath\n}) => {\n  return (action, mwApi) => {\n    if (api.util.resetApiState.match(action)) {\n      mwApi.dispatch(api.internalActions.middlewareRegistered(apiUid));\n    }\n    if (typeof process !== \"undefined\" && \"development\" === \"development\") {\n      if (api.internalActions.middlewareRegistered.match(action) && action.payload === apiUid && mwApi.getState()[reducerPath]?.config?.middlewareRegistered === \"conflict\") {\n        console.warn(`There is a mismatch between slice and middleware for the reducerPath \"${reducerPath}\".\nYou can only have one api per reducer path, this will lead to crashes in various situations!${reducerPath === \"api\" ? `\nIf you have multiple apis, you *have* to specify the reducerPath option when using createApi!` : \"\"}`);\n      }\n    }\n  };\n};\n\n// src/query/core/buildMiddleware/invalidationByTags.ts\nvar buildInvalidationByTagsHandler = ({\n  reducerPath,\n  context,\n  context: {\n    endpointDefinitions\n  },\n  mutationThunk,\n  queryThunk,\n  api,\n  assertTagType,\n  refetchQuery,\n  internalState\n}) => {\n  const {\n    removeQueryResult\n  } = api.internalActions;\n  const isThunkActionWithTags = (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.isAnyOf)((0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.isFulfilled)(mutationThunk), (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.isRejectedWithValue)(mutationThunk));\n  const isQueryEnd = (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.isAnyOf)((0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.isFulfilled)(mutationThunk, queryThunk), (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.isRejected)(mutationThunk, queryThunk));\n  let pendingTagInvalidations = [];\n  const handler = (action, mwApi) => {\n    if (isThunkActionWithTags(action)) {\n      invalidateTags(calculateProvidedByThunk(action, \"invalidatesTags\", endpointDefinitions, assertTagType), mwApi);\n    } else if (isQueryEnd(action)) {\n      invalidateTags([], mwApi);\n    } else if (api.util.invalidateTags.match(action)) {\n      invalidateTags(calculateProvidedBy(action.payload, void 0, void 0, void 0, void 0, assertTagType), mwApi);\n    }\n  };\n  function hasPendingRequests(state) {\n    for (const key in state.queries) {\n      if (state.queries[key]?.status === \"pending\" /* pending */) return true;\n    }\n    for (const key in state.mutations) {\n      if (state.mutations[key]?.status === \"pending\" /* pending */) return true;\n    }\n    return false;\n  }\n  function invalidateTags(newTags, mwApi) {\n    const rootState = mwApi.getState();\n    const state = rootState[reducerPath];\n    pendingTagInvalidations.push(...newTags);\n    if (state.config.invalidationBehavior === \"delayed\" && hasPendingRequests(state)) {\n      return;\n    }\n    const tags = pendingTagInvalidations;\n    pendingTagInvalidations = [];\n    if (tags.length === 0) return;\n    const toInvalidate = api.util.selectInvalidatedBy(rootState, tags);\n    context.batch(() => {\n      const valuesArray = Array.from(toInvalidate.values());\n      for (const {\n        queryCacheKey\n      } of valuesArray) {\n        const querySubState = state.queries[queryCacheKey];\n        const subscriptionSubState = internalState.currentSubscriptions[queryCacheKey] ?? {};\n        if (querySubState) {\n          if (countObjectKeys(subscriptionSubState) === 0) {\n            mwApi.dispatch(removeQueryResult({\n              queryCacheKey\n            }));\n          } else if (querySubState.status !== \"uninitialized\" /* uninitialized */) {\n            mwApi.dispatch(refetchQuery(querySubState, queryCacheKey));\n          }\n        }\n      }\n    });\n  }\n  return handler;\n};\n\n// src/query/core/buildMiddleware/polling.ts\nvar buildPollingHandler = ({\n  reducerPath,\n  queryThunk,\n  api,\n  refetchQuery,\n  internalState\n}) => {\n  const currentPolls = {};\n  const handler = (action, mwApi) => {\n    if (api.internalActions.updateSubscriptionOptions.match(action) || api.internalActions.unsubscribeQueryResult.match(action)) {\n      updatePollingInterval(action.payload, mwApi);\n    }\n    if (queryThunk.pending.match(action) || queryThunk.rejected.match(action) && action.meta.condition) {\n      updatePollingInterval(action.meta.arg, mwApi);\n    }\n    if (queryThunk.fulfilled.match(action) || queryThunk.rejected.match(action) && !action.meta.condition) {\n      startNextPoll(action.meta.arg, mwApi);\n    }\n    if (api.util.resetApiState.match(action)) {\n      clearPolls();\n    }\n  };\n  function startNextPoll({\n    queryCacheKey\n  }, api2) {\n    const state = api2.getState()[reducerPath];\n    const querySubState = state.queries[queryCacheKey];\n    const subscriptions = internalState.currentSubscriptions[queryCacheKey];\n    if (!querySubState || querySubState.status === \"uninitialized\" /* uninitialized */) return;\n    const {\n      lowestPollingInterval,\n      skipPollingIfUnfocused\n    } = findLowestPollingInterval(subscriptions);\n    if (!Number.isFinite(lowestPollingInterval)) return;\n    const currentPoll = currentPolls[queryCacheKey];\n    if (currentPoll?.timeout) {\n      clearTimeout(currentPoll.timeout);\n      currentPoll.timeout = void 0;\n    }\n    const nextPollTimestamp = Date.now() + lowestPollingInterval;\n    currentPolls[queryCacheKey] = {\n      nextPollTimestamp,\n      pollingInterval: lowestPollingInterval,\n      timeout: setTimeout(() => {\n        if (state.config.focused || !skipPollingIfUnfocused) {\n          api2.dispatch(refetchQuery(querySubState, queryCacheKey));\n        }\n        startNextPoll({\n          queryCacheKey\n        }, api2);\n      }, lowestPollingInterval)\n    };\n  }\n  function updatePollingInterval({\n    queryCacheKey\n  }, api2) {\n    const state = api2.getState()[reducerPath];\n    const querySubState = state.queries[queryCacheKey];\n    const subscriptions = internalState.currentSubscriptions[queryCacheKey];\n    if (!querySubState || querySubState.status === \"uninitialized\" /* uninitialized */) {\n      return;\n    }\n    const {\n      lowestPollingInterval\n    } = findLowestPollingInterval(subscriptions);\n    if (!Number.isFinite(lowestPollingInterval)) {\n      cleanupPollForKey(queryCacheKey);\n      return;\n    }\n    const currentPoll = currentPolls[queryCacheKey];\n    const nextPollTimestamp = Date.now() + lowestPollingInterval;\n    if (!currentPoll || nextPollTimestamp < currentPoll.nextPollTimestamp) {\n      startNextPoll({\n        queryCacheKey\n      }, api2);\n    }\n  }\n  function cleanupPollForKey(key) {\n    const existingPoll = currentPolls[key];\n    if (existingPoll?.timeout) {\n      clearTimeout(existingPoll.timeout);\n    }\n    delete currentPolls[key];\n  }\n  function clearPolls() {\n    for (const key of Object.keys(currentPolls)) {\n      cleanupPollForKey(key);\n    }\n  }\n  function findLowestPollingInterval(subscribers = {}) {\n    let skipPollingIfUnfocused = false;\n    let lowestPollingInterval = Number.POSITIVE_INFINITY;\n    for (let key in subscribers) {\n      if (!!subscribers[key].pollingInterval) {\n        lowestPollingInterval = Math.min(subscribers[key].pollingInterval, lowestPollingInterval);\n        skipPollingIfUnfocused = subscribers[key].skipPollingIfUnfocused || skipPollingIfUnfocused;\n      }\n    }\n    return {\n      lowestPollingInterval,\n      skipPollingIfUnfocused\n    };\n  }\n  return handler;\n};\n\n// src/query/core/buildMiddleware/queryLifecycle.ts\nvar buildQueryLifecycleHandler = ({\n  api,\n  context,\n  queryThunk,\n  mutationThunk\n}) => {\n  const isPendingThunk = (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.isPending)(queryThunk, mutationThunk);\n  const isRejectedThunk = (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.isRejected)(queryThunk, mutationThunk);\n  const isFullfilledThunk = (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.isFulfilled)(queryThunk, mutationThunk);\n  const lifecycleMap = {};\n  const handler = (action, mwApi) => {\n    if (isPendingThunk(action)) {\n      const {\n        requestId,\n        arg: {\n          endpointName,\n          originalArgs\n        }\n      } = action.meta;\n      const endpointDefinition = context.endpointDefinitions[endpointName];\n      const onQueryStarted = endpointDefinition?.onQueryStarted;\n      if (onQueryStarted) {\n        const lifecycle = {};\n        const queryFulfilled = new Promise((resolve, reject) => {\n          lifecycle.resolve = resolve;\n          lifecycle.reject = reject;\n        });\n        queryFulfilled.catch(() => {\n        });\n        lifecycleMap[requestId] = lifecycle;\n        const selector = api.endpoints[endpointName].select(endpointDefinition.type === \"query\" /* query */ ? originalArgs : requestId);\n        const extra = mwApi.dispatch((_, __, extra2) => extra2);\n        const lifecycleApi = {\n          ...mwApi,\n          getCacheEntry: () => selector(mwApi.getState()),\n          requestId,\n          extra,\n          updateCachedData: endpointDefinition.type === \"query\" /* query */ ? (updateRecipe) => mwApi.dispatch(api.util.updateQueryData(endpointName, originalArgs, updateRecipe)) : void 0,\n          queryFulfilled\n        };\n        onQueryStarted(originalArgs, lifecycleApi);\n      }\n    } else if (isFullfilledThunk(action)) {\n      const {\n        requestId,\n        baseQueryMeta\n      } = action.meta;\n      lifecycleMap[requestId]?.resolve({\n        data: action.payload,\n        meta: baseQueryMeta\n      });\n      delete lifecycleMap[requestId];\n    } else if (isRejectedThunk(action)) {\n      const {\n        requestId,\n        rejectedWithValue,\n        baseQueryMeta\n      } = action.meta;\n      lifecycleMap[requestId]?.reject({\n        error: action.payload ?? action.error,\n        isUnhandledError: !rejectedWithValue,\n        meta: baseQueryMeta\n      });\n      delete lifecycleMap[requestId];\n    }\n  };\n  return handler;\n};\n\n// src/query/core/buildMiddleware/windowEventHandling.ts\nvar buildWindowEventHandler = ({\n  reducerPath,\n  context,\n  api,\n  refetchQuery,\n  internalState\n}) => {\n  const {\n    removeQueryResult\n  } = api.internalActions;\n  const handler = (action, mwApi) => {\n    if (onFocus.match(action)) {\n      refetchValidQueries(mwApi, \"refetchOnFocus\");\n    }\n    if (onOnline.match(action)) {\n      refetchValidQueries(mwApi, \"refetchOnReconnect\");\n    }\n  };\n  function refetchValidQueries(api2, type) {\n    const state = api2.getState()[reducerPath];\n    const queries = state.queries;\n    const subscriptions = internalState.currentSubscriptions;\n    context.batch(() => {\n      for (const queryCacheKey of Object.keys(subscriptions)) {\n        const querySubState = queries[queryCacheKey];\n        const subscriptionSubState = subscriptions[queryCacheKey];\n        if (!subscriptionSubState || !querySubState) continue;\n        const shouldRefetch = Object.values(subscriptionSubState).some((sub) => sub[type] === true) || Object.values(subscriptionSubState).every((sub) => sub[type] === void 0) && state.config[type];\n        if (shouldRefetch) {\n          if (countObjectKeys(subscriptionSubState) === 0) {\n            api2.dispatch(removeQueryResult({\n              queryCacheKey\n            }));\n          } else if (querySubState.status !== \"uninitialized\" /* uninitialized */) {\n            api2.dispatch(refetchQuery(querySubState, queryCacheKey));\n          }\n        }\n      }\n    });\n  }\n  return handler;\n};\n\n// src/query/core/buildMiddleware/index.ts\nfunction buildMiddleware(input) {\n  const {\n    reducerPath,\n    queryThunk,\n    api,\n    context\n  } = input;\n  const {\n    apiUid\n  } = context;\n  const actions = {\n    invalidateTags: (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.createAction)(`${reducerPath}/invalidateTags`)\n  };\n  const isThisApiSliceAction = (action) => action.type.startsWith(`${reducerPath}/`);\n  const handlerBuilders = [buildDevCheckHandler, buildCacheCollectionHandler, buildInvalidationByTagsHandler, buildPollingHandler, buildCacheLifecycleHandler, buildQueryLifecycleHandler];\n  const middleware = (mwApi) => {\n    let initialized2 = false;\n    const internalState = {\n      currentSubscriptions: {}\n    };\n    const builderArgs = {\n      ...input,\n      internalState,\n      refetchQuery,\n      isThisApiSliceAction\n    };\n    const handlers = handlerBuilders.map((build) => build(builderArgs));\n    const batchedActionsHandler = buildBatchedActionsHandler(builderArgs);\n    const windowEventsHandler = buildWindowEventHandler(builderArgs);\n    return (next) => {\n      return (action) => {\n        if (!(0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__.isAction)(action)) {\n          return next(action);\n        }\n        if (!initialized2) {\n          initialized2 = true;\n          mwApi.dispatch(api.internalActions.middlewareRegistered(apiUid));\n        }\n        const mwApiWithNext = {\n          ...mwApi,\n          next\n        };\n        const stateBefore = mwApi.getState();\n        const [actionShouldContinue, internalProbeResult] = batchedActionsHandler(action, mwApiWithNext, stateBefore);\n        let res;\n        if (actionShouldContinue) {\n          res = next(action);\n        } else {\n          res = internalProbeResult;\n        }\n        if (!!mwApi.getState()[reducerPath]) {\n          windowEventsHandler(action, mwApiWithNext, stateBefore);\n          if (isThisApiSliceAction(action) || context.hasRehydrationInfo(action)) {\n            for (const handler of handlers) {\n              handler(action, mwApiWithNext, stateBefore);\n            }\n          }\n        }\n        return res;\n      };\n    };\n  };\n  return {\n    middleware,\n    actions\n  };\n  function refetchQuery(querySubState, queryCacheKey, override = {}) {\n    return queryThunk({\n      type: \"query\",\n      endpointName: querySubState.endpointName,\n      originalArgs: querySubState.originalArgs,\n      subscribe: false,\n      forceRefetch: true,\n      queryCacheKey,\n      ...override\n    });\n  }\n}\n\n// src/query/core/module.ts\nvar coreModuleName = /* @__PURE__ */ Symbol();\nvar coreModule = ({\n  createSelector: createSelector2 = reselect__WEBPACK_IMPORTED_MODULE_3__.createSelector\n} = {}) => ({\n  name: coreModuleName,\n  init(api, {\n    baseQuery,\n    tagTypes,\n    reducerPath,\n    serializeQueryArgs,\n    keepUnusedDataFor,\n    refetchOnMountOrArgChange,\n    refetchOnFocus,\n    refetchOnReconnect,\n    invalidationBehavior\n  }, context) {\n    (0,immer__WEBPACK_IMPORTED_MODULE_2__.enablePatches)();\n    assertCast(serializeQueryArgs);\n    const assertTagType = (tag) => {\n      if (typeof process !== \"undefined\" && \"development\" === \"development\") {\n        if (!tagTypes.includes(tag.type)) {\n          console.error(`Tag type '${tag.type}' was used, but not specified in \\`tagTypes\\`!`);\n        }\n      }\n      return tag;\n    };\n    Object.assign(api, {\n      reducerPath,\n      endpoints: {},\n      internalActions: {\n        onOnline,\n        onOffline,\n        onFocus,\n        onFocusLost\n      },\n      util: {}\n    });\n    const {\n      queryThunk,\n      mutationThunk,\n      patchQueryData,\n      updateQueryData,\n      upsertQueryData,\n      prefetch,\n      buildMatchThunkActions\n    } = buildThunks({\n      baseQuery,\n      reducerPath,\n      context,\n      api,\n      serializeQueryArgs,\n      assertTagType\n    });\n    const {\n      reducer,\n      actions: sliceActions\n    } = buildSlice({\n      context,\n      queryThunk,\n      mutationThunk,\n      reducerPath,\n      assertTagType,\n      config: {\n        refetchOnFocus,\n        refetchOnReconnect,\n        refetchOnMountOrArgChange,\n        keepUnusedDataFor,\n        reducerPath,\n        invalidationBehavior\n      }\n    });\n    safeAssign(api.util, {\n      patchQueryData,\n      updateQueryData,\n      upsertQueryData,\n      prefetch,\n      resetApiState: sliceActions.resetApiState\n    });\n    safeAssign(api.internalActions, sliceActions);\n    const {\n      middleware,\n      actions: middlewareActions\n    } = buildMiddleware({\n      reducerPath,\n      context,\n      queryThunk,\n      mutationThunk,\n      api,\n      assertTagType\n    });\n    safeAssign(api.util, middlewareActions);\n    safeAssign(api, {\n      reducer,\n      middleware\n    });\n    const {\n      buildQuerySelector,\n      buildMutationSelector,\n      selectInvalidatedBy,\n      selectCachedArgsForQuery\n    } = buildSelectors({\n      serializeQueryArgs,\n      reducerPath,\n      createSelector: createSelector2\n    });\n    safeAssign(api.util, {\n      selectInvalidatedBy,\n      selectCachedArgsForQuery\n    });\n    const {\n      buildInitiateQuery,\n      buildInitiateMutation,\n      getRunningMutationThunk,\n      getRunningMutationsThunk,\n      getRunningQueriesThunk,\n      getRunningQueryThunk\n    } = buildInitiate({\n      queryThunk,\n      mutationThunk,\n      api,\n      serializeQueryArgs,\n      context\n    });\n    safeAssign(api.util, {\n      getRunningMutationThunk,\n      getRunningMutationsThunk,\n      getRunningQueryThunk,\n      getRunningQueriesThunk\n    });\n    return {\n      name: coreModuleName,\n      injectEndpoint(endpointName, definition) {\n        const anyApi = api;\n        anyApi.endpoints[endpointName] ??= {};\n        if (isQueryDefinition(definition)) {\n          safeAssign(anyApi.endpoints[endpointName], {\n            name: endpointName,\n            select: buildQuerySelector(endpointName, definition),\n            initiate: buildInitiateQuery(endpointName, definition)\n          }, buildMatchThunkActions(queryThunk, endpointName));\n        } else if (isMutationDefinition(definition)) {\n          safeAssign(anyApi.endpoints[endpointName], {\n            name: endpointName,\n            select: buildMutationSelector(),\n            initiate: buildInitiateMutation(endpointName)\n          }, buildMatchThunkActions(mutationThunk, endpointName));\n        }\n      }\n    };\n  }\n});\n\n// src/query/core/index.ts\nvar createApi = /* @__PURE__ */ buildCreateApi(coreModule());\n\n//# sourceMappingURL=rtk-query.modern.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlZHV4anMvdG9vbGtpdC9kaXN0L3F1ZXJ5L3J0ay1xdWVyeS5tb2Rlcm4ubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLG1CQUFtQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDdVM7O0FBRXZTO0FBQ0EscUJBQXFCLDJEQUFhO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxLQUFLLEVBQUUsVUFBVSxFQUFFLElBQUk7QUFDbkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sK0RBQWE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLElBQUk7QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsaUVBQWlFLCtEQUFhO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQSw4QkFBOEIsOERBQVk7QUFDMUMsa0NBQWtDLDhEQUFZO0FBQzlDLCtCQUErQiw4REFBWTtBQUMzQyxnQ0FBZ0MsOERBQVk7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUN3RDs7QUFFeEQ7QUFDcUY7O0FBRXJGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RTtBQUN6RTtBQUNBO0FBQ0EsMkVBQTJFO0FBQzNFO0FBQ0E7QUFDQSxRQUFRLElBQXFDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLE1BQXFDLEdBQUcsQ0FBMkIsNERBQTRELGdCQUFnQjtBQUN2SztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxJQUFJO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sSUFBSTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQWVFO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGllbnQvLi9ub2RlX21vZHVsZXMvQHJlZHV4anMvdG9vbGtpdC9kaXN0L3F1ZXJ5L3J0ay1xdWVyeS5tb2Rlcm4ubWpzPzMzNGYiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL3F1ZXJ5L2NvcmUvYXBpU3RhdGUudHNcbnZhciBRdWVyeVN0YXR1cyA9IC8qIEBfX1BVUkVfXyAqLyAoKFF1ZXJ5U3RhdHVzMikgPT4ge1xuICBRdWVyeVN0YXR1czJbXCJ1bmluaXRpYWxpemVkXCJdID0gXCJ1bmluaXRpYWxpemVkXCI7XG4gIFF1ZXJ5U3RhdHVzMltcInBlbmRpbmdcIl0gPSBcInBlbmRpbmdcIjtcbiAgUXVlcnlTdGF0dXMyW1wiZnVsZmlsbGVkXCJdID0gXCJmdWxmaWxsZWRcIjtcbiAgUXVlcnlTdGF0dXMyW1wicmVqZWN0ZWRcIl0gPSBcInJlamVjdGVkXCI7XG4gIHJldHVybiBRdWVyeVN0YXR1czI7XG59KShRdWVyeVN0YXR1cyB8fCB7fSk7XG5mdW5jdGlvbiBnZXRSZXF1ZXN0U3RhdHVzRmxhZ3Moc3RhdHVzKSB7XG4gIHJldHVybiB7XG4gICAgc3RhdHVzLFxuICAgIGlzVW5pbml0aWFsaXplZDogc3RhdHVzID09PSBcInVuaW5pdGlhbGl6ZWRcIiAvKiB1bmluaXRpYWxpemVkICovLFxuICAgIGlzTG9hZGluZzogc3RhdHVzID09PSBcInBlbmRpbmdcIiAvKiBwZW5kaW5nICovLFxuICAgIGlzU3VjY2Vzczogc3RhdHVzID09PSBcImZ1bGZpbGxlZFwiIC8qIGZ1bGZpbGxlZCAqLyxcbiAgICBpc0Vycm9yOiBzdGF0dXMgPT09IFwicmVqZWN0ZWRcIiAvKiByZWplY3RlZCAqL1xuICB9O1xufVxuXG4vLyBzcmMvcXVlcnkvY29yZS9ydGtJbXBvcnRzLnRzXG5pbXBvcnQgeyBjcmVhdGVBY3Rpb24sIGNyZWF0ZVNsaWNlLCBjcmVhdGVTZWxlY3RvciwgY3JlYXRlQXN5bmNUaHVuaywgY29tYmluZVJlZHVjZXJzLCBjcmVhdGVOZXh0U3RhdGUsIGlzQW55T2YsIGlzQWxsT2YsIGlzQWN0aW9uLCBpc1BlbmRpbmcsIGlzUmVqZWN0ZWQsIGlzRnVsZmlsbGVkLCBpc1JlamVjdGVkV2l0aFZhbHVlLCBpc0FzeW5jVGh1bmtBY3Rpb24sIHByZXBhcmVBdXRvQmF0Y2hlZCwgU0hPVUxEX0FVVE9CQVRDSCwgaXNQbGFpbk9iamVjdCwgbmFub2lkIH0gZnJvbSBcIkByZWR1eGpzL3Rvb2xraXRcIjtcblxuLy8gc3JjL3F1ZXJ5L3V0aWxzL2NvcHlXaXRoU3RydWN0dXJhbFNoYXJpbmcudHNcbnZhciBpc1BsYWluT2JqZWN0MiA9IGlzUGxhaW5PYmplY3Q7XG5mdW5jdGlvbiBjb3B5V2l0aFN0cnVjdHVyYWxTaGFyaW5nKG9sZE9iaiwgbmV3T2JqKSB7XG4gIGlmIChvbGRPYmogPT09IG5ld09iaiB8fCAhKGlzUGxhaW5PYmplY3QyKG9sZE9iaikgJiYgaXNQbGFpbk9iamVjdDIobmV3T2JqKSB8fCBBcnJheS5pc0FycmF5KG9sZE9iaikgJiYgQXJyYXkuaXNBcnJheShuZXdPYmopKSkge1xuICAgIHJldHVybiBuZXdPYmo7XG4gIH1cbiAgY29uc3QgbmV3S2V5cyA9IE9iamVjdC5rZXlzKG5ld09iaik7XG4gIGNvbnN0IG9sZEtleXMgPSBPYmplY3Qua2V5cyhvbGRPYmopO1xuICBsZXQgaXNTYW1lT2JqZWN0ID0gbmV3S2V5cy5sZW5ndGggPT09IG9sZEtleXMubGVuZ3RoO1xuICBjb25zdCBtZXJnZU9iaiA9IEFycmF5LmlzQXJyYXkobmV3T2JqKSA/IFtdIDoge307XG4gIGZvciAoY29uc3Qga2V5IG9mIG5ld0tleXMpIHtcbiAgICBtZXJnZU9ialtrZXldID0gY29weVdpdGhTdHJ1Y3R1cmFsU2hhcmluZyhvbGRPYmpba2V5XSwgbmV3T2JqW2tleV0pO1xuICAgIGlmIChpc1NhbWVPYmplY3QpIGlzU2FtZU9iamVjdCA9IG9sZE9ialtrZXldID09PSBtZXJnZU9ialtrZXldO1xuICB9XG4gIHJldHVybiBpc1NhbWVPYmplY3QgPyBvbGRPYmogOiBtZXJnZU9iajtcbn1cblxuLy8gc3JjL3F1ZXJ5L3V0aWxzL2NvdW50T2JqZWN0S2V5cy50c1xuZnVuY3Rpb24gY291bnRPYmplY3RLZXlzKG9iaikge1xuICBsZXQgY291bnQgPSAwO1xuICBmb3IgKGNvbnN0IF9rZXkgaW4gb2JqKSB7XG4gICAgY291bnQrKztcbiAgfVxuICByZXR1cm4gY291bnQ7XG59XG5cbi8vIHNyYy9xdWVyeS91dGlscy9mbGF0dGVuLnRzXG52YXIgZmxhdHRlbiA9IChhcnIpID0+IFtdLmNvbmNhdCguLi5hcnIpO1xuXG4vLyBzcmMvcXVlcnkvdXRpbHMvaXNBYnNvbHV0ZVVybC50c1xuZnVuY3Rpb24gaXNBYnNvbHV0ZVVybCh1cmwpIHtcbiAgcmV0dXJuIG5ldyBSZWdFeHAoYChefDopLy9gKS50ZXN0KHVybCk7XG59XG5cbi8vIHNyYy9xdWVyeS91dGlscy9pc0RvY3VtZW50VmlzaWJsZS50c1xuZnVuY3Rpb24gaXNEb2N1bWVudFZpc2libGUoKSB7XG4gIGlmICh0eXBlb2YgZG9jdW1lbnQgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZG9jdW1lbnQudmlzaWJpbGl0eVN0YXRlICE9PSBcImhpZGRlblwiO1xufVxuXG4vLyBzcmMvcXVlcnkvdXRpbHMvaXNOb3ROdWxsaXNoLnRzXG5mdW5jdGlvbiBpc05vdE51bGxpc2godikge1xuICByZXR1cm4gdiAhPSBudWxsO1xufVxuXG4vLyBzcmMvcXVlcnkvdXRpbHMvaXNPbmxpbmUudHNcbmZ1bmN0aW9uIGlzT25saW5lKCkge1xuICByZXR1cm4gdHlwZW9mIG5hdmlnYXRvciA9PT0gXCJ1bmRlZmluZWRcIiA/IHRydWUgOiBuYXZpZ2F0b3Iub25MaW5lID09PSB2b2lkIDAgPyB0cnVlIDogbmF2aWdhdG9yLm9uTGluZTtcbn1cblxuLy8gc3JjL3F1ZXJ5L3V0aWxzL2pvaW5VcmxzLnRzXG52YXIgd2l0aG91dFRyYWlsaW5nU2xhc2ggPSAodXJsKSA9PiB1cmwucmVwbGFjZSgvXFwvJC8sIFwiXCIpO1xudmFyIHdpdGhvdXRMZWFkaW5nU2xhc2ggPSAodXJsKSA9PiB1cmwucmVwbGFjZSgvXlxcLy8sIFwiXCIpO1xuZnVuY3Rpb24gam9pblVybHMoYmFzZSwgdXJsKSB7XG4gIGlmICghYmFzZSkge1xuICAgIHJldHVybiB1cmw7XG4gIH1cbiAgaWYgKCF1cmwpIHtcbiAgICByZXR1cm4gYmFzZTtcbiAgfVxuICBpZiAoaXNBYnNvbHV0ZVVybCh1cmwpKSB7XG4gICAgcmV0dXJuIHVybDtcbiAgfVxuICBjb25zdCBkZWxpbWl0ZXIgPSBiYXNlLmVuZHNXaXRoKFwiL1wiKSB8fCAhdXJsLnN0YXJ0c1dpdGgoXCI/XCIpID8gXCIvXCIgOiBcIlwiO1xuICBiYXNlID0gd2l0aG91dFRyYWlsaW5nU2xhc2goYmFzZSk7XG4gIHVybCA9IHdpdGhvdXRMZWFkaW5nU2xhc2godXJsKTtcbiAgcmV0dXJuIGAke2Jhc2V9JHtkZWxpbWl0ZXJ9JHt1cmx9YDtcbn1cblxuLy8gc3JjL3F1ZXJ5L2ZldGNoQmFzZVF1ZXJ5LnRzXG52YXIgZGVmYXVsdEZldGNoRm4gPSAoLi4uYXJncykgPT4gZmV0Y2goLi4uYXJncyk7XG52YXIgZGVmYXVsdFZhbGlkYXRlU3RhdHVzID0gKHJlc3BvbnNlKSA9PiByZXNwb25zZS5zdGF0dXMgPj0gMjAwICYmIHJlc3BvbnNlLnN0YXR1cyA8PSAyOTk7XG52YXIgZGVmYXVsdElzSnNvbkNvbnRlbnRUeXBlID0gKGhlYWRlcnMpID0+IChcbiAgLyphcHBsaWNhdCovXG4gIC9pb25cXC8odm5kXFwuYXBpXFwrKT9qc29uLy50ZXN0KGhlYWRlcnMuZ2V0KFwiY29udGVudC10eXBlXCIpIHx8IFwiXCIpXG4pO1xuZnVuY3Rpb24gc3RyaXBVbmRlZmluZWQob2JqKSB7XG4gIGlmICghaXNQbGFpbk9iamVjdChvYmopKSB7XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuICBjb25zdCBjb3B5ID0ge1xuICAgIC4uLm9ialxuICB9O1xuICBmb3IgKGNvbnN0IFtrLCB2XSBvZiBPYmplY3QuZW50cmllcyhjb3B5KSkge1xuICAgIGlmICh2ID09PSB2b2lkIDApIGRlbGV0ZSBjb3B5W2tdO1xuICB9XG4gIHJldHVybiBjb3B5O1xufVxuZnVuY3Rpb24gZmV0Y2hCYXNlUXVlcnkoe1xuICBiYXNlVXJsLFxuICBwcmVwYXJlSGVhZGVycyA9ICh4KSA9PiB4LFxuICBmZXRjaEZuID0gZGVmYXVsdEZldGNoRm4sXG4gIHBhcmFtc1NlcmlhbGl6ZXIsXG4gIGlzSnNvbkNvbnRlbnRUeXBlID0gZGVmYXVsdElzSnNvbkNvbnRlbnRUeXBlLFxuICBqc29uQ29udGVudFR5cGUgPSBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAganNvblJlcGxhY2VyLFxuICB0aW1lb3V0OiBkZWZhdWx0VGltZW91dCxcbiAgcmVzcG9uc2VIYW5kbGVyOiBnbG9iYWxSZXNwb25zZUhhbmRsZXIsXG4gIHZhbGlkYXRlU3RhdHVzOiBnbG9iYWxWYWxpZGF0ZVN0YXR1cyxcbiAgLi4uYmFzZUZldGNoT3B0aW9uc1xufSA9IHt9KSB7XG4gIGlmICh0eXBlb2YgZmV0Y2ggPT09IFwidW5kZWZpbmVkXCIgJiYgZmV0Y2hGbiA9PT0gZGVmYXVsdEZldGNoRm4pIHtcbiAgICBjb25zb2xlLndhcm4oXCJXYXJuaW5nOiBgZmV0Y2hgIGlzIG5vdCBhdmFpbGFibGUuIFBsZWFzZSBzdXBwbHkgYSBjdXN0b20gYGZldGNoRm5gIHByb3BlcnR5IHRvIHVzZSBgZmV0Y2hCYXNlUXVlcnlgIG9uIFNTUiBlbnZpcm9ubWVudHMuXCIpO1xuICB9XG4gIHJldHVybiBhc3luYyAoYXJnLCBhcGkpID0+IHtcbiAgICBjb25zdCB7XG4gICAgICBzaWduYWwsXG4gICAgICBnZXRTdGF0ZSxcbiAgICAgIGV4dHJhLFxuICAgICAgZW5kcG9pbnQsXG4gICAgICBmb3JjZWQsXG4gICAgICB0eXBlXG4gICAgfSA9IGFwaTtcbiAgICBsZXQgbWV0YTtcbiAgICBsZXQge1xuICAgICAgdXJsLFxuICAgICAgaGVhZGVycyA9IG5ldyBIZWFkZXJzKGJhc2VGZXRjaE9wdGlvbnMuaGVhZGVycyksXG4gICAgICBwYXJhbXMgPSB2b2lkIDAsXG4gICAgICByZXNwb25zZUhhbmRsZXIgPSBnbG9iYWxSZXNwb25zZUhhbmRsZXIgPz8gXCJqc29uXCIsXG4gICAgICB2YWxpZGF0ZVN0YXR1cyA9IGdsb2JhbFZhbGlkYXRlU3RhdHVzID8/IGRlZmF1bHRWYWxpZGF0ZVN0YXR1cyxcbiAgICAgIHRpbWVvdXQgPSBkZWZhdWx0VGltZW91dCxcbiAgICAgIC4uLnJlc3RcbiAgICB9ID0gdHlwZW9mIGFyZyA9PSBcInN0cmluZ1wiID8ge1xuICAgICAgdXJsOiBhcmdcbiAgICB9IDogYXJnO1xuICAgIGxldCBjb25maWcgPSB7XG4gICAgICAuLi5iYXNlRmV0Y2hPcHRpb25zLFxuICAgICAgc2lnbmFsLFxuICAgICAgLi4ucmVzdFxuICAgIH07XG4gICAgaGVhZGVycyA9IG5ldyBIZWFkZXJzKHN0cmlwVW5kZWZpbmVkKGhlYWRlcnMpKTtcbiAgICBjb25maWcuaGVhZGVycyA9IGF3YWl0IHByZXBhcmVIZWFkZXJzKGhlYWRlcnMsIHtcbiAgICAgIGdldFN0YXRlLFxuICAgICAgZXh0cmEsXG4gICAgICBlbmRwb2ludCxcbiAgICAgIGZvcmNlZCxcbiAgICAgIHR5cGVcbiAgICB9KSB8fCBoZWFkZXJzO1xuICAgIGNvbnN0IGlzSnNvbmlmaWFibGUgPSAoYm9keSkgPT4gdHlwZW9mIGJvZHkgPT09IFwib2JqZWN0XCIgJiYgKGlzUGxhaW5PYmplY3QoYm9keSkgfHwgQXJyYXkuaXNBcnJheShib2R5KSB8fCB0eXBlb2YgYm9keS50b0pTT04gPT09IFwiZnVuY3Rpb25cIik7XG4gICAgaWYgKCFjb25maWcuaGVhZGVycy5oYXMoXCJjb250ZW50LXR5cGVcIikgJiYgaXNKc29uaWZpYWJsZShjb25maWcuYm9keSkpIHtcbiAgICAgIGNvbmZpZy5oZWFkZXJzLnNldChcImNvbnRlbnQtdHlwZVwiLCBqc29uQ29udGVudFR5cGUpO1xuICAgIH1cbiAgICBpZiAoaXNKc29uaWZpYWJsZShjb25maWcuYm9keSkgJiYgaXNKc29uQ29udGVudFR5cGUoY29uZmlnLmhlYWRlcnMpKSB7XG4gICAgICBjb25maWcuYm9keSA9IEpTT04uc3RyaW5naWZ5KGNvbmZpZy5ib2R5LCBqc29uUmVwbGFjZXIpO1xuICAgIH1cbiAgICBpZiAocGFyYW1zKSB7XG4gICAgICBjb25zdCBkaXZpZGVyID0gfnVybC5pbmRleE9mKFwiP1wiKSA/IFwiJlwiIDogXCI/XCI7XG4gICAgICBjb25zdCBxdWVyeSA9IHBhcmFtc1NlcmlhbGl6ZXIgPyBwYXJhbXNTZXJpYWxpemVyKHBhcmFtcykgOiBuZXcgVVJMU2VhcmNoUGFyYW1zKHN0cmlwVW5kZWZpbmVkKHBhcmFtcykpO1xuICAgICAgdXJsICs9IGRpdmlkZXIgKyBxdWVyeTtcbiAgICB9XG4gICAgdXJsID0gam9pblVybHMoYmFzZVVybCwgdXJsKTtcbiAgICBjb25zdCByZXF1ZXN0ID0gbmV3IFJlcXVlc3QodXJsLCBjb25maWcpO1xuICAgIGNvbnN0IHJlcXVlc3RDbG9uZSA9IG5ldyBSZXF1ZXN0KHVybCwgY29uZmlnKTtcbiAgICBtZXRhID0ge1xuICAgICAgcmVxdWVzdDogcmVxdWVzdENsb25lXG4gICAgfTtcbiAgICBsZXQgcmVzcG9uc2UsIHRpbWVkT3V0ID0gZmFsc2UsIHRpbWVvdXRJZCA9IHRpbWVvdXQgJiYgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aW1lZE91dCA9IHRydWU7XG4gICAgICBhcGkuYWJvcnQoKTtcbiAgICB9LCB0aW1lb3V0KTtcbiAgICB0cnkge1xuICAgICAgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaEZuKHJlcXVlc3QpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGVycm9yOiB7XG4gICAgICAgICAgc3RhdHVzOiB0aW1lZE91dCA/IFwiVElNRU9VVF9FUlJPUlwiIDogXCJGRVRDSF9FUlJPUlwiLFxuICAgICAgICAgIGVycm9yOiBTdHJpbmcoZSlcbiAgICAgICAgfSxcbiAgICAgICAgbWV0YVxuICAgICAgfTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKHRpbWVvdXRJZCkgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgfVxuICAgIGNvbnN0IHJlc3BvbnNlQ2xvbmUgPSByZXNwb25zZS5jbG9uZSgpO1xuICAgIG1ldGEucmVzcG9uc2UgPSByZXNwb25zZUNsb25lO1xuICAgIGxldCByZXN1bHREYXRhO1xuICAgIGxldCByZXNwb25zZVRleHQgPSBcIlwiO1xuICAgIHRyeSB7XG4gICAgICBsZXQgaGFuZGxlUmVzcG9uc2VFcnJvcjtcbiAgICAgIGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgaGFuZGxlUmVzcG9uc2UocmVzcG9uc2UsIHJlc3BvbnNlSGFuZGxlcikudGhlbigocikgPT4gcmVzdWx0RGF0YSA9IHIsIChlKSA9PiBoYW5kbGVSZXNwb25zZUVycm9yID0gZSksXG4gICAgICAgIC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vbm9kZS1mZXRjaC9ub2RlLWZldGNoL2lzc3Vlcy82NjUjaXNzdWVjb21tZW50LTUzODk5NTE4MlxuICAgICAgICAvLyB3ZSAqaGF2ZSogdG8gXCJ1c2UgdXBcIiBib3RoIHN0cmVhbXMgYXQgdGhlIHNhbWUgdGltZSBvciB0aGV5IHdpbGwgc3RvcCBydW5uaW5nIGluIG5vZGUtZmV0Y2ggc2NlbmFyaW9zXG4gICAgICAgIHJlc3BvbnNlQ2xvbmUudGV4dCgpLnRoZW4oKHIpID0+IHJlc3BvbnNlVGV4dCA9IHIsICgpID0+IHtcbiAgICAgICAgfSlcbiAgICAgIF0pO1xuICAgICAgaWYgKGhhbmRsZVJlc3BvbnNlRXJyb3IpIHRocm93IGhhbmRsZVJlc3BvbnNlRXJyb3I7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZXJyb3I6IHtcbiAgICAgICAgICBzdGF0dXM6IFwiUEFSU0lOR19FUlJPUlwiLFxuICAgICAgICAgIG9yaWdpbmFsU3RhdHVzOiByZXNwb25zZS5zdGF0dXMsXG4gICAgICAgICAgZGF0YTogcmVzcG9uc2VUZXh0LFxuICAgICAgICAgIGVycm9yOiBTdHJpbmcoZSlcbiAgICAgICAgfSxcbiAgICAgICAgbWV0YVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbGlkYXRlU3RhdHVzKHJlc3BvbnNlLCByZXN1bHREYXRhKSA/IHtcbiAgICAgIGRhdGE6IHJlc3VsdERhdGEsXG4gICAgICBtZXRhXG4gICAgfSA6IHtcbiAgICAgIGVycm9yOiB7XG4gICAgICAgIHN0YXR1czogcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgICBkYXRhOiByZXN1bHREYXRhXG4gICAgICB9LFxuICAgICAgbWV0YVxuICAgIH07XG4gIH07XG4gIGFzeW5jIGZ1bmN0aW9uIGhhbmRsZVJlc3BvbnNlKHJlc3BvbnNlLCByZXNwb25zZUhhbmRsZXIpIHtcbiAgICBpZiAodHlwZW9mIHJlc3BvbnNlSGFuZGxlciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICByZXR1cm4gcmVzcG9uc2VIYW5kbGVyKHJlc3BvbnNlKTtcbiAgICB9XG4gICAgaWYgKHJlc3BvbnNlSGFuZGxlciA9PT0gXCJjb250ZW50LXR5cGVcIikge1xuICAgICAgcmVzcG9uc2VIYW5kbGVyID0gaXNKc29uQ29udGVudFR5cGUocmVzcG9uc2UuaGVhZGVycykgPyBcImpzb25cIiA6IFwidGV4dFwiO1xuICAgIH1cbiAgICBpZiAocmVzcG9uc2VIYW5kbGVyID09PSBcImpzb25cIikge1xuICAgICAgY29uc3QgdGV4dCA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcbiAgICAgIHJldHVybiB0ZXh0Lmxlbmd0aCA/IEpTT04ucGFyc2UodGV4dCkgOiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gcmVzcG9uc2UudGV4dCgpO1xuICB9XG59XG5cbi8vIHNyYy9xdWVyeS9IYW5kbGVkRXJyb3IudHNcbnZhciBIYW5kbGVkRXJyb3IgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHZhbHVlLCBtZXRhID0gdm9pZCAwKSB7XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIHRoaXMubWV0YSA9IG1ldGE7XG4gIH1cbn07XG5cbi8vIHNyYy9xdWVyeS9yZXRyeS50c1xuYXN5bmMgZnVuY3Rpb24gZGVmYXVsdEJhY2tvZmYoYXR0ZW1wdCA9IDAsIG1heFJldHJpZXMgPSA1KSB7XG4gIGNvbnN0IGF0dGVtcHRzID0gTWF0aC5taW4oYXR0ZW1wdCwgbWF4UmV0cmllcyk7XG4gIGNvbnN0IHRpbWVvdXQgPSB+figoTWF0aC5yYW5kb20oKSArIDAuNCkgKiAoMzAwIDw8IGF0dGVtcHRzKSk7XG4gIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KChyZXMpID0+IHJlc29sdmUocmVzKSwgdGltZW91dCkpO1xufVxuZnVuY3Rpb24gZmFpbChlKSB7XG4gIHRocm93IE9iamVjdC5hc3NpZ24obmV3IEhhbmRsZWRFcnJvcih7XG4gICAgZXJyb3I6IGVcbiAgfSksIHtcbiAgICB0aHJvd0ltbWVkaWF0ZWx5OiB0cnVlXG4gIH0pO1xufVxudmFyIEVNUFRZX09QVElPTlMgPSB7fTtcbnZhciByZXRyeVdpdGhCYWNrb2ZmID0gKGJhc2VRdWVyeSwgZGVmYXVsdE9wdGlvbnMpID0+IGFzeW5jIChhcmdzLCBhcGksIGV4dHJhT3B0aW9ucykgPT4ge1xuICBjb25zdCBwb3NzaWJsZU1heFJldHJpZXMgPSBbNSwgKGRlZmF1bHRPcHRpb25zIHx8IEVNUFRZX09QVElPTlMpLm1heFJldHJpZXMsIChleHRyYU9wdGlvbnMgfHwgRU1QVFlfT1BUSU9OUykubWF4UmV0cmllc10uZmlsdGVyKCh4KSA9PiB4ICE9PSB2b2lkIDApO1xuICBjb25zdCBbbWF4UmV0cmllc10gPSBwb3NzaWJsZU1heFJldHJpZXMuc2xpY2UoLTEpO1xuICBjb25zdCBkZWZhdWx0UmV0cnlDb25kaXRpb24gPSAoXywgX18sIHtcbiAgICBhdHRlbXB0XG4gIH0pID0+IGF0dGVtcHQgPD0gbWF4UmV0cmllcztcbiAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICBtYXhSZXRyaWVzLFxuICAgIGJhY2tvZmY6IGRlZmF1bHRCYWNrb2ZmLFxuICAgIHJldHJ5Q29uZGl0aW9uOiBkZWZhdWx0UmV0cnlDb25kaXRpb24sXG4gICAgLi4uZGVmYXVsdE9wdGlvbnMsXG4gICAgLi4uZXh0cmFPcHRpb25zXG4gIH07XG4gIGxldCByZXRyeTIgPSAwO1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBiYXNlUXVlcnkoYXJncywgYXBpLCBleHRyYU9wdGlvbnMpO1xuICAgICAgaWYgKHJlc3VsdC5lcnJvcikge1xuICAgICAgICB0aHJvdyBuZXcgSGFuZGxlZEVycm9yKHJlc3VsdCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHJ5MisrO1xuICAgICAgaWYgKGUudGhyb3dJbW1lZGlhdGVseSkge1xuICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIEhhbmRsZWRFcnJvcikge1xuICAgICAgICAgIHJldHVybiBlLnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgICBpZiAoZSBpbnN0YW5jZW9mIEhhbmRsZWRFcnJvciAmJiAhb3B0aW9ucy5yZXRyeUNvbmRpdGlvbihlLnZhbHVlLmVycm9yLCBhcmdzLCB7XG4gICAgICAgIGF0dGVtcHQ6IHJldHJ5MixcbiAgICAgICAgYmFzZVF1ZXJ5QXBpOiBhcGksXG4gICAgICAgIGV4dHJhT3B0aW9uc1xuICAgICAgfSkpIHtcbiAgICAgICAgcmV0dXJuIGUudmFsdWU7XG4gICAgICB9XG4gICAgICBhd2FpdCBvcHRpb25zLmJhY2tvZmYocmV0cnkyLCBvcHRpb25zLm1heFJldHJpZXMpO1xuICAgIH1cbiAgfVxufTtcbnZhciByZXRyeSA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuYXNzaWduKHJldHJ5V2l0aEJhY2tvZmYsIHtcbiAgZmFpbFxufSk7XG5cbi8vIHNyYy9xdWVyeS9jb3JlL3NldHVwTGlzdGVuZXJzLnRzXG52YXIgb25Gb2N1cyA9IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVBY3Rpb24oXCJfX3J0a3EvZm9jdXNlZFwiKTtcbnZhciBvbkZvY3VzTG9zdCA9IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVBY3Rpb24oXCJfX3J0a3EvdW5mb2N1c2VkXCIpO1xudmFyIG9uT25saW5lID0gLyogQF9fUFVSRV9fICovIGNyZWF0ZUFjdGlvbihcIl9fcnRrcS9vbmxpbmVcIik7XG52YXIgb25PZmZsaW5lID0gLyogQF9fUFVSRV9fICovIGNyZWF0ZUFjdGlvbihcIl9fcnRrcS9vZmZsaW5lXCIpO1xudmFyIGluaXRpYWxpemVkID0gZmFsc2U7XG5mdW5jdGlvbiBzZXR1cExpc3RlbmVycyhkaXNwYXRjaCwgY3VzdG9tSGFuZGxlcikge1xuICBmdW5jdGlvbiBkZWZhdWx0SGFuZGxlcigpIHtcbiAgICBjb25zdCBoYW5kbGVGb2N1cyA9ICgpID0+IGRpc3BhdGNoKG9uRm9jdXMoKSk7XG4gICAgY29uc3QgaGFuZGxlRm9jdXNMb3N0ID0gKCkgPT4gZGlzcGF0Y2gob25Gb2N1c0xvc3QoKSk7XG4gICAgY29uc3QgaGFuZGxlT25saW5lID0gKCkgPT4gZGlzcGF0Y2gob25PbmxpbmUoKSk7XG4gICAgY29uc3QgaGFuZGxlT2ZmbGluZSA9ICgpID0+IGRpc3BhdGNoKG9uT2ZmbGluZSgpKTtcbiAgICBjb25zdCBoYW5kbGVWaXNpYmlsaXR5Q2hhbmdlID0gKCkgPT4ge1xuICAgICAgaWYgKHdpbmRvdy5kb2N1bWVudC52aXNpYmlsaXR5U3RhdGUgPT09IFwidmlzaWJsZVwiKSB7XG4gICAgICAgIGhhbmRsZUZvY3VzKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBoYW5kbGVGb2N1c0xvc3QoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGlmICghaW5pdGlhbGl6ZWQpIHtcbiAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwidmlzaWJpbGl0eWNoYW5nZVwiLCBoYW5kbGVWaXNpYmlsaXR5Q2hhbmdlLCBmYWxzZSk7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNcIiwgaGFuZGxlRm9jdXMsIGZhbHNlKTtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJvbmxpbmVcIiwgaGFuZGxlT25saW5lLCBmYWxzZSk7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwib2ZmbGluZVwiLCBoYW5kbGVPZmZsaW5lLCBmYWxzZSk7XG4gICAgICAgIGluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgdW5zdWJzY3JpYmUgPSAoKSA9PiB7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImZvY3VzXCIsIGhhbmRsZUZvY3VzKTtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwidmlzaWJpbGl0eWNoYW5nZVwiLCBoYW5kbGVWaXNpYmlsaXR5Q2hhbmdlKTtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwib25saW5lXCIsIGhhbmRsZU9ubGluZSk7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm9mZmxpbmVcIiwgaGFuZGxlT2ZmbGluZSk7XG4gICAgICBpbml0aWFsaXplZCA9IGZhbHNlO1xuICAgIH07XG4gICAgcmV0dXJuIHVuc3Vic2NyaWJlO1xuICB9XG4gIHJldHVybiBjdXN0b21IYW5kbGVyID8gY3VzdG9tSGFuZGxlcihkaXNwYXRjaCwge1xuICAgIG9uRm9jdXMsXG4gICAgb25Gb2N1c0xvc3QsXG4gICAgb25PZmZsaW5lLFxuICAgIG9uT25saW5lXG4gIH0pIDogZGVmYXVsdEhhbmRsZXIoKTtcbn1cblxuLy8gc3JjL3F1ZXJ5L2VuZHBvaW50RGVmaW5pdGlvbnMudHNcbmZ1bmN0aW9uIGlzUXVlcnlEZWZpbml0aW9uKGUpIHtcbiAgcmV0dXJuIGUudHlwZSA9PT0gXCJxdWVyeVwiIC8qIHF1ZXJ5ICovO1xufVxuZnVuY3Rpb24gaXNNdXRhdGlvbkRlZmluaXRpb24oZSkge1xuICByZXR1cm4gZS50eXBlID09PSBcIm11dGF0aW9uXCIgLyogbXV0YXRpb24gKi87XG59XG5mdW5jdGlvbiBjYWxjdWxhdGVQcm92aWRlZEJ5KGRlc2NyaXB0aW9uLCByZXN1bHQsIGVycm9yLCBxdWVyeUFyZywgbWV0YSwgYXNzZXJ0VGFnVHlwZXMpIHtcbiAgaWYgKGlzRnVuY3Rpb24oZGVzY3JpcHRpb24pKSB7XG4gICAgcmV0dXJuIGRlc2NyaXB0aW9uKHJlc3VsdCwgZXJyb3IsIHF1ZXJ5QXJnLCBtZXRhKS5tYXAoZXhwYW5kVGFnRGVzY3JpcHRpb24pLm1hcChhc3NlcnRUYWdUeXBlcyk7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkoZGVzY3JpcHRpb24pKSB7XG4gICAgcmV0dXJuIGRlc2NyaXB0aW9uLm1hcChleHBhbmRUYWdEZXNjcmlwdGlvbikubWFwKGFzc2VydFRhZ1R5cGVzKTtcbiAgfVxuICByZXR1cm4gW107XG59XG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHQpIHtcbiAgcmV0dXJuIHR5cGVvZiB0ID09PSBcImZ1bmN0aW9uXCI7XG59XG5mdW5jdGlvbiBleHBhbmRUYWdEZXNjcmlwdGlvbihkZXNjcmlwdGlvbikge1xuICByZXR1cm4gdHlwZW9mIGRlc2NyaXB0aW9uID09PSBcInN0cmluZ1wiID8ge1xuICAgIHR5cGU6IGRlc2NyaXB0aW9uXG4gIH0gOiBkZXNjcmlwdGlvbjtcbn1cblxuLy8gc3JjL3F1ZXJ5L2NvcmUvYnVpbGRUaHVua3MudHNcbmltcG9ydCB7IGlzRHJhZnRhYmxlLCBwcm9kdWNlV2l0aFBhdGNoZXMgfSBmcm9tIFwiaW1tZXJcIjtcblxuLy8gc3JjL3F1ZXJ5L2NvcmUvYnVpbGRJbml0aWF0ZS50c1xuaW1wb3J0IHsgZm9ybWF0UHJvZEVycm9yTWVzc2FnZSBhcyBfZm9ybWF0UHJvZEVycm9yTWVzc2FnZSB9IGZyb20gXCJAcmVkdXhqcy90b29sa2l0XCI7XG5cbi8vIHNyYy90c0hlbHBlcnMudHNcbmZ1bmN0aW9uIGFzU2FmZVByb21pc2UocHJvbWlzZSwgZmFsbGJhY2spIHtcbiAgcmV0dXJuIHByb21pc2UuY2F0Y2goZmFsbGJhY2spO1xufVxuXG4vLyBzcmMvcXVlcnkvY29yZS9idWlsZEluaXRpYXRlLnRzXG52YXIgZm9yY2VRdWVyeUZuU3ltYm9sID0gU3ltYm9sKFwiZm9yY2VRdWVyeUZuXCIpO1xudmFyIGlzVXBzZXJ0UXVlcnkgPSAoYXJnKSA9PiB0eXBlb2YgYXJnW2ZvcmNlUXVlcnlGblN5bWJvbF0gPT09IFwiZnVuY3Rpb25cIjtcbmZ1bmN0aW9uIGJ1aWxkSW5pdGlhdGUoe1xuICBzZXJpYWxpemVRdWVyeUFyZ3MsXG4gIHF1ZXJ5VGh1bmssXG4gIG11dGF0aW9uVGh1bmssXG4gIGFwaSxcbiAgY29udGV4dFxufSkge1xuICBjb25zdCBydW5uaW5nUXVlcmllcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGNvbnN0IHJ1bm5pbmdNdXRhdGlvbnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBjb25zdCB7XG4gICAgdW5zdWJzY3JpYmVRdWVyeVJlc3VsdCxcbiAgICByZW1vdmVNdXRhdGlvblJlc3VsdCxcbiAgICB1cGRhdGVTdWJzY3JpcHRpb25PcHRpb25zXG4gIH0gPSBhcGkuaW50ZXJuYWxBY3Rpb25zO1xuICByZXR1cm4ge1xuICAgIGJ1aWxkSW5pdGlhdGVRdWVyeSxcbiAgICBidWlsZEluaXRpYXRlTXV0YXRpb24sXG4gICAgZ2V0UnVubmluZ1F1ZXJ5VGh1bmssXG4gICAgZ2V0UnVubmluZ011dGF0aW9uVGh1bmssXG4gICAgZ2V0UnVubmluZ1F1ZXJpZXNUaHVuayxcbiAgICBnZXRSdW5uaW5nTXV0YXRpb25zVGh1bmtcbiAgfTtcbiAgZnVuY3Rpb24gZ2V0UnVubmluZ1F1ZXJ5VGh1bmsoZW5kcG9pbnROYW1lLCBxdWVyeUFyZ3MpIHtcbiAgICByZXR1cm4gKGRpc3BhdGNoKSA9PiB7XG4gICAgICBjb25zdCBlbmRwb2ludERlZmluaXRpb24gPSBjb250ZXh0LmVuZHBvaW50RGVmaW5pdGlvbnNbZW5kcG9pbnROYW1lXTtcbiAgICAgIGNvbnN0IHF1ZXJ5Q2FjaGVLZXkgPSBzZXJpYWxpemVRdWVyeUFyZ3Moe1xuICAgICAgICBxdWVyeUFyZ3MsXG4gICAgICAgIGVuZHBvaW50RGVmaW5pdGlvbixcbiAgICAgICAgZW5kcG9pbnROYW1lXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBydW5uaW5nUXVlcmllcy5nZXQoZGlzcGF0Y2gpPy5bcXVlcnlDYWNoZUtleV07XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBnZXRSdW5uaW5nTXV0YXRpb25UaHVuayhfZW5kcG9pbnROYW1lLCBmaXhlZENhY2hlS2V5T3JSZXF1ZXN0SWQpIHtcbiAgICByZXR1cm4gKGRpc3BhdGNoKSA9PiB7XG4gICAgICByZXR1cm4gcnVubmluZ011dGF0aW9ucy5nZXQoZGlzcGF0Y2gpPy5bZml4ZWRDYWNoZUtleU9yUmVxdWVzdElkXTtcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIGdldFJ1bm5pbmdRdWVyaWVzVGh1bmsoKSB7XG4gICAgcmV0dXJuIChkaXNwYXRjaCkgPT4gT2JqZWN0LnZhbHVlcyhydW5uaW5nUXVlcmllcy5nZXQoZGlzcGF0Y2gpIHx8IHt9KS5maWx0ZXIoaXNOb3ROdWxsaXNoKTtcbiAgfVxuICBmdW5jdGlvbiBnZXRSdW5uaW5nTXV0YXRpb25zVGh1bmsoKSB7XG4gICAgcmV0dXJuIChkaXNwYXRjaCkgPT4gT2JqZWN0LnZhbHVlcyhydW5uaW5nTXV0YXRpb25zLmdldChkaXNwYXRjaCkgfHwge30pLmZpbHRlcihpc05vdE51bGxpc2gpO1xuICB9XG4gIGZ1bmN0aW9uIG1pZGRsZXdhcmVXYXJuaW5nKGRpc3BhdGNoKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgaWYgKG1pZGRsZXdhcmVXYXJuaW5nLnRyaWdnZXJlZCkgcmV0dXJuO1xuICAgICAgY29uc3QgcmV0dXJuZWRWYWx1ZSA9IGRpc3BhdGNoKGFwaS5pbnRlcm5hbEFjdGlvbnMuaW50ZXJuYWxfZ2V0UlRLUVN1YnNjcmlwdGlvbnMoKSk7XG4gICAgICBtaWRkbGV3YXJlV2FybmluZy50cmlnZ2VyZWQgPSB0cnVlO1xuICAgICAgaWYgKHR5cGVvZiByZXR1cm5lZFZhbHVlICE9PSBcIm9iamVjdFwiIHx8IHR5cGVvZiByZXR1cm5lZFZhbHVlPy50eXBlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBfZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgzNCkgOiBgV2FybmluZzogTWlkZGxld2FyZSBmb3IgUlRLLVF1ZXJ5IEFQSSBhdCByZWR1Y2VyUGF0aCBcIiR7YXBpLnJlZHVjZXJQYXRofVwiIGhhcyBub3QgYmVlbiBhZGRlZCB0byB0aGUgc3RvcmUuXG5Zb3UgbXVzdCBhZGQgdGhlIG1pZGRsZXdhcmUgZm9yIFJUSy1RdWVyeSB0byBmdW5jdGlvbiBjb3JyZWN0bHkhYCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGJ1aWxkSW5pdGlhdGVRdWVyeShlbmRwb2ludE5hbWUsIGVuZHBvaW50RGVmaW5pdGlvbikge1xuICAgIGNvbnN0IHF1ZXJ5QWN0aW9uID0gKGFyZywge1xuICAgICAgc3Vic2NyaWJlID0gdHJ1ZSxcbiAgICAgIGZvcmNlUmVmZXRjaCxcbiAgICAgIHN1YnNjcmlwdGlvbk9wdGlvbnMsXG4gICAgICBbZm9yY2VRdWVyeUZuU3ltYm9sXTogZm9yY2VRdWVyeUZuLFxuICAgICAgLi4ucmVzdFxuICAgIH0gPSB7fSkgPT4gKGRpc3BhdGNoLCBnZXRTdGF0ZSkgPT4ge1xuICAgICAgY29uc3QgcXVlcnlDYWNoZUtleSA9IHNlcmlhbGl6ZVF1ZXJ5QXJncyh7XG4gICAgICAgIHF1ZXJ5QXJnczogYXJnLFxuICAgICAgICBlbmRwb2ludERlZmluaXRpb24sXG4gICAgICAgIGVuZHBvaW50TmFtZVxuICAgICAgfSk7XG4gICAgICBjb25zdCB0aHVuayA9IHF1ZXJ5VGh1bmsoe1xuICAgICAgICAuLi5yZXN0LFxuICAgICAgICB0eXBlOiBcInF1ZXJ5XCIsXG4gICAgICAgIHN1YnNjcmliZSxcbiAgICAgICAgZm9yY2VSZWZldGNoLFxuICAgICAgICBzdWJzY3JpcHRpb25PcHRpb25zLFxuICAgICAgICBlbmRwb2ludE5hbWUsXG4gICAgICAgIG9yaWdpbmFsQXJnczogYXJnLFxuICAgICAgICBxdWVyeUNhY2hlS2V5LFxuICAgICAgICBbZm9yY2VRdWVyeUZuU3ltYm9sXTogZm9yY2VRdWVyeUZuXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHNlbGVjdG9yID0gYXBpLmVuZHBvaW50c1tlbmRwb2ludE5hbWVdLnNlbGVjdChhcmcpO1xuICAgICAgY29uc3QgdGh1bmtSZXN1bHQgPSBkaXNwYXRjaCh0aHVuayk7XG4gICAgICBjb25zdCBzdGF0ZUFmdGVyID0gc2VsZWN0b3IoZ2V0U3RhdGUoKSk7XG4gICAgICBtaWRkbGV3YXJlV2FybmluZyhkaXNwYXRjaCk7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHJlcXVlc3RJZCxcbiAgICAgICAgYWJvcnRcbiAgICAgIH0gPSB0aHVua1Jlc3VsdDtcbiAgICAgIGNvbnN0IHNraXBwZWRTeW5jaHJvbm91c2x5ID0gc3RhdGVBZnRlci5yZXF1ZXN0SWQgIT09IHJlcXVlc3RJZDtcbiAgICAgIGNvbnN0IHJ1bm5pbmdRdWVyeSA9IHJ1bm5pbmdRdWVyaWVzLmdldChkaXNwYXRjaCk/LltxdWVyeUNhY2hlS2V5XTtcbiAgICAgIGNvbnN0IHNlbGVjdEZyb21TdGF0ZSA9ICgpID0+IHNlbGVjdG9yKGdldFN0YXRlKCkpO1xuICAgICAgY29uc3Qgc3RhdGVQcm9taXNlID0gT2JqZWN0LmFzc2lnbihmb3JjZVF1ZXJ5Rm4gPyAoXG4gICAgICAgIC8vIGEgcXVlcnkgaGFzIGJlZW4gZm9yY2VkICh1cHNlcnRRdWVyeURhdGEpXG4gICAgICAgIC8vIC0+IHdlIHdhbnQgdG8gcmVzb2x2ZSBpdCBvbmNlIGRhdGEgaGFzIGJlZW4gd3JpdHRlbiB3aXRoIHRoZSBkYXRhIHRoYXQgd2lsbCBiZSB3cml0dGVuXG4gICAgICAgIHRodW5rUmVzdWx0LnRoZW4oc2VsZWN0RnJvbVN0YXRlKVxuICAgICAgKSA6IHNraXBwZWRTeW5jaHJvbm91c2x5ICYmICFydW5uaW5nUXVlcnkgPyAoXG4gICAgICAgIC8vIGEgcXVlcnkgaGFzIGJlZW4gc2tpcHBlZCBkdWUgdG8gYSBjb25kaXRpb24gYW5kIHdlIGRvIG5vdCBoYXZlIGFueSBjdXJyZW50bHkgcnVubmluZyBxdWVyeVxuICAgICAgICAvLyAtPiB3ZSB3YW50IHRvIHJlc29sdmUgaXQgaW1tZWRpYXRlbHkgd2l0aCB0aGUgY3VycmVudCBkYXRhXG4gICAgICAgIFByb21pc2UucmVzb2x2ZShzdGF0ZUFmdGVyKVxuICAgICAgKSA6IChcbiAgICAgICAgLy8gcXVlcnkganVzdCBzdGFydGVkIG9yIG9uZSBpcyBhbHJlYWR5IGluIGZsaWdodFxuICAgICAgICAvLyAtPiB3YWl0IGZvciB0aGUgcnVubmluZyBxdWVyeSwgdGhlbiByZXNvbHZlIHdpdGggZGF0YSBmcm9tIGFmdGVyIHRoYXRcbiAgICAgICAgUHJvbWlzZS5hbGwoW3J1bm5pbmdRdWVyeSwgdGh1bmtSZXN1bHRdKS50aGVuKHNlbGVjdEZyb21TdGF0ZSlcbiAgICAgICksIHtcbiAgICAgICAgYXJnLFxuICAgICAgICByZXF1ZXN0SWQsXG4gICAgICAgIHN1YnNjcmlwdGlvbk9wdGlvbnMsXG4gICAgICAgIHF1ZXJ5Q2FjaGVLZXksXG4gICAgICAgIGFib3J0LFxuICAgICAgICBhc3luYyB1bndyYXAoKSB7XG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc3RhdGVQcm9taXNlO1xuICAgICAgICAgIGlmIChyZXN1bHQuaXNFcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgcmVzdWx0LmVycm9yO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0LmRhdGE7XG4gICAgICAgIH0sXG4gICAgICAgIHJlZmV0Y2g6ICgpID0+IGRpc3BhdGNoKHF1ZXJ5QWN0aW9uKGFyZywge1xuICAgICAgICAgIHN1YnNjcmliZTogZmFsc2UsXG4gICAgICAgICAgZm9yY2VSZWZldGNoOiB0cnVlXG4gICAgICAgIH0pKSxcbiAgICAgICAgdW5zdWJzY3JpYmUoKSB7XG4gICAgICAgICAgaWYgKHN1YnNjcmliZSkgZGlzcGF0Y2godW5zdWJzY3JpYmVRdWVyeVJlc3VsdCh7XG4gICAgICAgICAgICBxdWVyeUNhY2hlS2V5LFxuICAgICAgICAgICAgcmVxdWVzdElkXG4gICAgICAgICAgfSkpO1xuICAgICAgICB9LFxuICAgICAgICB1cGRhdGVTdWJzY3JpcHRpb25PcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgICAgICBzdGF0ZVByb21pc2Uuc3Vic2NyaXB0aW9uT3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgICAgZGlzcGF0Y2godXBkYXRlU3Vic2NyaXB0aW9uT3B0aW9ucyh7XG4gICAgICAgICAgICBlbmRwb2ludE5hbWUsXG4gICAgICAgICAgICByZXF1ZXN0SWQsXG4gICAgICAgICAgICBxdWVyeUNhY2hlS2V5LFxuICAgICAgICAgICAgb3B0aW9uc1xuICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpZiAoIXJ1bm5pbmdRdWVyeSAmJiAhc2tpcHBlZFN5bmNocm9ub3VzbHkgJiYgIWZvcmNlUXVlcnlGbikge1xuICAgICAgICBjb25zdCBydW5uaW5nID0gcnVubmluZ1F1ZXJpZXMuZ2V0KGRpc3BhdGNoKSB8fCB7fTtcbiAgICAgICAgcnVubmluZ1txdWVyeUNhY2hlS2V5XSA9IHN0YXRlUHJvbWlzZTtcbiAgICAgICAgcnVubmluZ1F1ZXJpZXMuc2V0KGRpc3BhdGNoLCBydW5uaW5nKTtcbiAgICAgICAgc3RhdGVQcm9taXNlLnRoZW4oKCkgPT4ge1xuICAgICAgICAgIGRlbGV0ZSBydW5uaW5nW3F1ZXJ5Q2FjaGVLZXldO1xuICAgICAgICAgIGlmICghY291bnRPYmplY3RLZXlzKHJ1bm5pbmcpKSB7XG4gICAgICAgICAgICBydW5uaW5nUXVlcmllcy5kZWxldGUoZGlzcGF0Y2gpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc3RhdGVQcm9taXNlO1xuICAgIH07XG4gICAgcmV0dXJuIHF1ZXJ5QWN0aW9uO1xuICB9XG4gIGZ1bmN0aW9uIGJ1aWxkSW5pdGlhdGVNdXRhdGlvbihlbmRwb2ludE5hbWUpIHtcbiAgICByZXR1cm4gKGFyZywge1xuICAgICAgdHJhY2sgPSB0cnVlLFxuICAgICAgZml4ZWRDYWNoZUtleVxuICAgIH0gPSB7fSkgPT4gKGRpc3BhdGNoLCBnZXRTdGF0ZSkgPT4ge1xuICAgICAgY29uc3QgdGh1bmsgPSBtdXRhdGlvblRodW5rKHtcbiAgICAgICAgdHlwZTogXCJtdXRhdGlvblwiLFxuICAgICAgICBlbmRwb2ludE5hbWUsXG4gICAgICAgIG9yaWdpbmFsQXJnczogYXJnLFxuICAgICAgICB0cmFjayxcbiAgICAgICAgZml4ZWRDYWNoZUtleVxuICAgICAgfSk7XG4gICAgICBjb25zdCB0aHVua1Jlc3VsdCA9IGRpc3BhdGNoKHRodW5rKTtcbiAgICAgIG1pZGRsZXdhcmVXYXJuaW5nKGRpc3BhdGNoKTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcmVxdWVzdElkLFxuICAgICAgICBhYm9ydCxcbiAgICAgICAgdW53cmFwXG4gICAgICB9ID0gdGh1bmtSZXN1bHQ7XG4gICAgICBjb25zdCByZXR1cm5WYWx1ZVByb21pc2UgPSBhc1NhZmVQcm9taXNlKHRodW5rUmVzdWx0LnVud3JhcCgpLnRoZW4oKGRhdGEpID0+ICh7XG4gICAgICAgIGRhdGFcbiAgICAgIH0pKSwgKGVycm9yKSA9PiAoe1xuICAgICAgICBlcnJvclxuICAgICAgfSkpO1xuICAgICAgY29uc3QgcmVzZXQgPSAoKSA9PiB7XG4gICAgICAgIGRpc3BhdGNoKHJlbW92ZU11dGF0aW9uUmVzdWx0KHtcbiAgICAgICAgICByZXF1ZXN0SWQsXG4gICAgICAgICAgZml4ZWRDYWNoZUtleVxuICAgICAgICB9KSk7XG4gICAgICB9O1xuICAgICAgY29uc3QgcmV0ID0gT2JqZWN0LmFzc2lnbihyZXR1cm5WYWx1ZVByb21pc2UsIHtcbiAgICAgICAgYXJnOiB0aHVua1Jlc3VsdC5hcmcsXG4gICAgICAgIHJlcXVlc3RJZCxcbiAgICAgICAgYWJvcnQsXG4gICAgICAgIHVud3JhcCxcbiAgICAgICAgcmVzZXRcbiAgICAgIH0pO1xuICAgICAgY29uc3QgcnVubmluZyA9IHJ1bm5pbmdNdXRhdGlvbnMuZ2V0KGRpc3BhdGNoKSB8fCB7fTtcbiAgICAgIHJ1bm5pbmdNdXRhdGlvbnMuc2V0KGRpc3BhdGNoLCBydW5uaW5nKTtcbiAgICAgIHJ1bm5pbmdbcmVxdWVzdElkXSA9IHJldDtcbiAgICAgIHJldC50aGVuKCgpID0+IHtcbiAgICAgICAgZGVsZXRlIHJ1bm5pbmdbcmVxdWVzdElkXTtcbiAgICAgICAgaWYgKCFjb3VudE9iamVjdEtleXMocnVubmluZykpIHtcbiAgICAgICAgICBydW5uaW5nTXV0YXRpb25zLmRlbGV0ZShkaXNwYXRjaCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaWYgKGZpeGVkQ2FjaGVLZXkpIHtcbiAgICAgICAgcnVubmluZ1tmaXhlZENhY2hlS2V5XSA9IHJldDtcbiAgICAgICAgcmV0LnRoZW4oKCkgPT4ge1xuICAgICAgICAgIGlmIChydW5uaW5nW2ZpeGVkQ2FjaGVLZXldID09PSByZXQpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBydW5uaW5nW2ZpeGVkQ2FjaGVLZXldO1xuICAgICAgICAgICAgaWYgKCFjb3VudE9iamVjdEtleXMocnVubmluZykpIHtcbiAgICAgICAgICAgICAgcnVubmluZ011dGF0aW9ucy5kZWxldGUoZGlzcGF0Y2gpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH07XG4gIH1cbn1cblxuLy8gc3JjL3F1ZXJ5L2NvcmUvYnVpbGRUaHVua3MudHNcbmZ1bmN0aW9uIGRlZmF1bHRUcmFuc2Zvcm1SZXNwb25zZShiYXNlUXVlcnlSZXR1cm5WYWx1ZSkge1xuICByZXR1cm4gYmFzZVF1ZXJ5UmV0dXJuVmFsdWU7XG59XG5mdW5jdGlvbiBidWlsZFRodW5rcyh7XG4gIHJlZHVjZXJQYXRoLFxuICBiYXNlUXVlcnksXG4gIGNvbnRleHQ6IHtcbiAgICBlbmRwb2ludERlZmluaXRpb25zXG4gIH0sXG4gIHNlcmlhbGl6ZVF1ZXJ5QXJncyxcbiAgYXBpLFxuICBhc3NlcnRUYWdUeXBlXG59KSB7XG4gIGNvbnN0IHBhdGNoUXVlcnlEYXRhID0gKGVuZHBvaW50TmFtZSwgYXJncywgcGF0Y2hlcywgdXBkYXRlUHJvdmlkZWQpID0+IChkaXNwYXRjaCwgZ2V0U3RhdGUpID0+IHtcbiAgICBjb25zdCBlbmRwb2ludERlZmluaXRpb24gPSBlbmRwb2ludERlZmluaXRpb25zW2VuZHBvaW50TmFtZV07XG4gICAgY29uc3QgcXVlcnlDYWNoZUtleSA9IHNlcmlhbGl6ZVF1ZXJ5QXJncyh7XG4gICAgICBxdWVyeUFyZ3M6IGFyZ3MsXG4gICAgICBlbmRwb2ludERlZmluaXRpb24sXG4gICAgICBlbmRwb2ludE5hbWVcbiAgICB9KTtcbiAgICBkaXNwYXRjaChhcGkuaW50ZXJuYWxBY3Rpb25zLnF1ZXJ5UmVzdWx0UGF0Y2hlZCh7XG4gICAgICBxdWVyeUNhY2hlS2V5LFxuICAgICAgcGF0Y2hlc1xuICAgIH0pKTtcbiAgICBpZiAoIXVwZGF0ZVByb3ZpZGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG5ld1ZhbHVlID0gYXBpLmVuZHBvaW50c1tlbmRwb2ludE5hbWVdLnNlbGVjdChhcmdzKShcbiAgICAgIC8vIFdvcmsgYXJvdW5kIFRTIDQuMSBtaXNtYXRjaFxuICAgICAgZ2V0U3RhdGUoKVxuICAgICk7XG4gICAgY29uc3QgcHJvdmlkZWRUYWdzID0gY2FsY3VsYXRlUHJvdmlkZWRCeShlbmRwb2ludERlZmluaXRpb24ucHJvdmlkZXNUYWdzLCBuZXdWYWx1ZS5kYXRhLCB2b2lkIDAsIGFyZ3MsIHt9LCBhc3NlcnRUYWdUeXBlKTtcbiAgICBkaXNwYXRjaChhcGkuaW50ZXJuYWxBY3Rpb25zLnVwZGF0ZVByb3ZpZGVkQnkoe1xuICAgICAgcXVlcnlDYWNoZUtleSxcbiAgICAgIHByb3ZpZGVkVGFnc1xuICAgIH0pKTtcbiAgfTtcbiAgY29uc3QgdXBkYXRlUXVlcnlEYXRhID0gKGVuZHBvaW50TmFtZSwgYXJncywgdXBkYXRlUmVjaXBlLCB1cGRhdGVQcm92aWRlZCA9IHRydWUpID0+IChkaXNwYXRjaCwgZ2V0U3RhdGUpID0+IHtcbiAgICBjb25zdCBlbmRwb2ludERlZmluaXRpb24gPSBhcGkuZW5kcG9pbnRzW2VuZHBvaW50TmFtZV07XG4gICAgY29uc3QgY3VycmVudFN0YXRlID0gZW5kcG9pbnREZWZpbml0aW9uLnNlbGVjdChhcmdzKShcbiAgICAgIC8vIFdvcmsgYXJvdW5kIFRTIDQuMSBtaXNtYXRjaFxuICAgICAgZ2V0U3RhdGUoKVxuICAgICk7XG4gICAgY29uc3QgcmV0ID0ge1xuICAgICAgcGF0Y2hlczogW10sXG4gICAgICBpbnZlcnNlUGF0Y2hlczogW10sXG4gICAgICB1bmRvOiAoKSA9PiBkaXNwYXRjaChhcGkudXRpbC5wYXRjaFF1ZXJ5RGF0YShlbmRwb2ludE5hbWUsIGFyZ3MsIHJldC5pbnZlcnNlUGF0Y2hlcywgdXBkYXRlUHJvdmlkZWQpKVxuICAgIH07XG4gICAgaWYgKGN1cnJlbnRTdGF0ZS5zdGF0dXMgPT09IFwidW5pbml0aWFsaXplZFwiIC8qIHVuaW5pdGlhbGl6ZWQgKi8pIHtcbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIGxldCBuZXdWYWx1ZTtcbiAgICBpZiAoXCJkYXRhXCIgaW4gY3VycmVudFN0YXRlKSB7XG4gICAgICBpZiAoaXNEcmFmdGFibGUoY3VycmVudFN0YXRlLmRhdGEpKSB7XG4gICAgICAgIGNvbnN0IFt2YWx1ZSwgcGF0Y2hlcywgaW52ZXJzZVBhdGNoZXNdID0gcHJvZHVjZVdpdGhQYXRjaGVzKGN1cnJlbnRTdGF0ZS5kYXRhLCB1cGRhdGVSZWNpcGUpO1xuICAgICAgICByZXQucGF0Y2hlcy5wdXNoKC4uLnBhdGNoZXMpO1xuICAgICAgICByZXQuaW52ZXJzZVBhdGNoZXMucHVzaCguLi5pbnZlcnNlUGF0Y2hlcyk7XG4gICAgICAgIG5ld1ZhbHVlID0gdmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXdWYWx1ZSA9IHVwZGF0ZVJlY2lwZShjdXJyZW50U3RhdGUuZGF0YSk7XG4gICAgICAgIHJldC5wYXRjaGVzLnB1c2goe1xuICAgICAgICAgIG9wOiBcInJlcGxhY2VcIixcbiAgICAgICAgICBwYXRoOiBbXSxcbiAgICAgICAgICB2YWx1ZTogbmV3VmFsdWVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldC5pbnZlcnNlUGF0Y2hlcy5wdXNoKHtcbiAgICAgICAgICBvcDogXCJyZXBsYWNlXCIsXG4gICAgICAgICAgcGF0aDogW10sXG4gICAgICAgICAgdmFsdWU6IGN1cnJlbnRTdGF0ZS5kYXRhXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocmV0LnBhdGNoZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICBkaXNwYXRjaChhcGkudXRpbC5wYXRjaFF1ZXJ5RGF0YShlbmRwb2ludE5hbWUsIGFyZ3MsIHJldC5wYXRjaGVzLCB1cGRhdGVQcm92aWRlZCkpO1xuICAgIHJldHVybiByZXQ7XG4gIH07XG4gIGNvbnN0IHVwc2VydFF1ZXJ5RGF0YSA9IChlbmRwb2ludE5hbWUsIGFyZ3MsIHZhbHVlKSA9PiAoZGlzcGF0Y2gpID0+IHtcbiAgICByZXR1cm4gZGlzcGF0Y2goYXBpLmVuZHBvaW50c1tlbmRwb2ludE5hbWVdLmluaXRpYXRlKGFyZ3MsIHtcbiAgICAgIHN1YnNjcmliZTogZmFsc2UsXG4gICAgICBmb3JjZVJlZmV0Y2g6IHRydWUsXG4gICAgICBbZm9yY2VRdWVyeUZuU3ltYm9sXTogKCkgPT4gKHtcbiAgICAgICAgZGF0YTogdmFsdWVcbiAgICAgIH0pXG4gICAgfSkpO1xuICB9O1xuICBjb25zdCBleGVjdXRlRW5kcG9pbnQgPSBhc3luYyAoYXJnLCB7XG4gICAgc2lnbmFsLFxuICAgIGFib3J0LFxuICAgIHJlamVjdFdpdGhWYWx1ZSxcbiAgICBmdWxmaWxsV2l0aFZhbHVlLFxuICAgIGRpc3BhdGNoLFxuICAgIGdldFN0YXRlLFxuICAgIGV4dHJhXG4gIH0pID0+IHtcbiAgICBjb25zdCBlbmRwb2ludERlZmluaXRpb24gPSBlbmRwb2ludERlZmluaXRpb25zW2FyZy5lbmRwb2ludE5hbWVdO1xuICAgIHRyeSB7XG4gICAgICBsZXQgdHJhbnNmb3JtUmVzcG9uc2UgPSBkZWZhdWx0VHJhbnNmb3JtUmVzcG9uc2U7XG4gICAgICBsZXQgcmVzdWx0O1xuICAgICAgY29uc3QgYmFzZVF1ZXJ5QXBpID0ge1xuICAgICAgICBzaWduYWwsXG4gICAgICAgIGFib3J0LFxuICAgICAgICBkaXNwYXRjaCxcbiAgICAgICAgZ2V0U3RhdGUsXG4gICAgICAgIGV4dHJhLFxuICAgICAgICBlbmRwb2ludDogYXJnLmVuZHBvaW50TmFtZSxcbiAgICAgICAgdHlwZTogYXJnLnR5cGUsXG4gICAgICAgIGZvcmNlZDogYXJnLnR5cGUgPT09IFwicXVlcnlcIiA/IGlzRm9yY2VkUXVlcnkoYXJnLCBnZXRTdGF0ZSgpKSA6IHZvaWQgMFxuICAgICAgfTtcbiAgICAgIGNvbnN0IGZvcmNlUXVlcnlGbiA9IGFyZy50eXBlID09PSBcInF1ZXJ5XCIgPyBhcmdbZm9yY2VRdWVyeUZuU3ltYm9sXSA6IHZvaWQgMDtcbiAgICAgIGlmIChmb3JjZVF1ZXJ5Rm4pIHtcbiAgICAgICAgcmVzdWx0ID0gZm9yY2VRdWVyeUZuKCk7XG4gICAgICB9IGVsc2UgaWYgKGVuZHBvaW50RGVmaW5pdGlvbi5xdWVyeSkge1xuICAgICAgICByZXN1bHQgPSBhd2FpdCBiYXNlUXVlcnkoZW5kcG9pbnREZWZpbml0aW9uLnF1ZXJ5KGFyZy5vcmlnaW5hbEFyZ3MpLCBiYXNlUXVlcnlBcGksIGVuZHBvaW50RGVmaW5pdGlvbi5leHRyYU9wdGlvbnMpO1xuICAgICAgICBpZiAoZW5kcG9pbnREZWZpbml0aW9uLnRyYW5zZm9ybVJlc3BvbnNlKSB7XG4gICAgICAgICAgdHJhbnNmb3JtUmVzcG9uc2UgPSBlbmRwb2ludERlZmluaXRpb24udHJhbnNmb3JtUmVzcG9uc2U7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9IGF3YWl0IGVuZHBvaW50RGVmaW5pdGlvbi5xdWVyeUZuKGFyZy5vcmlnaW5hbEFyZ3MsIGJhc2VRdWVyeUFwaSwgZW5kcG9pbnREZWZpbml0aW9uLmV4dHJhT3B0aW9ucywgKGFyZzIpID0+IGJhc2VRdWVyeShhcmcyLCBiYXNlUXVlcnlBcGksIGVuZHBvaW50RGVmaW5pdGlvbi5leHRyYU9wdGlvbnMpKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgcHJvY2VzcyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJkZXZlbG9wbWVudFwiKSB7XG4gICAgICAgIGNvbnN0IHdoYXQgPSBlbmRwb2ludERlZmluaXRpb24ucXVlcnkgPyBcImBiYXNlUXVlcnlgXCIgOiBcImBxdWVyeUZuYFwiO1xuICAgICAgICBsZXQgZXJyO1xuICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgIGVyciA9IGAke3doYXR9IGRpZCBub3QgcmV0dXJuIGFueXRoaW5nLmA7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHJlc3VsdCAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgIGVyciA9IGAke3doYXR9IGRpZCBub3QgcmV0dXJuIGFuIG9iamVjdC5gO1xuICAgICAgICB9IGVsc2UgaWYgKHJlc3VsdC5lcnJvciAmJiByZXN1bHQuZGF0YSkge1xuICAgICAgICAgIGVyciA9IGAke3doYXR9IHJldHVybmVkIGFuIG9iamVjdCBjb250YWluaW5nIGJvdGggXFxgZXJyb3JcXGAgYW5kIFxcYHJlc3VsdFxcYC5gO1xuICAgICAgICB9IGVsc2UgaWYgKHJlc3VsdC5lcnJvciA9PT0gdm9pZCAwICYmIHJlc3VsdC5kYXRhID09PSB2b2lkIDApIHtcbiAgICAgICAgICBlcnIgPSBgJHt3aGF0fSByZXR1cm5lZCBhbiBvYmplY3QgY29udGFpbmluZyBuZWl0aGVyIGEgdmFsaWQgXFxgZXJyb3JcXGAgYW5kIFxcYHJlc3VsdFxcYC4gQXQgbGVhc3Qgb25lIG9mIHRoZW0gc2hvdWxkIG5vdCBiZSBcXGB1bmRlZmluZWRcXGBgO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHJlc3VsdCkpIHtcbiAgICAgICAgICAgIGlmIChrZXkgIT09IFwiZXJyb3JcIiAmJiBrZXkgIT09IFwiZGF0YVwiICYmIGtleSAhPT0gXCJtZXRhXCIpIHtcbiAgICAgICAgICAgICAgZXJyID0gYFRoZSBvYmplY3QgcmV0dXJuZWQgYnkgJHt3aGF0fSBoYXMgdGhlIHVua25vd24gcHJvcGVydHkgJHtrZXl9LmA7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgZW5jb3VudGVyZWQgaGFuZGxpbmcgdGhlIGVuZHBvaW50ICR7YXJnLmVuZHBvaW50TmFtZX0uXG4gICAgICAgICAgICAgICR7ZXJyfVxuICAgICAgICAgICAgICBJdCBuZWVkcyB0byByZXR1cm4gYW4gb2JqZWN0IHdpdGggZWl0aGVyIHRoZSBzaGFwZSBcXGB7IGRhdGE6IDx2YWx1ZT4gfVxcYCBvciBcXGB7IGVycm9yOiA8dmFsdWU+IH1cXGAgdGhhdCBtYXkgY29udGFpbiBhbiBvcHRpb25hbCBcXGBtZXRhXFxgIHByb3BlcnR5LlxuICAgICAgICAgICAgICBPYmplY3QgcmV0dXJuZWQgd2FzOmAsIHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChyZXN1bHQuZXJyb3IpIHRocm93IG5ldyBIYW5kbGVkRXJyb3IocmVzdWx0LmVycm9yLCByZXN1bHQubWV0YSk7XG4gICAgICByZXR1cm4gZnVsZmlsbFdpdGhWYWx1ZShhd2FpdCB0cmFuc2Zvcm1SZXNwb25zZShyZXN1bHQuZGF0YSwgcmVzdWx0Lm1ldGEsIGFyZy5vcmlnaW5hbEFyZ3MpLCB7XG4gICAgICAgIGZ1bGZpbGxlZFRpbWVTdGFtcDogRGF0ZS5ub3coKSxcbiAgICAgICAgYmFzZVF1ZXJ5TWV0YTogcmVzdWx0Lm1ldGEsXG4gICAgICAgIFtTSE9VTERfQVVUT0JBVENIXTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGxldCBjYXRjaGVkRXJyb3IgPSBlcnJvcjtcbiAgICAgIGlmIChjYXRjaGVkRXJyb3IgaW5zdGFuY2VvZiBIYW5kbGVkRXJyb3IpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybUVycm9yUmVzcG9uc2UgPSBkZWZhdWx0VHJhbnNmb3JtUmVzcG9uc2U7XG4gICAgICAgIGlmIChlbmRwb2ludERlZmluaXRpb24ucXVlcnkgJiYgZW5kcG9pbnREZWZpbml0aW9uLnRyYW5zZm9ybUVycm9yUmVzcG9uc2UpIHtcbiAgICAgICAgICB0cmFuc2Zvcm1FcnJvclJlc3BvbnNlID0gZW5kcG9pbnREZWZpbml0aW9uLnRyYW5zZm9ybUVycm9yUmVzcG9uc2U7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gcmVqZWN0V2l0aFZhbHVlKGF3YWl0IHRyYW5zZm9ybUVycm9yUmVzcG9uc2UoY2F0Y2hlZEVycm9yLnZhbHVlLCBjYXRjaGVkRXJyb3IubWV0YSwgYXJnLm9yaWdpbmFsQXJncyksIHtcbiAgICAgICAgICAgIGJhc2VRdWVyeU1ldGE6IGNhdGNoZWRFcnJvci5tZXRhLFxuICAgICAgICAgICAgW1NIT1VMRF9BVVRPQkFUQ0hdOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBjYXRjaGVkRXJyb3IgPSBlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHByb2Nlc3MgIT09IFwidW5kZWZpbmVkXCIgJiYgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYEFuIHVuaGFuZGxlZCBlcnJvciBvY2N1cnJlZCBwcm9jZXNzaW5nIGEgcmVxdWVzdCBmb3IgdGhlIGVuZHBvaW50IFwiJHthcmcuZW5kcG9pbnROYW1lfVwiLlxuSW4gdGhlIGNhc2Ugb2YgYW4gdW5oYW5kbGVkIGVycm9yLCBubyB0YWdzIHdpbGwgYmUgXCJwcm92aWRlZFwiIG9yIFwiaW52YWxpZGF0ZWRcIi5gLCBjYXRjaGVkRXJyb3IpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihjYXRjaGVkRXJyb3IpO1xuICAgICAgfVxuICAgICAgdGhyb3cgY2F0Y2hlZEVycm9yO1xuICAgIH1cbiAgfTtcbiAgZnVuY3Rpb24gaXNGb3JjZWRRdWVyeShhcmcsIHN0YXRlKSB7XG4gICAgY29uc3QgcmVxdWVzdFN0YXRlID0gc3RhdGVbcmVkdWNlclBhdGhdPy5xdWVyaWVzPy5bYXJnLnF1ZXJ5Q2FjaGVLZXldO1xuICAgIGNvbnN0IGJhc2VGZXRjaE9uTW91bnRPckFyZ0NoYW5nZSA9IHN0YXRlW3JlZHVjZXJQYXRoXT8uY29uZmlnLnJlZmV0Y2hPbk1vdW50T3JBcmdDaGFuZ2U7XG4gICAgY29uc3QgZnVsZmlsbGVkVmFsID0gcmVxdWVzdFN0YXRlPy5mdWxmaWxsZWRUaW1lU3RhbXA7XG4gICAgY29uc3QgcmVmZXRjaFZhbCA9IGFyZy5mb3JjZVJlZmV0Y2ggPz8gKGFyZy5zdWJzY3JpYmUgJiYgYmFzZUZldGNoT25Nb3VudE9yQXJnQ2hhbmdlKTtcbiAgICBpZiAocmVmZXRjaFZhbCkge1xuICAgICAgcmV0dXJuIHJlZmV0Y2hWYWwgPT09IHRydWUgfHwgKE51bWJlcigvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKSkgLSBOdW1iZXIoZnVsZmlsbGVkVmFsKSkgLyAxZTMgPj0gcmVmZXRjaFZhbDtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IHF1ZXJ5VGh1bmsgPSBjcmVhdGVBc3luY1RodW5rKGAke3JlZHVjZXJQYXRofS9leGVjdXRlUXVlcnlgLCBleGVjdXRlRW5kcG9pbnQsIHtcbiAgICBnZXRQZW5kaW5nTWV0YSgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN0YXJ0ZWRUaW1lU3RhbXA6IERhdGUubm93KCksXG4gICAgICAgIFtTSE9VTERfQVVUT0JBVENIXTogdHJ1ZVxuICAgICAgfTtcbiAgICB9LFxuICAgIGNvbmRpdGlvbihxdWVyeVRodW5rQXJncywge1xuICAgICAgZ2V0U3RhdGVcbiAgICB9KSB7XG4gICAgICBjb25zdCBzdGF0ZSA9IGdldFN0YXRlKCk7XG4gICAgICBjb25zdCByZXF1ZXN0U3RhdGUgPSBzdGF0ZVtyZWR1Y2VyUGF0aF0/LnF1ZXJpZXM/LltxdWVyeVRodW5rQXJncy5xdWVyeUNhY2hlS2V5XTtcbiAgICAgIGNvbnN0IGZ1bGZpbGxlZFZhbCA9IHJlcXVlc3RTdGF0ZT8uZnVsZmlsbGVkVGltZVN0YW1wO1xuICAgICAgY29uc3QgY3VycmVudEFyZyA9IHF1ZXJ5VGh1bmtBcmdzLm9yaWdpbmFsQXJncztcbiAgICAgIGNvbnN0IHByZXZpb3VzQXJnID0gcmVxdWVzdFN0YXRlPy5vcmlnaW5hbEFyZ3M7XG4gICAgICBjb25zdCBlbmRwb2ludERlZmluaXRpb24gPSBlbmRwb2ludERlZmluaXRpb25zW3F1ZXJ5VGh1bmtBcmdzLmVuZHBvaW50TmFtZV07XG4gICAgICBpZiAoaXNVcHNlcnRRdWVyeShxdWVyeVRodW5rQXJncykpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBpZiAocmVxdWVzdFN0YXRlPy5zdGF0dXMgPT09IFwicGVuZGluZ1wiKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0ZvcmNlZFF1ZXJ5KHF1ZXJ5VGh1bmtBcmdzLCBzdGF0ZSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoaXNRdWVyeURlZmluaXRpb24oZW5kcG9pbnREZWZpbml0aW9uKSAmJiBlbmRwb2ludERlZmluaXRpb24/LmZvcmNlUmVmZXRjaD8uKHtcbiAgICAgICAgY3VycmVudEFyZyxcbiAgICAgICAgcHJldmlvdXNBcmcsXG4gICAgICAgIGVuZHBvaW50U3RhdGU6IHJlcXVlc3RTdGF0ZSxcbiAgICAgICAgc3RhdGVcbiAgICAgIH0pKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKGZ1bGZpbGxlZFZhbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICAgIGRpc3BhdGNoQ29uZGl0aW9uUmVqZWN0aW9uOiB0cnVlXG4gIH0pO1xuICBjb25zdCBtdXRhdGlvblRodW5rID0gY3JlYXRlQXN5bmNUaHVuayhgJHtyZWR1Y2VyUGF0aH0vZXhlY3V0ZU11dGF0aW9uYCwgZXhlY3V0ZUVuZHBvaW50LCB7XG4gICAgZ2V0UGVuZGluZ01ldGEoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdGFydGVkVGltZVN0YW1wOiBEYXRlLm5vdygpLFxuICAgICAgICBbU0hPVUxEX0FVVE9CQVRDSF06IHRydWVcbiAgICAgIH07XG4gICAgfVxuICB9KTtcbiAgY29uc3QgaGFzVGhlRm9yY2UgPSAob3B0aW9ucykgPT4gXCJmb3JjZVwiIGluIG9wdGlvbnM7XG4gIGNvbnN0IGhhc01heEFnZSA9IChvcHRpb25zKSA9PiBcImlmT2xkZXJUaGFuXCIgaW4gb3B0aW9ucztcbiAgY29uc3QgcHJlZmV0Y2ggPSAoZW5kcG9pbnROYW1lLCBhcmcsIG9wdGlvbnMpID0+IChkaXNwYXRjaCwgZ2V0U3RhdGUpID0+IHtcbiAgICBjb25zdCBmb3JjZSA9IGhhc1RoZUZvcmNlKG9wdGlvbnMpICYmIG9wdGlvbnMuZm9yY2U7XG4gICAgY29uc3QgbWF4QWdlID0gaGFzTWF4QWdlKG9wdGlvbnMpICYmIG9wdGlvbnMuaWZPbGRlclRoYW47XG4gICAgY29uc3QgcXVlcnlBY3Rpb24gPSAoZm9yY2UyID0gdHJ1ZSkgPT4ge1xuICAgICAgY29uc3Qgb3B0aW9uczIgPSB7XG4gICAgICAgIGZvcmNlUmVmZXRjaDogZm9yY2UyLFxuICAgICAgICBpc1ByZWZldGNoOiB0cnVlXG4gICAgICB9O1xuICAgICAgcmV0dXJuIGFwaS5lbmRwb2ludHNbZW5kcG9pbnROYW1lXS5pbml0aWF0ZShhcmcsIG9wdGlvbnMyKTtcbiAgICB9O1xuICAgIGNvbnN0IGxhdGVzdFN0YXRlVmFsdWUgPSBhcGkuZW5kcG9pbnRzW2VuZHBvaW50TmFtZV0uc2VsZWN0KGFyZykoZ2V0U3RhdGUoKSk7XG4gICAgaWYgKGZvcmNlKSB7XG4gICAgICBkaXNwYXRjaChxdWVyeUFjdGlvbigpKTtcbiAgICB9IGVsc2UgaWYgKG1heEFnZSkge1xuICAgICAgY29uc3QgbGFzdEZ1bGZpbGxlZFRzID0gbGF0ZXN0U3RhdGVWYWx1ZT8uZnVsZmlsbGVkVGltZVN0YW1wO1xuICAgICAgaWYgKCFsYXN0RnVsZmlsbGVkVHMpIHtcbiAgICAgICAgZGlzcGF0Y2gocXVlcnlBY3Rpb24oKSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNob3VsZFJldHJpZ2dlciA9IChOdW1iZXIoLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCkpIC0gTnVtYmVyKG5ldyBEYXRlKGxhc3RGdWxmaWxsZWRUcykpKSAvIDFlMyA+PSBtYXhBZ2U7XG4gICAgICBpZiAoc2hvdWxkUmV0cmlnZ2VyKSB7XG4gICAgICAgIGRpc3BhdGNoKHF1ZXJ5QWN0aW9uKCkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBkaXNwYXRjaChxdWVyeUFjdGlvbihmYWxzZSkpO1xuICAgIH1cbiAgfTtcbiAgZnVuY3Rpb24gbWF0Y2hlc0VuZHBvaW50KGVuZHBvaW50TmFtZSkge1xuICAgIHJldHVybiAoYWN0aW9uKSA9PiBhY3Rpb24/Lm1ldGE/LmFyZz8uZW5kcG9pbnROYW1lID09PSBlbmRwb2ludE5hbWU7XG4gIH1cbiAgZnVuY3Rpb24gYnVpbGRNYXRjaFRodW5rQWN0aW9ucyh0aHVuaywgZW5kcG9pbnROYW1lKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1hdGNoUGVuZGluZzogaXNBbGxPZihpc1BlbmRpbmcodGh1bmspLCBtYXRjaGVzRW5kcG9pbnQoZW5kcG9pbnROYW1lKSksXG4gICAgICBtYXRjaEZ1bGZpbGxlZDogaXNBbGxPZihpc0Z1bGZpbGxlZCh0aHVuayksIG1hdGNoZXNFbmRwb2ludChlbmRwb2ludE5hbWUpKSxcbiAgICAgIG1hdGNoUmVqZWN0ZWQ6IGlzQWxsT2YoaXNSZWplY3RlZCh0aHVuayksIG1hdGNoZXNFbmRwb2ludChlbmRwb2ludE5hbWUpKVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBxdWVyeVRodW5rLFxuICAgIG11dGF0aW9uVGh1bmssXG4gICAgcHJlZmV0Y2gsXG4gICAgdXBkYXRlUXVlcnlEYXRhLFxuICAgIHVwc2VydFF1ZXJ5RGF0YSxcbiAgICBwYXRjaFF1ZXJ5RGF0YSxcbiAgICBidWlsZE1hdGNoVGh1bmtBY3Rpb25zXG4gIH07XG59XG5mdW5jdGlvbiBjYWxjdWxhdGVQcm92aWRlZEJ5VGh1bmsoYWN0aW9uLCB0eXBlLCBlbmRwb2ludERlZmluaXRpb25zLCBhc3NlcnRUYWdUeXBlKSB7XG4gIHJldHVybiBjYWxjdWxhdGVQcm92aWRlZEJ5KGVuZHBvaW50RGVmaW5pdGlvbnNbYWN0aW9uLm1ldGEuYXJnLmVuZHBvaW50TmFtZV1bdHlwZV0sIGlzRnVsZmlsbGVkKGFjdGlvbikgPyBhY3Rpb24ucGF5bG9hZCA6IHZvaWQgMCwgaXNSZWplY3RlZFdpdGhWYWx1ZShhY3Rpb24pID8gYWN0aW9uLnBheWxvYWQgOiB2b2lkIDAsIGFjdGlvbi5tZXRhLmFyZy5vcmlnaW5hbEFyZ3MsIFwiYmFzZVF1ZXJ5TWV0YVwiIGluIGFjdGlvbi5tZXRhID8gYWN0aW9uLm1ldGEuYmFzZVF1ZXJ5TWV0YSA6IHZvaWQgMCwgYXNzZXJ0VGFnVHlwZSk7XG59XG5cbi8vIHNyYy9xdWVyeS9jb3JlL2J1aWxkU2xpY2UudHNcbmltcG9ydCB7IGlzRHJhZnQgfSBmcm9tIFwiaW1tZXJcIjtcbmltcG9ydCB7IGFwcGx5UGF0Y2hlcywgb3JpZ2luYWwgfSBmcm9tIFwiaW1tZXJcIjtcbmZ1bmN0aW9uIHVwZGF0ZVF1ZXJ5U3Vic3RhdGVJZkV4aXN0cyhzdGF0ZSwgcXVlcnlDYWNoZUtleSwgdXBkYXRlKSB7XG4gIGNvbnN0IHN1YnN0YXRlID0gc3RhdGVbcXVlcnlDYWNoZUtleV07XG4gIGlmIChzdWJzdGF0ZSkge1xuICAgIHVwZGF0ZShzdWJzdGF0ZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldE11dGF0aW9uQ2FjaGVLZXkoaWQpIHtcbiAgcmV0dXJuIChcImFyZ1wiIGluIGlkID8gaWQuYXJnLmZpeGVkQ2FjaGVLZXkgOiBpZC5maXhlZENhY2hlS2V5KSA/PyBpZC5yZXF1ZXN0SWQ7XG59XG5mdW5jdGlvbiB1cGRhdGVNdXRhdGlvblN1YnN0YXRlSWZFeGlzdHMoc3RhdGUsIGlkLCB1cGRhdGUpIHtcbiAgY29uc3Qgc3Vic3RhdGUgPSBzdGF0ZVtnZXRNdXRhdGlvbkNhY2hlS2V5KGlkKV07XG4gIGlmIChzdWJzdGF0ZSkge1xuICAgIHVwZGF0ZShzdWJzdGF0ZSk7XG4gIH1cbn1cbnZhciBpbml0aWFsU3RhdGUgPSB7fTtcbmZ1bmN0aW9uIGJ1aWxkU2xpY2Uoe1xuICByZWR1Y2VyUGF0aCxcbiAgcXVlcnlUaHVuayxcbiAgbXV0YXRpb25UaHVuayxcbiAgY29udGV4dDoge1xuICAgIGVuZHBvaW50RGVmaW5pdGlvbnM6IGRlZmluaXRpb25zLFxuICAgIGFwaVVpZCxcbiAgICBleHRyYWN0UmVoeWRyYXRpb25JbmZvLFxuICAgIGhhc1JlaHlkcmF0aW9uSW5mb1xuICB9LFxuICBhc3NlcnRUYWdUeXBlLFxuICBjb25maWdcbn0pIHtcbiAgY29uc3QgcmVzZXRBcGlTdGF0ZSA9IGNyZWF0ZUFjdGlvbihgJHtyZWR1Y2VyUGF0aH0vcmVzZXRBcGlTdGF0ZWApO1xuICBjb25zdCBxdWVyeVNsaWNlID0gY3JlYXRlU2xpY2Uoe1xuICAgIG5hbWU6IGAke3JlZHVjZXJQYXRofS9xdWVyaWVzYCxcbiAgICBpbml0aWFsU3RhdGUsXG4gICAgcmVkdWNlcnM6IHtcbiAgICAgIHJlbW92ZVF1ZXJ5UmVzdWx0OiB7XG4gICAgICAgIHJlZHVjZXIoZHJhZnQsIHtcbiAgICAgICAgICBwYXlsb2FkOiB7XG4gICAgICAgICAgICBxdWVyeUNhY2hlS2V5XG4gICAgICAgICAgfVxuICAgICAgICB9KSB7XG4gICAgICAgICAgZGVsZXRlIGRyYWZ0W3F1ZXJ5Q2FjaGVLZXldO1xuICAgICAgICB9LFxuICAgICAgICBwcmVwYXJlOiBwcmVwYXJlQXV0b0JhdGNoZWQoKVxuICAgICAgfSxcbiAgICAgIHF1ZXJ5UmVzdWx0UGF0Y2hlZDoge1xuICAgICAgICByZWR1Y2VyKGRyYWZ0LCB7XG4gICAgICAgICAgcGF5bG9hZDoge1xuICAgICAgICAgICAgcXVlcnlDYWNoZUtleSxcbiAgICAgICAgICAgIHBhdGNoZXNcbiAgICAgICAgICB9XG4gICAgICAgIH0pIHtcbiAgICAgICAgICB1cGRhdGVRdWVyeVN1YnN0YXRlSWZFeGlzdHMoZHJhZnQsIHF1ZXJ5Q2FjaGVLZXksIChzdWJzdGF0ZSkgPT4ge1xuICAgICAgICAgICAgc3Vic3RhdGUuZGF0YSA9IGFwcGx5UGF0Y2hlcyhzdWJzdGF0ZS5kYXRhLCBwYXRjaGVzLmNvbmNhdCgpKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgcHJlcGFyZTogcHJlcGFyZUF1dG9CYXRjaGVkKClcbiAgICAgIH1cbiAgICB9LFxuICAgIGV4dHJhUmVkdWNlcnMoYnVpbGRlcikge1xuICAgICAgYnVpbGRlci5hZGRDYXNlKHF1ZXJ5VGh1bmsucGVuZGluZywgKGRyYWZ0LCB7XG4gICAgICAgIG1ldGEsXG4gICAgICAgIG1ldGE6IHtcbiAgICAgICAgICBhcmdcbiAgICAgICAgfVxuICAgICAgfSkgPT4ge1xuICAgICAgICBjb25zdCB1cHNlcnRpbmcgPSBpc1Vwc2VydFF1ZXJ5KGFyZyk7XG4gICAgICAgIGRyYWZ0W2FyZy5xdWVyeUNhY2hlS2V5XSA/Pz0ge1xuICAgICAgICAgIHN0YXR1czogXCJ1bmluaXRpYWxpemVkXCIgLyogdW5pbml0aWFsaXplZCAqLyxcbiAgICAgICAgICBlbmRwb2ludE5hbWU6IGFyZy5lbmRwb2ludE5hbWVcbiAgICAgICAgfTtcbiAgICAgICAgdXBkYXRlUXVlcnlTdWJzdGF0ZUlmRXhpc3RzKGRyYWZ0LCBhcmcucXVlcnlDYWNoZUtleSwgKHN1YnN0YXRlKSA9PiB7XG4gICAgICAgICAgc3Vic3RhdGUuc3RhdHVzID0gXCJwZW5kaW5nXCIgLyogcGVuZGluZyAqLztcbiAgICAgICAgICBzdWJzdGF0ZS5yZXF1ZXN0SWQgPSB1cHNlcnRpbmcgJiYgc3Vic3RhdGUucmVxdWVzdElkID8gKFxuICAgICAgICAgICAgLy8gZm9yIGB1cHNlcnRRdWVyeWAgKip1cGRhdGVzKiosIGtlZXAgdGhlIGN1cnJlbnQgYHJlcXVlc3RJZGBcbiAgICAgICAgICAgIHN1YnN0YXRlLnJlcXVlc3RJZFxuICAgICAgICAgICkgOiAoXG4gICAgICAgICAgICAvLyBmb3Igbm9ybWFsIHF1ZXJpZXMgb3IgYHVwc2VydFF1ZXJ5YCAqKmluc2VydHMqKiBhbHdheXMgdXBkYXRlIHRoZSBgcmVxdWVzdElkYFxuICAgICAgICAgICAgbWV0YS5yZXF1ZXN0SWRcbiAgICAgICAgICApO1xuICAgICAgICAgIGlmIChhcmcub3JpZ2luYWxBcmdzICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHN1YnN0YXRlLm9yaWdpbmFsQXJncyA9IGFyZy5vcmlnaW5hbEFyZ3M7XG4gICAgICAgICAgfVxuICAgICAgICAgIHN1YnN0YXRlLnN0YXJ0ZWRUaW1lU3RhbXAgPSBtZXRhLnN0YXJ0ZWRUaW1lU3RhbXA7XG4gICAgICAgIH0pO1xuICAgICAgfSkuYWRkQ2FzZShxdWVyeVRodW5rLmZ1bGZpbGxlZCwgKGRyYWZ0LCB7XG4gICAgICAgIG1ldGEsXG4gICAgICAgIHBheWxvYWRcbiAgICAgIH0pID0+IHtcbiAgICAgICAgdXBkYXRlUXVlcnlTdWJzdGF0ZUlmRXhpc3RzKGRyYWZ0LCBtZXRhLmFyZy5xdWVyeUNhY2hlS2V5LCAoc3Vic3RhdGUpID0+IHtcbiAgICAgICAgICBpZiAoc3Vic3RhdGUucmVxdWVzdElkICE9PSBtZXRhLnJlcXVlc3RJZCAmJiAhaXNVcHNlcnRRdWVyeShtZXRhLmFyZykpIHJldHVybjtcbiAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBtZXJnZVxuICAgICAgICAgIH0gPSBkZWZpbml0aW9uc1ttZXRhLmFyZy5lbmRwb2ludE5hbWVdO1xuICAgICAgICAgIHN1YnN0YXRlLnN0YXR1cyA9IFwiZnVsZmlsbGVkXCIgLyogZnVsZmlsbGVkICovO1xuICAgICAgICAgIGlmIChtZXJnZSkge1xuICAgICAgICAgICAgaWYgKHN1YnN0YXRlLmRhdGEgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgICAgZnVsZmlsbGVkVGltZVN0YW1wLFxuICAgICAgICAgICAgICAgIGFyZyxcbiAgICAgICAgICAgICAgICBiYXNlUXVlcnlNZXRhLFxuICAgICAgICAgICAgICAgIHJlcXVlc3RJZFxuICAgICAgICAgICAgICB9ID0gbWV0YTtcbiAgICAgICAgICAgICAgbGV0IG5ld0RhdGEgPSBjcmVhdGVOZXh0U3RhdGUoc3Vic3RhdGUuZGF0YSwgKGRyYWZ0U3Vic3RhdGVEYXRhKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1lcmdlKGRyYWZ0U3Vic3RhdGVEYXRhLCBwYXlsb2FkLCB7XG4gICAgICAgICAgICAgICAgICBhcmc6IGFyZy5vcmlnaW5hbEFyZ3MsXG4gICAgICAgICAgICAgICAgICBiYXNlUXVlcnlNZXRhLFxuICAgICAgICAgICAgICAgICAgZnVsZmlsbGVkVGltZVN0YW1wLFxuICAgICAgICAgICAgICAgICAgcmVxdWVzdElkXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBzdWJzdGF0ZS5kYXRhID0gbmV3RGF0YTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHN1YnN0YXRlLmRhdGEgPSBwYXlsb2FkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdWJzdGF0ZS5kYXRhID0gZGVmaW5pdGlvbnNbbWV0YS5hcmcuZW5kcG9pbnROYW1lXS5zdHJ1Y3R1cmFsU2hhcmluZyA/PyB0cnVlID8gY29weVdpdGhTdHJ1Y3R1cmFsU2hhcmluZyhpc0RyYWZ0KHN1YnN0YXRlLmRhdGEpID8gb3JpZ2luYWwoc3Vic3RhdGUuZGF0YSkgOiBzdWJzdGF0ZS5kYXRhLCBwYXlsb2FkKSA6IHBheWxvYWQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRlbGV0ZSBzdWJzdGF0ZS5lcnJvcjtcbiAgICAgICAgICBzdWJzdGF0ZS5mdWxmaWxsZWRUaW1lU3RhbXAgPSBtZXRhLmZ1bGZpbGxlZFRpbWVTdGFtcDtcbiAgICAgICAgfSk7XG4gICAgICB9KS5hZGRDYXNlKHF1ZXJ5VGh1bmsucmVqZWN0ZWQsIChkcmFmdCwge1xuICAgICAgICBtZXRhOiB7XG4gICAgICAgICAgY29uZGl0aW9uLFxuICAgICAgICAgIGFyZyxcbiAgICAgICAgICByZXF1ZXN0SWRcbiAgICAgICAgfSxcbiAgICAgICAgZXJyb3IsXG4gICAgICAgIHBheWxvYWRcbiAgICAgIH0pID0+IHtcbiAgICAgICAgdXBkYXRlUXVlcnlTdWJzdGF0ZUlmRXhpc3RzKGRyYWZ0LCBhcmcucXVlcnlDYWNoZUtleSwgKHN1YnN0YXRlKSA9PiB7XG4gICAgICAgICAgaWYgKGNvbmRpdGlvbikge1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoc3Vic3RhdGUucmVxdWVzdElkICE9PSByZXF1ZXN0SWQpIHJldHVybjtcbiAgICAgICAgICAgIHN1YnN0YXRlLnN0YXR1cyA9IFwicmVqZWN0ZWRcIiAvKiByZWplY3RlZCAqLztcbiAgICAgICAgICAgIHN1YnN0YXRlLmVycm9yID0gcGF5bG9hZCA/PyBlcnJvcjtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSkuYWRkTWF0Y2hlcihoYXNSZWh5ZHJhdGlvbkluZm8sIChkcmFmdCwgYWN0aW9uKSA9PiB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBxdWVyaWVzXG4gICAgICAgIH0gPSBleHRyYWN0UmVoeWRyYXRpb25JbmZvKGFjdGlvbik7XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgZW50cnldIG9mIE9iamVjdC5lbnRyaWVzKHF1ZXJpZXMpKSB7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgLy8gZG8gbm90IHJlaHlkcmF0ZSBlbnRyaWVzIHRoYXQgd2VyZSBjdXJyZW50bHkgaW4gZmxpZ2h0LlxuICAgICAgICAgICAgZW50cnk/LnN0YXR1cyA9PT0gXCJmdWxmaWxsZWRcIiAvKiBmdWxmaWxsZWQgKi8gfHwgZW50cnk/LnN0YXR1cyA9PT0gXCJyZWplY3RlZFwiIC8qIHJlamVjdGVkICovXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBkcmFmdFtrZXldID0gZW50cnk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuICBjb25zdCBtdXRhdGlvblNsaWNlID0gY3JlYXRlU2xpY2Uoe1xuICAgIG5hbWU6IGAke3JlZHVjZXJQYXRofS9tdXRhdGlvbnNgLFxuICAgIGluaXRpYWxTdGF0ZSxcbiAgICByZWR1Y2Vyczoge1xuICAgICAgcmVtb3ZlTXV0YXRpb25SZXN1bHQ6IHtcbiAgICAgICAgcmVkdWNlcihkcmFmdCwge1xuICAgICAgICAgIHBheWxvYWRcbiAgICAgICAgfSkge1xuICAgICAgICAgIGNvbnN0IGNhY2hlS2V5ID0gZ2V0TXV0YXRpb25DYWNoZUtleShwYXlsb2FkKTtcbiAgICAgICAgICBpZiAoY2FjaGVLZXkgaW4gZHJhZnQpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBkcmFmdFtjYWNoZUtleV07XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBwcmVwYXJlOiBwcmVwYXJlQXV0b0JhdGNoZWQoKVxuICAgICAgfVxuICAgIH0sXG4gICAgZXh0cmFSZWR1Y2VycyhidWlsZGVyKSB7XG4gICAgICBidWlsZGVyLmFkZENhc2UobXV0YXRpb25UaHVuay5wZW5kaW5nLCAoZHJhZnQsIHtcbiAgICAgICAgbWV0YSxcbiAgICAgICAgbWV0YToge1xuICAgICAgICAgIHJlcXVlc3RJZCxcbiAgICAgICAgICBhcmcsXG4gICAgICAgICAgc3RhcnRlZFRpbWVTdGFtcFxuICAgICAgICB9XG4gICAgICB9KSA9PiB7XG4gICAgICAgIGlmICghYXJnLnRyYWNrKSByZXR1cm47XG4gICAgICAgIGRyYWZ0W2dldE11dGF0aW9uQ2FjaGVLZXkobWV0YSldID0ge1xuICAgICAgICAgIHJlcXVlc3RJZCxcbiAgICAgICAgICBzdGF0dXM6IFwicGVuZGluZ1wiIC8qIHBlbmRpbmcgKi8sXG4gICAgICAgICAgZW5kcG9pbnROYW1lOiBhcmcuZW5kcG9pbnROYW1lLFxuICAgICAgICAgIHN0YXJ0ZWRUaW1lU3RhbXBcbiAgICAgICAgfTtcbiAgICAgIH0pLmFkZENhc2UobXV0YXRpb25UaHVuay5mdWxmaWxsZWQsIChkcmFmdCwge1xuICAgICAgICBwYXlsb2FkLFxuICAgICAgICBtZXRhXG4gICAgICB9KSA9PiB7XG4gICAgICAgIGlmICghbWV0YS5hcmcudHJhY2spIHJldHVybjtcbiAgICAgICAgdXBkYXRlTXV0YXRpb25TdWJzdGF0ZUlmRXhpc3RzKGRyYWZ0LCBtZXRhLCAoc3Vic3RhdGUpID0+IHtcbiAgICAgICAgICBpZiAoc3Vic3RhdGUucmVxdWVzdElkICE9PSBtZXRhLnJlcXVlc3RJZCkgcmV0dXJuO1xuICAgICAgICAgIHN1YnN0YXRlLnN0YXR1cyA9IFwiZnVsZmlsbGVkXCIgLyogZnVsZmlsbGVkICovO1xuICAgICAgICAgIHN1YnN0YXRlLmRhdGEgPSBwYXlsb2FkO1xuICAgICAgICAgIHN1YnN0YXRlLmZ1bGZpbGxlZFRpbWVTdGFtcCA9IG1ldGEuZnVsZmlsbGVkVGltZVN0YW1wO1xuICAgICAgICB9KTtcbiAgICAgIH0pLmFkZENhc2UobXV0YXRpb25UaHVuay5yZWplY3RlZCwgKGRyYWZ0LCB7XG4gICAgICAgIHBheWxvYWQsXG4gICAgICAgIGVycm9yLFxuICAgICAgICBtZXRhXG4gICAgICB9KSA9PiB7XG4gICAgICAgIGlmICghbWV0YS5hcmcudHJhY2spIHJldHVybjtcbiAgICAgICAgdXBkYXRlTXV0YXRpb25TdWJzdGF0ZUlmRXhpc3RzKGRyYWZ0LCBtZXRhLCAoc3Vic3RhdGUpID0+IHtcbiAgICAgICAgICBpZiAoc3Vic3RhdGUucmVxdWVzdElkICE9PSBtZXRhLnJlcXVlc3RJZCkgcmV0dXJuO1xuICAgICAgICAgIHN1YnN0YXRlLnN0YXR1cyA9IFwicmVqZWN0ZWRcIiAvKiByZWplY3RlZCAqLztcbiAgICAgICAgICBzdWJzdGF0ZS5lcnJvciA9IHBheWxvYWQgPz8gZXJyb3I7XG4gICAgICAgIH0pO1xuICAgICAgfSkuYWRkTWF0Y2hlcihoYXNSZWh5ZHJhdGlvbkluZm8sIChkcmFmdCwgYWN0aW9uKSA9PiB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBtdXRhdGlvbnNcbiAgICAgICAgfSA9IGV4dHJhY3RSZWh5ZHJhdGlvbkluZm8oYWN0aW9uKTtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCBlbnRyeV0gb2YgT2JqZWN0LmVudHJpZXMobXV0YXRpb25zKSkge1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIC8vIGRvIG5vdCByZWh5ZHJhdGUgZW50cmllcyB0aGF0IHdlcmUgY3VycmVudGx5IGluIGZsaWdodC5cbiAgICAgICAgICAgIChlbnRyeT8uc3RhdHVzID09PSBcImZ1bGZpbGxlZFwiIC8qIGZ1bGZpbGxlZCAqLyB8fCBlbnRyeT8uc3RhdHVzID09PSBcInJlamVjdGVkXCIgLyogcmVqZWN0ZWQgKi8pICYmIC8vIG9ubHkgcmVoeWRyYXRlIGVuZHBvaW50cyB0aGF0IHdlcmUgcGVyc2lzdGVkIHVzaW5nIGEgYGZpeGVkQ2FjaGVLZXlgXG4gICAgICAgICAgICBrZXkgIT09IGVudHJ5Py5yZXF1ZXN0SWRcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIGRyYWZ0W2tleV0gPSBlbnRyeTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG4gIGNvbnN0IGludmFsaWRhdGlvblNsaWNlID0gY3JlYXRlU2xpY2Uoe1xuICAgIG5hbWU6IGAke3JlZHVjZXJQYXRofS9pbnZhbGlkYXRpb25gLFxuICAgIGluaXRpYWxTdGF0ZSxcbiAgICByZWR1Y2Vyczoge1xuICAgICAgdXBkYXRlUHJvdmlkZWRCeToge1xuICAgICAgICByZWR1Y2VyKGRyYWZ0LCBhY3Rpb24pIHtcbiAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBxdWVyeUNhY2hlS2V5LFxuICAgICAgICAgICAgcHJvdmlkZWRUYWdzXG4gICAgICAgICAgfSA9IGFjdGlvbi5wYXlsb2FkO1xuICAgICAgICAgIGZvciAoY29uc3QgdGFnVHlwZVN1YnNjcmlwdGlvbnMgb2YgT2JqZWN0LnZhbHVlcyhkcmFmdCkpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaWRTdWJzY3JpcHRpb25zIG9mIE9iamVjdC52YWx1ZXModGFnVHlwZVN1YnNjcmlwdGlvbnMpKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGZvdW5kQXQgPSBpZFN1YnNjcmlwdGlvbnMuaW5kZXhPZihxdWVyeUNhY2hlS2V5KTtcbiAgICAgICAgICAgICAgaWYgKGZvdW5kQXQgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgaWRTdWJzY3JpcHRpb25zLnNwbGljZShmb3VuZEF0LCAxKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKGNvbnN0IHtcbiAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICBpZFxuICAgICAgICAgIH0gb2YgcHJvdmlkZWRUYWdzKSB7XG4gICAgICAgICAgICBjb25zdCBzdWJzY3JpYmVkUXVlcmllcyA9IChkcmFmdFt0eXBlXSA/Pz0ge30pW2lkIHx8IFwiX19pbnRlcm5hbF93aXRob3V0X2lkXCJdID8/PSBbXTtcbiAgICAgICAgICAgIGNvbnN0IGFscmVhZHlTdWJzY3JpYmVkID0gc3Vic2NyaWJlZFF1ZXJpZXMuaW5jbHVkZXMocXVlcnlDYWNoZUtleSk7XG4gICAgICAgICAgICBpZiAoIWFscmVhZHlTdWJzY3JpYmVkKSB7XG4gICAgICAgICAgICAgIHN1YnNjcmliZWRRdWVyaWVzLnB1c2gocXVlcnlDYWNoZUtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBwcmVwYXJlOiBwcmVwYXJlQXV0b0JhdGNoZWQoKVxuICAgICAgfVxuICAgIH0sXG4gICAgZXh0cmFSZWR1Y2VycyhidWlsZGVyKSB7XG4gICAgICBidWlsZGVyLmFkZENhc2UocXVlcnlTbGljZS5hY3Rpb25zLnJlbW92ZVF1ZXJ5UmVzdWx0LCAoZHJhZnQsIHtcbiAgICAgICAgcGF5bG9hZDoge1xuICAgICAgICAgIHF1ZXJ5Q2FjaGVLZXlcbiAgICAgICAgfVxuICAgICAgfSkgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IHRhZ1R5cGVTdWJzY3JpcHRpb25zIG9mIE9iamVjdC52YWx1ZXMoZHJhZnQpKSB7XG4gICAgICAgICAgZm9yIChjb25zdCBpZFN1YnNjcmlwdGlvbnMgb2YgT2JqZWN0LnZhbHVlcyh0YWdUeXBlU3Vic2NyaXB0aW9ucykpIHtcbiAgICAgICAgICAgIGNvbnN0IGZvdW5kQXQgPSBpZFN1YnNjcmlwdGlvbnMuaW5kZXhPZihxdWVyeUNhY2hlS2V5KTtcbiAgICAgICAgICAgIGlmIChmb3VuZEF0ICE9PSAtMSkge1xuICAgICAgICAgICAgICBpZFN1YnNjcmlwdGlvbnMuc3BsaWNlKGZvdW5kQXQsIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSkuYWRkTWF0Y2hlcihoYXNSZWh5ZHJhdGlvbkluZm8sIChkcmFmdCwgYWN0aW9uKSA9PiB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBwcm92aWRlZFxuICAgICAgICB9ID0gZXh0cmFjdFJlaHlkcmF0aW9uSW5mbyhhY3Rpb24pO1xuICAgICAgICBmb3IgKGNvbnN0IFt0eXBlLCBpbmNvbWluZ1RhZ3NdIG9mIE9iamVjdC5lbnRyaWVzKHByb3ZpZGVkKSkge1xuICAgICAgICAgIGZvciAoY29uc3QgW2lkLCBjYWNoZUtleXNdIG9mIE9iamVjdC5lbnRyaWVzKGluY29taW5nVGFncykpIHtcbiAgICAgICAgICAgIGNvbnN0IHN1YnNjcmliZWRRdWVyaWVzID0gKGRyYWZ0W3R5cGVdID8/PSB7fSlbaWQgfHwgXCJfX2ludGVybmFsX3dpdGhvdXRfaWRcIl0gPz89IFtdO1xuICAgICAgICAgICAgZm9yIChjb25zdCBxdWVyeUNhY2hlS2V5IG9mIGNhY2hlS2V5cykge1xuICAgICAgICAgICAgICBjb25zdCBhbHJlYWR5U3Vic2NyaWJlZCA9IHN1YnNjcmliZWRRdWVyaWVzLmluY2x1ZGVzKHF1ZXJ5Q2FjaGVLZXkpO1xuICAgICAgICAgICAgICBpZiAoIWFscmVhZHlTdWJzY3JpYmVkKSB7XG4gICAgICAgICAgICAgICAgc3Vic2NyaWJlZFF1ZXJpZXMucHVzaChxdWVyeUNhY2hlS2V5KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSkuYWRkTWF0Y2hlcihpc0FueU9mKGlzRnVsZmlsbGVkKHF1ZXJ5VGh1bmspLCBpc1JlamVjdGVkV2l0aFZhbHVlKHF1ZXJ5VGh1bmspKSwgKGRyYWZ0LCBhY3Rpb24pID0+IHtcbiAgICAgICAgY29uc3QgcHJvdmlkZWRUYWdzID0gY2FsY3VsYXRlUHJvdmlkZWRCeVRodW5rKGFjdGlvbiwgXCJwcm92aWRlc1RhZ3NcIiwgZGVmaW5pdGlvbnMsIGFzc2VydFRhZ1R5cGUpO1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgcXVlcnlDYWNoZUtleVxuICAgICAgICB9ID0gYWN0aW9uLm1ldGEuYXJnO1xuICAgICAgICBpbnZhbGlkYXRpb25TbGljZS5jYXNlUmVkdWNlcnMudXBkYXRlUHJvdmlkZWRCeShkcmFmdCwgaW52YWxpZGF0aW9uU2xpY2UuYWN0aW9ucy51cGRhdGVQcm92aWRlZEJ5KHtcbiAgICAgICAgICBxdWVyeUNhY2hlS2V5LFxuICAgICAgICAgIHByb3ZpZGVkVGFnc1xuICAgICAgICB9KSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuICBjb25zdCBzdWJzY3JpcHRpb25TbGljZSA9IGNyZWF0ZVNsaWNlKHtcbiAgICBuYW1lOiBgJHtyZWR1Y2VyUGF0aH0vc3Vic2NyaXB0aW9uc2AsXG4gICAgaW5pdGlhbFN0YXRlLFxuICAgIHJlZHVjZXJzOiB7XG4gICAgICB1cGRhdGVTdWJzY3JpcHRpb25PcHRpb25zKGQsIGEpIHtcbiAgICAgIH0sXG4gICAgICB1bnN1YnNjcmliZVF1ZXJ5UmVzdWx0KGQsIGEpIHtcbiAgICAgIH0sXG4gICAgICBpbnRlcm5hbF9nZXRSVEtRU3Vic2NyaXB0aW9ucygpIHtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICBjb25zdCBpbnRlcm5hbFN1YnNjcmlwdGlvbnNTbGljZSA9IGNyZWF0ZVNsaWNlKHtcbiAgICBuYW1lOiBgJHtyZWR1Y2VyUGF0aH0vaW50ZXJuYWxTdWJzY3JpcHRpb25zYCxcbiAgICBpbml0aWFsU3RhdGUsXG4gICAgcmVkdWNlcnM6IHtcbiAgICAgIHN1YnNjcmlwdGlvbnNVcGRhdGVkOiB7XG4gICAgICAgIHJlZHVjZXIoc3RhdGUsIGFjdGlvbikge1xuICAgICAgICAgIHJldHVybiBhcHBseVBhdGNoZXMoc3RhdGUsIGFjdGlvbi5wYXlsb2FkKTtcbiAgICAgICAgfSxcbiAgICAgICAgcHJlcGFyZTogcHJlcGFyZUF1dG9CYXRjaGVkKClcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICBjb25zdCBjb25maWdTbGljZSA9IGNyZWF0ZVNsaWNlKHtcbiAgICBuYW1lOiBgJHtyZWR1Y2VyUGF0aH0vY29uZmlnYCxcbiAgICBpbml0aWFsU3RhdGU6IHtcbiAgICAgIG9ubGluZTogaXNPbmxpbmUoKSxcbiAgICAgIGZvY3VzZWQ6IGlzRG9jdW1lbnRWaXNpYmxlKCksXG4gICAgICBtaWRkbGV3YXJlUmVnaXN0ZXJlZDogZmFsc2UsXG4gICAgICAuLi5jb25maWdcbiAgICB9LFxuICAgIHJlZHVjZXJzOiB7XG4gICAgICBtaWRkbGV3YXJlUmVnaXN0ZXJlZChzdGF0ZSwge1xuICAgICAgICBwYXlsb2FkXG4gICAgICB9KSB7XG4gICAgICAgIHN0YXRlLm1pZGRsZXdhcmVSZWdpc3RlcmVkID0gc3RhdGUubWlkZGxld2FyZVJlZ2lzdGVyZWQgPT09IFwiY29uZmxpY3RcIiB8fCBhcGlVaWQgIT09IHBheWxvYWQgPyBcImNvbmZsaWN0XCIgOiB0cnVlO1xuICAgICAgfVxuICAgIH0sXG4gICAgZXh0cmFSZWR1Y2VyczogKGJ1aWxkZXIpID0+IHtcbiAgICAgIGJ1aWxkZXIuYWRkQ2FzZShvbk9ubGluZSwgKHN0YXRlKSA9PiB7XG4gICAgICAgIHN0YXRlLm9ubGluZSA9IHRydWU7XG4gICAgICB9KS5hZGRDYXNlKG9uT2ZmbGluZSwgKHN0YXRlKSA9PiB7XG4gICAgICAgIHN0YXRlLm9ubGluZSA9IGZhbHNlO1xuICAgICAgfSkuYWRkQ2FzZShvbkZvY3VzLCAoc3RhdGUpID0+IHtcbiAgICAgICAgc3RhdGUuZm9jdXNlZCA9IHRydWU7XG4gICAgICB9KS5hZGRDYXNlKG9uRm9jdXNMb3N0LCAoc3RhdGUpID0+IHtcbiAgICAgICAgc3RhdGUuZm9jdXNlZCA9IGZhbHNlO1xuICAgICAgfSkuYWRkTWF0Y2hlcihoYXNSZWh5ZHJhdGlvbkluZm8sIChkcmFmdCkgPT4gKHtcbiAgICAgICAgLi4uZHJhZnRcbiAgICAgIH0pKTtcbiAgICB9XG4gIH0pO1xuICBjb25zdCBjb21iaW5lZFJlZHVjZXIgPSBjb21iaW5lUmVkdWNlcnMoe1xuICAgIHF1ZXJpZXM6IHF1ZXJ5U2xpY2UucmVkdWNlcixcbiAgICBtdXRhdGlvbnM6IG11dGF0aW9uU2xpY2UucmVkdWNlcixcbiAgICBwcm92aWRlZDogaW52YWxpZGF0aW9uU2xpY2UucmVkdWNlcixcbiAgICBzdWJzY3JpcHRpb25zOiBpbnRlcm5hbFN1YnNjcmlwdGlvbnNTbGljZS5yZWR1Y2VyLFxuICAgIGNvbmZpZzogY29uZmlnU2xpY2UucmVkdWNlclxuICB9KTtcbiAgY29uc3QgcmVkdWNlciA9IChzdGF0ZSwgYWN0aW9uKSA9PiBjb21iaW5lZFJlZHVjZXIocmVzZXRBcGlTdGF0ZS5tYXRjaChhY3Rpb24pID8gdm9pZCAwIDogc3RhdGUsIGFjdGlvbik7XG4gIGNvbnN0IGFjdGlvbnMgPSB7XG4gICAgLi4uY29uZmlnU2xpY2UuYWN0aW9ucyxcbiAgICAuLi5xdWVyeVNsaWNlLmFjdGlvbnMsXG4gICAgLi4uc3Vic2NyaXB0aW9uU2xpY2UuYWN0aW9ucyxcbiAgICAuLi5pbnRlcm5hbFN1YnNjcmlwdGlvbnNTbGljZS5hY3Rpb25zLFxuICAgIC4uLm11dGF0aW9uU2xpY2UuYWN0aW9ucyxcbiAgICAuLi5pbnZhbGlkYXRpb25TbGljZS5hY3Rpb25zLFxuICAgIHJlc2V0QXBpU3RhdGVcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICByZWR1Y2VyLFxuICAgIGFjdGlvbnNcbiAgfTtcbn1cblxuLy8gc3JjL3F1ZXJ5L2NvcmUvYnVpbGRTZWxlY3RvcnMudHNcbnZhciBza2lwVG9rZW4gPSAvKiBAX19QVVJFX18gKi8gU3ltYm9sLmZvcihcIlJUS1Evc2tpcFRva2VuXCIpO1xudmFyIGluaXRpYWxTdWJTdGF0ZSA9IHtcbiAgc3RhdHVzOiBcInVuaW5pdGlhbGl6ZWRcIiAvKiB1bmluaXRpYWxpemVkICovXG59O1xudmFyIGRlZmF1bHRRdWVyeVN1YlN0YXRlID0gLyogQF9fUFVSRV9fICovIGNyZWF0ZU5leHRTdGF0ZShpbml0aWFsU3ViU3RhdGUsICgpID0+IHtcbn0pO1xudmFyIGRlZmF1bHRNdXRhdGlvblN1YlN0YXRlID0gLyogQF9fUFVSRV9fICovIGNyZWF0ZU5leHRTdGF0ZShpbml0aWFsU3ViU3RhdGUsICgpID0+IHtcbn0pO1xuZnVuY3Rpb24gYnVpbGRTZWxlY3RvcnMoe1xuICBzZXJpYWxpemVRdWVyeUFyZ3MsXG4gIHJlZHVjZXJQYXRoLFxuICBjcmVhdGVTZWxlY3RvcjogY3JlYXRlU2VsZWN0b3IyXG59KSB7XG4gIGNvbnN0IHNlbGVjdFNraXBwZWRRdWVyeSA9IChzdGF0ZSkgPT4gZGVmYXVsdFF1ZXJ5U3ViU3RhdGU7XG4gIGNvbnN0IHNlbGVjdFNraXBwZWRNdXRhdGlvbiA9IChzdGF0ZSkgPT4gZGVmYXVsdE11dGF0aW9uU3ViU3RhdGU7XG4gIHJldHVybiB7XG4gICAgYnVpbGRRdWVyeVNlbGVjdG9yLFxuICAgIGJ1aWxkTXV0YXRpb25TZWxlY3RvcixcbiAgICBzZWxlY3RJbnZhbGlkYXRlZEJ5LFxuICAgIHNlbGVjdENhY2hlZEFyZ3NGb3JRdWVyeVxuICB9O1xuICBmdW5jdGlvbiB3aXRoUmVxdWVzdEZsYWdzKHN1YnN0YXRlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnN1YnN0YXRlLFxuICAgICAgLi4uZ2V0UmVxdWVzdFN0YXR1c0ZsYWdzKHN1YnN0YXRlLnN0YXR1cylcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIHNlbGVjdEludGVybmFsU3RhdGUocm9vdFN0YXRlKSB7XG4gICAgY29uc3Qgc3RhdGUgPSByb290U3RhdGVbcmVkdWNlclBhdGhdO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIGlmICghc3RhdGUpIHtcbiAgICAgICAgaWYgKHNlbGVjdEludGVybmFsU3RhdGUudHJpZ2dlcmVkKSByZXR1cm4gc3RhdGU7XG4gICAgICAgIHNlbGVjdEludGVybmFsU3RhdGUudHJpZ2dlcmVkID0gdHJ1ZTtcbiAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3I6IE5vIGRhdGEgZm91bmQgYXQgXFxgc3RhdGUuJHtyZWR1Y2VyUGF0aH1cXGAuIERpZCB5b3UgZm9yZ2V0IHRvIGFkZCB0aGUgcmVkdWNlciB0byB0aGUgc3RvcmU/YCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxuICBmdW5jdGlvbiBidWlsZFF1ZXJ5U2VsZWN0b3IoZW5kcG9pbnROYW1lLCBlbmRwb2ludERlZmluaXRpb24pIHtcbiAgICByZXR1cm4gKHF1ZXJ5QXJncykgPT4ge1xuICAgICAgY29uc3Qgc2VyaWFsaXplZEFyZ3MgPSBzZXJpYWxpemVRdWVyeUFyZ3Moe1xuICAgICAgICBxdWVyeUFyZ3MsXG4gICAgICAgIGVuZHBvaW50RGVmaW5pdGlvbixcbiAgICAgICAgZW5kcG9pbnROYW1lXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHNlbGVjdFF1ZXJ5U3Vic3RhdGUgPSAoc3RhdGUpID0+IHNlbGVjdEludGVybmFsU3RhdGUoc3RhdGUpPy5xdWVyaWVzPy5bc2VyaWFsaXplZEFyZ3NdID8/IGRlZmF1bHRRdWVyeVN1YlN0YXRlO1xuICAgICAgY29uc3QgZmluYWxTZWxlY3RRdWVyeVN1YlN0YXRlID0gcXVlcnlBcmdzID09PSBza2lwVG9rZW4gPyBzZWxlY3RTa2lwcGVkUXVlcnkgOiBzZWxlY3RRdWVyeVN1YnN0YXRlO1xuICAgICAgcmV0dXJuIGNyZWF0ZVNlbGVjdG9yMihmaW5hbFNlbGVjdFF1ZXJ5U3ViU3RhdGUsIHdpdGhSZXF1ZXN0RmxhZ3MpO1xuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gYnVpbGRNdXRhdGlvblNlbGVjdG9yKCkge1xuICAgIHJldHVybiAoaWQpID0+IHtcbiAgICAgIGxldCBtdXRhdGlvbklkO1xuICAgICAgaWYgKHR5cGVvZiBpZCA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICBtdXRhdGlvbklkID0gZ2V0TXV0YXRpb25DYWNoZUtleShpZCkgPz8gc2tpcFRva2VuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbXV0YXRpb25JZCA9IGlkO1xuICAgICAgfVxuICAgICAgY29uc3Qgc2VsZWN0TXV0YXRpb25TdWJzdGF0ZSA9IChzdGF0ZSkgPT4gc2VsZWN0SW50ZXJuYWxTdGF0ZShzdGF0ZSk/Lm11dGF0aW9ucz8uW211dGF0aW9uSWRdID8/IGRlZmF1bHRNdXRhdGlvblN1YlN0YXRlO1xuICAgICAgY29uc3QgZmluYWxTZWxlY3RNdXRhdGlvblN1YnN0YXRlID0gbXV0YXRpb25JZCA9PT0gc2tpcFRva2VuID8gc2VsZWN0U2tpcHBlZE11dGF0aW9uIDogc2VsZWN0TXV0YXRpb25TdWJzdGF0ZTtcbiAgICAgIHJldHVybiBjcmVhdGVTZWxlY3RvcjIoZmluYWxTZWxlY3RNdXRhdGlvblN1YnN0YXRlLCB3aXRoUmVxdWVzdEZsYWdzKTtcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIHNlbGVjdEludmFsaWRhdGVkQnkoc3RhdGUsIHRhZ3MpIHtcbiAgICBjb25zdCBhcGlTdGF0ZSA9IHN0YXRlW3JlZHVjZXJQYXRoXTtcbiAgICBjb25zdCB0b0ludmFsaWRhdGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIGZvciAoY29uc3QgdGFnIG9mIHRhZ3MubWFwKGV4cGFuZFRhZ0Rlc2NyaXB0aW9uKSkge1xuICAgICAgY29uc3QgcHJvdmlkZWQgPSBhcGlTdGF0ZS5wcm92aWRlZFt0YWcudHlwZV07XG4gICAgICBpZiAoIXByb3ZpZGVkKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgbGV0IGludmFsaWRhdGVTdWJzY3JpcHRpb25zID0gKHRhZy5pZCAhPT0gdm9pZCAwID8gKFxuICAgICAgICAvLyBpZCBnaXZlbjogaW52YWxpZGF0ZSBhbGwgcXVlcmllcyB0aGF0IHByb3ZpZGUgdGhpcyB0eXBlICYgaWRcbiAgICAgICAgcHJvdmlkZWRbdGFnLmlkXVxuICAgICAgKSA6IChcbiAgICAgICAgLy8gbm8gaWQ6IGludmFsaWRhdGUgYWxsIHF1ZXJpZXMgdGhhdCBwcm92aWRlIHRoaXMgdHlwZVxuICAgICAgICBmbGF0dGVuKE9iamVjdC52YWx1ZXMocHJvdmlkZWQpKVxuICAgICAgKSkgPz8gW107XG4gICAgICBmb3IgKGNvbnN0IGludmFsaWRhdGUgb2YgaW52YWxpZGF0ZVN1YnNjcmlwdGlvbnMpIHtcbiAgICAgICAgdG9JbnZhbGlkYXRlLmFkZChpbnZhbGlkYXRlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZsYXR0ZW4oQXJyYXkuZnJvbSh0b0ludmFsaWRhdGUudmFsdWVzKCkpLm1hcCgocXVlcnlDYWNoZUtleSkgPT4ge1xuICAgICAgY29uc3QgcXVlcnlTdWJTdGF0ZSA9IGFwaVN0YXRlLnF1ZXJpZXNbcXVlcnlDYWNoZUtleV07XG4gICAgICByZXR1cm4gcXVlcnlTdWJTdGF0ZSA/IFt7XG4gICAgICAgIHF1ZXJ5Q2FjaGVLZXksXG4gICAgICAgIGVuZHBvaW50TmFtZTogcXVlcnlTdWJTdGF0ZS5lbmRwb2ludE5hbWUsXG4gICAgICAgIG9yaWdpbmFsQXJnczogcXVlcnlTdWJTdGF0ZS5vcmlnaW5hbEFyZ3NcbiAgICAgIH1dIDogW107XG4gICAgfSkpO1xuICB9XG4gIGZ1bmN0aW9uIHNlbGVjdENhY2hlZEFyZ3NGb3JRdWVyeShzdGF0ZSwgcXVlcnlOYW1lKSB7XG4gICAgcmV0dXJuIE9iamVjdC52YWx1ZXMoc3RhdGVbcmVkdWNlclBhdGhdLnF1ZXJpZXMpLmZpbHRlcigoZW50cnkpID0+IGVudHJ5Py5lbmRwb2ludE5hbWUgPT09IHF1ZXJ5TmFtZSAmJiBlbnRyeS5zdGF0dXMgIT09IFwidW5pbml0aWFsaXplZFwiIC8qIHVuaW5pdGlhbGl6ZWQgKi8pLm1hcCgoZW50cnkpID0+IGVudHJ5Lm9yaWdpbmFsQXJncyk7XG4gIH1cbn1cblxuLy8gc3JjL3F1ZXJ5L2NyZWF0ZUFwaS50c1xuaW1wb3J0IHsgZm9ybWF0UHJvZEVycm9yTWVzc2FnZSBhcyBfZm9ybWF0UHJvZEVycm9yTWVzc2FnZTIgfSBmcm9tIFwiQHJlZHV4anMvdG9vbGtpdFwiO1xuXG4vLyBzcmMvcXVlcnkvZGVmYXVsdFNlcmlhbGl6ZVF1ZXJ5QXJncy50c1xudmFyIGNhY2hlID0gV2Vha01hcCA/IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpIDogdm9pZCAwO1xudmFyIGRlZmF1bHRTZXJpYWxpemVRdWVyeUFyZ3MgPSAoe1xuICBlbmRwb2ludE5hbWUsXG4gIHF1ZXJ5QXJnc1xufSkgPT4ge1xuICBsZXQgc2VyaWFsaXplZCA9IFwiXCI7XG4gIGNvbnN0IGNhY2hlZCA9IGNhY2hlPy5nZXQocXVlcnlBcmdzKTtcbiAgaWYgKHR5cGVvZiBjYWNoZWQgPT09IFwic3RyaW5nXCIpIHtcbiAgICBzZXJpYWxpemVkID0gY2FjaGVkO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IHN0cmluZ2lmaWVkID0gSlNPTi5zdHJpbmdpZnkocXVlcnlBcmdzLCAoa2V5LCB2YWx1ZSkgPT4ge1xuICAgICAgdmFsdWUgPSB0eXBlb2YgdmFsdWUgPT09IFwiYmlnaW50XCIgPyB7XG4gICAgICAgICRiaWdpbnQ6IHZhbHVlLnRvU3RyaW5nKClcbiAgICAgIH0gOiB2YWx1ZTtcbiAgICAgIHZhbHVlID0gaXNQbGFpbk9iamVjdCh2YWx1ZSkgPyBPYmplY3Qua2V5cyh2YWx1ZSkuc29ydCgpLnJlZHVjZSgoYWNjLCBrZXkyKSA9PiB7XG4gICAgICAgIGFjY1trZXkyXSA9IHZhbHVlW2tleTJdO1xuICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgfSwge30pIDogdmFsdWU7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSk7XG4gICAgaWYgKGlzUGxhaW5PYmplY3QocXVlcnlBcmdzKSkge1xuICAgICAgY2FjaGU/LnNldChxdWVyeUFyZ3MsIHN0cmluZ2lmaWVkKTtcbiAgICB9XG4gICAgc2VyaWFsaXplZCA9IHN0cmluZ2lmaWVkO1xuICB9XG4gIHJldHVybiBgJHtlbmRwb2ludE5hbWV9KCR7c2VyaWFsaXplZH0pYDtcbn07XG5cbi8vIHNyYy9xdWVyeS9jcmVhdGVBcGkudHNcbmltcG9ydCB7IHdlYWtNYXBNZW1vaXplIH0gZnJvbSBcInJlc2VsZWN0XCI7XG5mdW5jdGlvbiBidWlsZENyZWF0ZUFwaSguLi5tb2R1bGVzKSB7XG4gIHJldHVybiBmdW5jdGlvbiBiYXNlQ3JlYXRlQXBpKG9wdGlvbnMpIHtcbiAgICBjb25zdCBleHRyYWN0UmVoeWRyYXRpb25JbmZvID0gd2Vha01hcE1lbW9pemUoKGFjdGlvbikgPT4gb3B0aW9ucy5leHRyYWN0UmVoeWRyYXRpb25JbmZvPy4oYWN0aW9uLCB7XG4gICAgICByZWR1Y2VyUGF0aDogb3B0aW9ucy5yZWR1Y2VyUGF0aCA/PyBcImFwaVwiXG4gICAgfSkpO1xuICAgIGNvbnN0IG9wdGlvbnNXaXRoRGVmYXVsdHMgPSB7XG4gICAgICByZWR1Y2VyUGF0aDogXCJhcGlcIixcbiAgICAgIGtlZXBVbnVzZWREYXRhRm9yOiA2MCxcbiAgICAgIHJlZmV0Y2hPbk1vdW50T3JBcmdDaGFuZ2U6IGZhbHNlLFxuICAgICAgcmVmZXRjaE9uRm9jdXM6IGZhbHNlLFxuICAgICAgcmVmZXRjaE9uUmVjb25uZWN0OiBmYWxzZSxcbiAgICAgIGludmFsaWRhdGlvbkJlaGF2aW9yOiBcImRlbGF5ZWRcIixcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICBleHRyYWN0UmVoeWRyYXRpb25JbmZvLFxuICAgICAgc2VyaWFsaXplUXVlcnlBcmdzKHF1ZXJ5QXJnc0FwaSkge1xuICAgICAgICBsZXQgZmluYWxTZXJpYWxpemVRdWVyeUFyZ3MgPSBkZWZhdWx0U2VyaWFsaXplUXVlcnlBcmdzO1xuICAgICAgICBpZiAoXCJzZXJpYWxpemVRdWVyeUFyZ3NcIiBpbiBxdWVyeUFyZ3NBcGkuZW5kcG9pbnREZWZpbml0aW9uKSB7XG4gICAgICAgICAgY29uc3QgZW5kcG9pbnRTUUEgPSBxdWVyeUFyZ3NBcGkuZW5kcG9pbnREZWZpbml0aW9uLnNlcmlhbGl6ZVF1ZXJ5QXJncztcbiAgICAgICAgICBmaW5hbFNlcmlhbGl6ZVF1ZXJ5QXJncyA9IChxdWVyeUFyZ3NBcGkyKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBpbml0aWFsUmVzdWx0ID0gZW5kcG9pbnRTUUEocXVlcnlBcmdzQXBpMik7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGluaXRpYWxSZXN1bHQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGluaXRpYWxSZXN1bHQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gZGVmYXVsdFNlcmlhbGl6ZVF1ZXJ5QXJncyh7XG4gICAgICAgICAgICAgICAgLi4ucXVlcnlBcmdzQXBpMixcbiAgICAgICAgICAgICAgICBxdWVyeUFyZ3M6IGluaXRpYWxSZXN1bHRcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmIChvcHRpb25zLnNlcmlhbGl6ZVF1ZXJ5QXJncykge1xuICAgICAgICAgIGZpbmFsU2VyaWFsaXplUXVlcnlBcmdzID0gb3B0aW9ucy5zZXJpYWxpemVRdWVyeUFyZ3M7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZpbmFsU2VyaWFsaXplUXVlcnlBcmdzKHF1ZXJ5QXJnc0FwaSk7XG4gICAgICB9LFxuICAgICAgdGFnVHlwZXM6IFsuLi5vcHRpb25zLnRhZ1R5cGVzIHx8IFtdXVxuICAgIH07XG4gICAgY29uc3QgY29udGV4dCA9IHtcbiAgICAgIGVuZHBvaW50RGVmaW5pdGlvbnM6IHt9LFxuICAgICAgYmF0Y2goZm4pIHtcbiAgICAgICAgZm4oKTtcbiAgICAgIH0sXG4gICAgICBhcGlVaWQ6IG5hbm9pZCgpLFxuICAgICAgZXh0cmFjdFJlaHlkcmF0aW9uSW5mbyxcbiAgICAgIGhhc1JlaHlkcmF0aW9uSW5mbzogd2Vha01hcE1lbW9pemUoKGFjdGlvbikgPT4gZXh0cmFjdFJlaHlkcmF0aW9uSW5mbyhhY3Rpb24pICE9IG51bGwpXG4gICAgfTtcbiAgICBjb25zdCBhcGkgPSB7XG4gICAgICBpbmplY3RFbmRwb2ludHMsXG4gICAgICBlbmhhbmNlRW5kcG9pbnRzKHtcbiAgICAgICAgYWRkVGFnVHlwZXMsXG4gICAgICAgIGVuZHBvaW50c1xuICAgICAgfSkge1xuICAgICAgICBpZiAoYWRkVGFnVHlwZXMpIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IGVUIG9mIGFkZFRhZ1R5cGVzKSB7XG4gICAgICAgICAgICBpZiAoIW9wdGlvbnNXaXRoRGVmYXVsdHMudGFnVHlwZXMuaW5jbHVkZXMoZVQpKSB7XG4gICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgb3B0aW9uc1dpdGhEZWZhdWx0cy50YWdUeXBlcy5wdXNoKGVUKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVuZHBvaW50cykge1xuICAgICAgICAgIGZvciAoY29uc3QgW2VuZHBvaW50TmFtZSwgcGFydGlhbERlZmluaXRpb25dIG9mIE9iamVjdC5lbnRyaWVzKGVuZHBvaW50cykpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcGFydGlhbERlZmluaXRpb24gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICBwYXJ0aWFsRGVmaW5pdGlvbihjb250ZXh0LmVuZHBvaW50RGVmaW5pdGlvbnNbZW5kcG9pbnROYW1lXSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKGNvbnRleHQuZW5kcG9pbnREZWZpbml0aW9uc1tlbmRwb2ludE5hbWVdIHx8IHt9LCBwYXJ0aWFsRGVmaW5pdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcGk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBpbml0aWFsaXplZE1vZHVsZXMgPSBtb2R1bGVzLm1hcCgobSkgPT4gbS5pbml0KGFwaSwgb3B0aW9uc1dpdGhEZWZhdWx0cywgY29udGV4dCkpO1xuICAgIGZ1bmN0aW9uIGluamVjdEVuZHBvaW50cyhpbmplY3QpIHtcbiAgICAgIGNvbnN0IGV2YWx1YXRlZEVuZHBvaW50cyA9IGluamVjdC5lbmRwb2ludHMoe1xuICAgICAgICBxdWVyeTogKHgpID0+ICh7XG4gICAgICAgICAgLi4ueCxcbiAgICAgICAgICB0eXBlOiBcInF1ZXJ5XCIgLyogcXVlcnkgKi9cbiAgICAgICAgfSksXG4gICAgICAgIG11dGF0aW9uOiAoeCkgPT4gKHtcbiAgICAgICAgICAuLi54LFxuICAgICAgICAgIHR5cGU6IFwibXV0YXRpb25cIiAvKiBtdXRhdGlvbiAqL1xuICAgICAgICB9KVxuICAgICAgfSk7XG4gICAgICBmb3IgKGNvbnN0IFtlbmRwb2ludE5hbWUsIGRlZmluaXRpb25dIG9mIE9iamVjdC5lbnRyaWVzKGV2YWx1YXRlZEVuZHBvaW50cykpIHtcbiAgICAgICAgaWYgKGluamVjdC5vdmVycmlkZUV4aXN0aW5nICE9PSB0cnVlICYmIGVuZHBvaW50TmFtZSBpbiBjb250ZXh0LmVuZHBvaW50RGVmaW5pdGlvbnMpIHtcbiAgICAgICAgICBpZiAoaW5qZWN0Lm92ZXJyaWRlRXhpc3RpbmcgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IF9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlMigzOSkgOiBgY2FsbGVkIFxcYGluamVjdEVuZHBvaW50c1xcYCB0byBvdmVycmlkZSBhbHJlYWR5LWV4aXN0aW5nIGVuZHBvaW50TmFtZSAke2VuZHBvaW50TmFtZX0gd2l0aG91dCBzcGVjaWZ5aW5nIFxcYG92ZXJyaWRlRXhpc3Rpbmc6IHRydWVcXGBgKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBwcm9jZXNzICE9PSBcInVuZGVmaW5lZFwiICYmIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcImRldmVsb3BtZW50XCIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYGNhbGxlZCBcXGBpbmplY3RFbmRwb2ludHNcXGAgdG8gb3ZlcnJpZGUgYWxyZWFkeS1leGlzdGluZyBlbmRwb2ludE5hbWUgJHtlbmRwb2ludE5hbWV9IHdpdGhvdXQgc3BlY2lmeWluZyBcXGBvdmVycmlkZUV4aXN0aW5nOiB0cnVlXFxgYCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRleHQuZW5kcG9pbnREZWZpbml0aW9uc1tlbmRwb2ludE5hbWVdID0gZGVmaW5pdGlvbjtcbiAgICAgICAgZm9yIChjb25zdCBtIG9mIGluaXRpYWxpemVkTW9kdWxlcykge1xuICAgICAgICAgIG0uaW5qZWN0RW5kcG9pbnQoZW5kcG9pbnROYW1lLCBkZWZpbml0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGFwaTtcbiAgICB9XG4gICAgcmV0dXJuIGFwaS5pbmplY3RFbmRwb2ludHMoe1xuICAgICAgZW5kcG9pbnRzOiBvcHRpb25zLmVuZHBvaW50c1xuICAgIH0pO1xuICB9O1xufVxuXG4vLyBzcmMvcXVlcnkvZmFrZUJhc2VRdWVyeS50c1xuaW1wb3J0IHsgZm9ybWF0UHJvZEVycm9yTWVzc2FnZSBhcyBfZm9ybWF0UHJvZEVycm9yTWVzc2FnZTMgfSBmcm9tIFwiQHJlZHV4anMvdG9vbGtpdFwiO1xudmFyIF9ORVZFUiA9IC8qIEBfX1BVUkVfXyAqLyBTeW1ib2woKTtcbmZ1bmN0aW9uIGZha2VCYXNlUXVlcnkoKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gX2Zvcm1hdFByb2RFcnJvck1lc3NhZ2UzKDMzKSA6IFwiV2hlbiB1c2luZyBgZmFrZUJhc2VRdWVyeWAsIGFsbCBxdWVyaWVzICYgbXV0YXRpb25zIG11c3QgdXNlIHRoZSBgcXVlcnlGbmAgZGVmaW5pdGlvbiBzeW50YXguXCIpO1xuICB9O1xufVxuXG4vLyBzcmMvcXVlcnkvY29yZS9tb2R1bGUudHNcbmltcG9ydCB7IGVuYWJsZVBhdGNoZXMgfSBmcm9tIFwiaW1tZXJcIjtcblxuLy8gc3JjL3F1ZXJ5L3RzSGVscGVycy50c1xuZnVuY3Rpb24gYXNzZXJ0Q2FzdCh2KSB7XG59XG5mdW5jdGlvbiBzYWZlQXNzaWduKHRhcmdldCwgLi4uYXJncykge1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbih0YXJnZXQsIC4uLmFyZ3MpO1xufVxuXG4vLyBzcmMvcXVlcnkvY29yZS9idWlsZE1pZGRsZXdhcmUvYmF0Y2hBY3Rpb25zLnRzXG5pbXBvcnQgeyBwcm9kdWNlV2l0aFBhdGNoZXMgYXMgcHJvZHVjZVdpdGhQYXRjaGVzMiB9IGZyb20gXCJpbW1lclwiO1xudmFyIGJ1aWxkQmF0Y2hlZEFjdGlvbnNIYW5kbGVyID0gKHtcbiAgYXBpLFxuICBxdWVyeVRodW5rLFxuICBpbnRlcm5hbFN0YXRlXG59KSA9PiB7XG4gIGNvbnN0IHN1YnNjcmlwdGlvbnNQcmVmaXggPSBgJHthcGkucmVkdWNlclBhdGh9L3N1YnNjcmlwdGlvbnNgO1xuICBsZXQgcHJldmlvdXNTdWJzY3JpcHRpb25zID0gbnVsbDtcbiAgbGV0IHVwZGF0ZVN5bmNUaW1lciA9IG51bGw7XG4gIGNvbnN0IHtcbiAgICB1cGRhdGVTdWJzY3JpcHRpb25PcHRpb25zLFxuICAgIHVuc3Vic2NyaWJlUXVlcnlSZXN1bHRcbiAgfSA9IGFwaS5pbnRlcm5hbEFjdGlvbnM7XG4gIGNvbnN0IGFjdHVhbGx5TXV0YXRlU3Vic2NyaXB0aW9ucyA9IChtdXRhYmxlU3RhdGUsIGFjdGlvbikgPT4ge1xuICAgIGlmICh1cGRhdGVTdWJzY3JpcHRpb25PcHRpb25zLm1hdGNoKGFjdGlvbikpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcXVlcnlDYWNoZUtleSxcbiAgICAgICAgcmVxdWVzdElkLFxuICAgICAgICBvcHRpb25zXG4gICAgICB9ID0gYWN0aW9uLnBheWxvYWQ7XG4gICAgICBpZiAobXV0YWJsZVN0YXRlPy5bcXVlcnlDYWNoZUtleV0/LltyZXF1ZXN0SWRdKSB7XG4gICAgICAgIG11dGFibGVTdGF0ZVtxdWVyeUNhY2hlS2V5XVtyZXF1ZXN0SWRdID0gb3B0aW9ucztcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAodW5zdWJzY3JpYmVRdWVyeVJlc3VsdC5tYXRjaChhY3Rpb24pKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHF1ZXJ5Q2FjaGVLZXksXG4gICAgICAgIHJlcXVlc3RJZFxuICAgICAgfSA9IGFjdGlvbi5wYXlsb2FkO1xuICAgICAgaWYgKG11dGFibGVTdGF0ZVtxdWVyeUNhY2hlS2V5XSkge1xuICAgICAgICBkZWxldGUgbXV0YWJsZVN0YXRlW3F1ZXJ5Q2FjaGVLZXldW3JlcXVlc3RJZF07XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGFwaS5pbnRlcm5hbEFjdGlvbnMucmVtb3ZlUXVlcnlSZXN1bHQubWF0Y2goYWN0aW9uKSkge1xuICAgICAgZGVsZXRlIG11dGFibGVTdGF0ZVthY3Rpb24ucGF5bG9hZC5xdWVyeUNhY2hlS2V5XTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAocXVlcnlUaHVuay5wZW5kaW5nLm1hdGNoKGFjdGlvbikpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgbWV0YToge1xuICAgICAgICAgIGFyZyxcbiAgICAgICAgICByZXF1ZXN0SWRcbiAgICAgICAgfVxuICAgICAgfSA9IGFjdGlvbjtcbiAgICAgIGNvbnN0IHN1YnN0YXRlID0gbXV0YWJsZVN0YXRlW2FyZy5xdWVyeUNhY2hlS2V5XSA/Pz0ge307XG4gICAgICBzdWJzdGF0ZVtgJHtyZXF1ZXN0SWR9X3J1bm5pbmdgXSA9IHt9O1xuICAgICAgaWYgKGFyZy5zdWJzY3JpYmUpIHtcbiAgICAgICAgc3Vic3RhdGVbcmVxdWVzdElkXSA9IGFyZy5zdWJzY3JpcHRpb25PcHRpb25zID8/IHN1YnN0YXRlW3JlcXVlc3RJZF0gPz8ge307XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgbGV0IG11dGF0ZWQgPSBmYWxzZTtcbiAgICBpZiAocXVlcnlUaHVuay5mdWxmaWxsZWQubWF0Y2goYWN0aW9uKSB8fCBxdWVyeVRodW5rLnJlamVjdGVkLm1hdGNoKGFjdGlvbikpIHtcbiAgICAgIGNvbnN0IHN0YXRlID0gbXV0YWJsZVN0YXRlW2FjdGlvbi5tZXRhLmFyZy5xdWVyeUNhY2hlS2V5XSB8fCB7fTtcbiAgICAgIGNvbnN0IGtleSA9IGAke2FjdGlvbi5tZXRhLnJlcXVlc3RJZH1fcnVubmluZ2A7XG4gICAgICBtdXRhdGVkIHx8PSAhIXN0YXRlW2tleV07XG4gICAgICBkZWxldGUgc3RhdGVba2V5XTtcbiAgICB9XG4gICAgaWYgKHF1ZXJ5VGh1bmsucmVqZWN0ZWQubWF0Y2goYWN0aW9uKSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBtZXRhOiB7XG4gICAgICAgICAgY29uZGl0aW9uLFxuICAgICAgICAgIGFyZyxcbiAgICAgICAgICByZXF1ZXN0SWRcbiAgICAgICAgfVxuICAgICAgfSA9IGFjdGlvbjtcbiAgICAgIGlmIChjb25kaXRpb24gJiYgYXJnLnN1YnNjcmliZSkge1xuICAgICAgICBjb25zdCBzdWJzdGF0ZSA9IG11dGFibGVTdGF0ZVthcmcucXVlcnlDYWNoZUtleV0gPz89IHt9O1xuICAgICAgICBzdWJzdGF0ZVtyZXF1ZXN0SWRdID0gYXJnLnN1YnNjcmlwdGlvbk9wdGlvbnMgPz8gc3Vic3RhdGVbcmVxdWVzdElkXSA/PyB7fTtcbiAgICAgICAgbXV0YXRlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtdXRhdGVkO1xuICB9O1xuICBjb25zdCBnZXRTdWJzY3JpcHRpb25zID0gKCkgPT4gaW50ZXJuYWxTdGF0ZS5jdXJyZW50U3Vic2NyaXB0aW9ucztcbiAgY29uc3QgZ2V0U3Vic2NyaXB0aW9uQ291bnQgPSAocXVlcnlDYWNoZUtleSkgPT4ge1xuICAgIGNvbnN0IHN1YnNjcmlwdGlvbnMgPSBnZXRTdWJzY3JpcHRpb25zKCk7XG4gICAgY29uc3Qgc3Vic2NyaXB0aW9uc0ZvclF1ZXJ5QXJnID0gc3Vic2NyaXB0aW9uc1txdWVyeUNhY2hlS2V5XSA/PyB7fTtcbiAgICByZXR1cm4gY291bnRPYmplY3RLZXlzKHN1YnNjcmlwdGlvbnNGb3JRdWVyeUFyZyk7XG4gIH07XG4gIGNvbnN0IGlzUmVxdWVzdFN1YnNjcmliZWQgPSAocXVlcnlDYWNoZUtleSwgcmVxdWVzdElkKSA9PiB7XG4gICAgY29uc3Qgc3Vic2NyaXB0aW9ucyA9IGdldFN1YnNjcmlwdGlvbnMoKTtcbiAgICByZXR1cm4gISFzdWJzY3JpcHRpb25zPy5bcXVlcnlDYWNoZUtleV0/LltyZXF1ZXN0SWRdO1xuICB9O1xuICBjb25zdCBzdWJzY3JpcHRpb25TZWxlY3RvcnMgPSB7XG4gICAgZ2V0U3Vic2NyaXB0aW9ucyxcbiAgICBnZXRTdWJzY3JpcHRpb25Db3VudCxcbiAgICBpc1JlcXVlc3RTdWJzY3JpYmVkXG4gIH07XG4gIHJldHVybiAoYWN0aW9uLCBtd0FwaSkgPT4ge1xuICAgIGlmICghcHJldmlvdXNTdWJzY3JpcHRpb25zKSB7XG4gICAgICBwcmV2aW91c1N1YnNjcmlwdGlvbnMgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGludGVybmFsU3RhdGUuY3VycmVudFN1YnNjcmlwdGlvbnMpKTtcbiAgICB9XG4gICAgaWYgKGFwaS51dGlsLnJlc2V0QXBpU3RhdGUubWF0Y2goYWN0aW9uKSkge1xuICAgICAgcHJldmlvdXNTdWJzY3JpcHRpb25zID0gaW50ZXJuYWxTdGF0ZS5jdXJyZW50U3Vic2NyaXB0aW9ucyA9IHt9O1xuICAgICAgdXBkYXRlU3luY1RpbWVyID0gbnVsbDtcbiAgICAgIHJldHVybiBbdHJ1ZSwgZmFsc2VdO1xuICAgIH1cbiAgICBpZiAoYXBpLmludGVybmFsQWN0aW9ucy5pbnRlcm5hbF9nZXRSVEtRU3Vic2NyaXB0aW9ucy5tYXRjaChhY3Rpb24pKSB7XG4gICAgICByZXR1cm4gW2ZhbHNlLCBzdWJzY3JpcHRpb25TZWxlY3RvcnNdO1xuICAgIH1cbiAgICBjb25zdCBkaWRNdXRhdGUgPSBhY3R1YWxseU11dGF0ZVN1YnNjcmlwdGlvbnMoaW50ZXJuYWxTdGF0ZS5jdXJyZW50U3Vic2NyaXB0aW9ucywgYWN0aW9uKTtcbiAgICBsZXQgYWN0aW9uU2hvdWxkQ29udGludWUgPSB0cnVlO1xuICAgIGlmIChkaWRNdXRhdGUpIHtcbiAgICAgIGlmICghdXBkYXRlU3luY1RpbWVyKSB7XG4gICAgICAgIHVwZGF0ZVN5bmNUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IG5ld1N1YnNjcmlwdGlvbnMgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGludGVybmFsU3RhdGUuY3VycmVudFN1YnNjcmlwdGlvbnMpKTtcbiAgICAgICAgICBjb25zdCBbLCBwYXRjaGVzXSA9IHByb2R1Y2VXaXRoUGF0Y2hlczIocHJldmlvdXNTdWJzY3JpcHRpb25zLCAoKSA9PiBuZXdTdWJzY3JpcHRpb25zKTtcbiAgICAgICAgICBtd0FwaS5uZXh0KGFwaS5pbnRlcm5hbEFjdGlvbnMuc3Vic2NyaXB0aW9uc1VwZGF0ZWQocGF0Y2hlcykpO1xuICAgICAgICAgIHByZXZpb3VzU3Vic2NyaXB0aW9ucyA9IG5ld1N1YnNjcmlwdGlvbnM7XG4gICAgICAgICAgdXBkYXRlU3luY1RpbWVyID0gbnVsbDtcbiAgICAgICAgfSwgNTAwKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGlzU3Vic2NyaXB0aW9uU2xpY2VBY3Rpb24gPSB0eXBlb2YgYWN0aW9uLnR5cGUgPT0gXCJzdHJpbmdcIiAmJiAhIWFjdGlvbi50eXBlLnN0YXJ0c1dpdGgoc3Vic2NyaXB0aW9uc1ByZWZpeCk7XG4gICAgICBjb25zdCBpc0FkZGl0aW9uYWxTdWJzY3JpcHRpb25BY3Rpb24gPSBxdWVyeVRodW5rLnJlamVjdGVkLm1hdGNoKGFjdGlvbikgJiYgYWN0aW9uLm1ldGEuY29uZGl0aW9uICYmICEhYWN0aW9uLm1ldGEuYXJnLnN1YnNjcmliZTtcbiAgICAgIGFjdGlvblNob3VsZENvbnRpbnVlID0gIWlzU3Vic2NyaXB0aW9uU2xpY2VBY3Rpb24gJiYgIWlzQWRkaXRpb25hbFN1YnNjcmlwdGlvbkFjdGlvbjtcbiAgICB9XG4gICAgcmV0dXJuIFthY3Rpb25TaG91bGRDb250aW51ZSwgZmFsc2VdO1xuICB9O1xufTtcblxuLy8gc3JjL3F1ZXJ5L2NvcmUvYnVpbGRNaWRkbGV3YXJlL2NhY2hlQ29sbGVjdGlvbi50c1xuZnVuY3Rpb24gaXNPYmplY3RFbXB0eShvYmopIHtcbiAgZm9yIChjb25zdCBrIGluIG9iaikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbnZhciBUSElSVFlfVFdPX0JJVF9NQVhfVElNRVJfU0VDT05EUyA9IDIxNDc0ODM2NDcgLyAxZTMgLSAxO1xudmFyIGJ1aWxkQ2FjaGVDb2xsZWN0aW9uSGFuZGxlciA9ICh7XG4gIHJlZHVjZXJQYXRoLFxuICBhcGksXG4gIHF1ZXJ5VGh1bmssXG4gIGNvbnRleHQsXG4gIGludGVybmFsU3RhdGVcbn0pID0+IHtcbiAgY29uc3Qge1xuICAgIHJlbW92ZVF1ZXJ5UmVzdWx0LFxuICAgIHVuc3Vic2NyaWJlUXVlcnlSZXN1bHRcbiAgfSA9IGFwaS5pbnRlcm5hbEFjdGlvbnM7XG4gIGNvbnN0IGNhblRyaWdnZXJVbnN1YnNjcmliZSA9IGlzQW55T2YodW5zdWJzY3JpYmVRdWVyeVJlc3VsdC5tYXRjaCwgcXVlcnlUaHVuay5mdWxmaWxsZWQsIHF1ZXJ5VGh1bmsucmVqZWN0ZWQpO1xuICBmdW5jdGlvbiBhbnlTdWJzY3JpcHRpb25zUmVtYWluaW5nRm9yS2V5KHF1ZXJ5Q2FjaGVLZXkpIHtcbiAgICBjb25zdCBzdWJzY3JpcHRpb25zID0gaW50ZXJuYWxTdGF0ZS5jdXJyZW50U3Vic2NyaXB0aW9uc1txdWVyeUNhY2hlS2V5XTtcbiAgICByZXR1cm4gISFzdWJzY3JpcHRpb25zICYmICFpc09iamVjdEVtcHR5KHN1YnNjcmlwdGlvbnMpO1xuICB9XG4gIGNvbnN0IGN1cnJlbnRSZW1vdmFsVGltZW91dHMgPSB7fTtcbiAgY29uc3QgaGFuZGxlciA9IChhY3Rpb24sIG13QXBpLCBpbnRlcm5hbFN0YXRlMikgPT4ge1xuICAgIGlmIChjYW5UcmlnZ2VyVW5zdWJzY3JpYmUoYWN0aW9uKSkge1xuICAgICAgY29uc3Qgc3RhdGUgPSBtd0FwaS5nZXRTdGF0ZSgpW3JlZHVjZXJQYXRoXTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcXVlcnlDYWNoZUtleVxuICAgICAgfSA9IHVuc3Vic2NyaWJlUXVlcnlSZXN1bHQubWF0Y2goYWN0aW9uKSA/IGFjdGlvbi5wYXlsb2FkIDogYWN0aW9uLm1ldGEuYXJnO1xuICAgICAgaGFuZGxlVW5zdWJzY3JpYmUocXVlcnlDYWNoZUtleSwgc3RhdGUucXVlcmllc1txdWVyeUNhY2hlS2V5XT8uZW5kcG9pbnROYW1lLCBtd0FwaSwgc3RhdGUuY29uZmlnKTtcbiAgICB9XG4gICAgaWYgKGFwaS51dGlsLnJlc2V0QXBpU3RhdGUubWF0Y2goYWN0aW9uKSkge1xuICAgICAgZm9yIChjb25zdCBba2V5LCB0aW1lb3V0XSBvZiBPYmplY3QuZW50cmllcyhjdXJyZW50UmVtb3ZhbFRpbWVvdXRzKSkge1xuICAgICAgICBpZiAodGltZW91dCkgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICBkZWxldGUgY3VycmVudFJlbW92YWxUaW1lb3V0c1trZXldO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoY29udGV4dC5oYXNSZWh5ZHJhdGlvbkluZm8oYWN0aW9uKSkge1xuICAgICAgY29uc3Qgc3RhdGUgPSBtd0FwaS5nZXRTdGF0ZSgpW3JlZHVjZXJQYXRoXTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcXVlcmllc1xuICAgICAgfSA9IGNvbnRleHQuZXh0cmFjdFJlaHlkcmF0aW9uSW5mbyhhY3Rpb24pO1xuICAgICAgZm9yIChjb25zdCBbcXVlcnlDYWNoZUtleSwgcXVlcnlTdGF0ZV0gb2YgT2JqZWN0LmVudHJpZXMocXVlcmllcykpIHtcbiAgICAgICAgaGFuZGxlVW5zdWJzY3JpYmUocXVlcnlDYWNoZUtleSwgcXVlcnlTdGF0ZT8uZW5kcG9pbnROYW1lLCBtd0FwaSwgc3RhdGUuY29uZmlnKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIGZ1bmN0aW9uIGhhbmRsZVVuc3Vic2NyaWJlKHF1ZXJ5Q2FjaGVLZXksIGVuZHBvaW50TmFtZSwgYXBpMiwgY29uZmlnKSB7XG4gICAgY29uc3QgZW5kcG9pbnREZWZpbml0aW9uID0gY29udGV4dC5lbmRwb2ludERlZmluaXRpb25zW2VuZHBvaW50TmFtZV07XG4gICAgY29uc3Qga2VlcFVudXNlZERhdGFGb3IgPSBlbmRwb2ludERlZmluaXRpb24/LmtlZXBVbnVzZWREYXRhRm9yID8/IGNvbmZpZy5rZWVwVW51c2VkRGF0YUZvcjtcbiAgICBpZiAoa2VlcFVudXNlZERhdGFGb3IgPT09IEluZmluaXR5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGZpbmFsS2VlcFVudXNlZERhdGFGb3IgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihrZWVwVW51c2VkRGF0YUZvciwgVEhJUlRZX1RXT19CSVRfTUFYX1RJTUVSX1NFQ09ORFMpKTtcbiAgICBpZiAoIWFueVN1YnNjcmlwdGlvbnNSZW1haW5pbmdGb3JLZXkocXVlcnlDYWNoZUtleSkpIHtcbiAgICAgIGNvbnN0IGN1cnJlbnRUaW1lb3V0ID0gY3VycmVudFJlbW92YWxUaW1lb3V0c1txdWVyeUNhY2hlS2V5XTtcbiAgICAgIGlmIChjdXJyZW50VGltZW91dCkge1xuICAgICAgICBjbGVhclRpbWVvdXQoY3VycmVudFRpbWVvdXQpO1xuICAgICAgfVxuICAgICAgY3VycmVudFJlbW92YWxUaW1lb3V0c1txdWVyeUNhY2hlS2V5XSA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBpZiAoIWFueVN1YnNjcmlwdGlvbnNSZW1haW5pbmdGb3JLZXkocXVlcnlDYWNoZUtleSkpIHtcbiAgICAgICAgICBhcGkyLmRpc3BhdGNoKHJlbW92ZVF1ZXJ5UmVzdWx0KHtcbiAgICAgICAgICAgIHF1ZXJ5Q2FjaGVLZXlcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgZGVsZXRlIGN1cnJlbnRSZW1vdmFsVGltZW91dHNbcXVlcnlDYWNoZUtleV07XG4gICAgICB9LCBmaW5hbEtlZXBVbnVzZWREYXRhRm9yICogMWUzKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGhhbmRsZXI7XG59O1xuXG4vLyBzcmMvcXVlcnkvY29yZS9idWlsZE1pZGRsZXdhcmUvY2FjaGVMaWZlY3ljbGUudHNcbnZhciBuZXZlclJlc29sdmVkRXJyb3IgPSBuZXcgRXJyb3IoXCJQcm9taXNlIG5ldmVyIHJlc29sdmVkIGJlZm9yZSBjYWNoZUVudHJ5UmVtb3ZlZC5cIik7XG52YXIgYnVpbGRDYWNoZUxpZmVjeWNsZUhhbmRsZXIgPSAoe1xuICBhcGksXG4gIHJlZHVjZXJQYXRoLFxuICBjb250ZXh0LFxuICBxdWVyeVRodW5rLFxuICBtdXRhdGlvblRodW5rLFxuICBpbnRlcm5hbFN0YXRlXG59KSA9PiB7XG4gIGNvbnN0IGlzUXVlcnlUaHVuayA9IGlzQXN5bmNUaHVua0FjdGlvbihxdWVyeVRodW5rKTtcbiAgY29uc3QgaXNNdXRhdGlvblRodW5rID0gaXNBc3luY1RodW5rQWN0aW9uKG11dGF0aW9uVGh1bmspO1xuICBjb25zdCBpc0Z1bGZpbGxlZFRodW5rID0gaXNGdWxmaWxsZWQocXVlcnlUaHVuaywgbXV0YXRpb25UaHVuayk7XG4gIGNvbnN0IGxpZmVjeWNsZU1hcCA9IHt9O1xuICBjb25zdCBoYW5kbGVyID0gKGFjdGlvbiwgbXdBcGksIHN0YXRlQmVmb3JlKSA9PiB7XG4gICAgY29uc3QgY2FjaGVLZXkgPSBnZXRDYWNoZUtleShhY3Rpb24pO1xuICAgIGlmIChxdWVyeVRodW5rLnBlbmRpbmcubWF0Y2goYWN0aW9uKSkge1xuICAgICAgY29uc3Qgb2xkU3RhdGUgPSBzdGF0ZUJlZm9yZVtyZWR1Y2VyUGF0aF0ucXVlcmllc1tjYWNoZUtleV07XG4gICAgICBjb25zdCBzdGF0ZSA9IG13QXBpLmdldFN0YXRlKClbcmVkdWNlclBhdGhdLnF1ZXJpZXNbY2FjaGVLZXldO1xuICAgICAgaWYgKCFvbGRTdGF0ZSAmJiBzdGF0ZSkge1xuICAgICAgICBoYW5kbGVOZXdLZXkoYWN0aW9uLm1ldGEuYXJnLmVuZHBvaW50TmFtZSwgYWN0aW9uLm1ldGEuYXJnLm9yaWdpbmFsQXJncywgY2FjaGVLZXksIG13QXBpLCBhY3Rpb24ubWV0YS5yZXF1ZXN0SWQpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobXV0YXRpb25UaHVuay5wZW5kaW5nLm1hdGNoKGFjdGlvbikpIHtcbiAgICAgIGNvbnN0IHN0YXRlID0gbXdBcGkuZ2V0U3RhdGUoKVtyZWR1Y2VyUGF0aF0ubXV0YXRpb25zW2NhY2hlS2V5XTtcbiAgICAgIGlmIChzdGF0ZSkge1xuICAgICAgICBoYW5kbGVOZXdLZXkoYWN0aW9uLm1ldGEuYXJnLmVuZHBvaW50TmFtZSwgYWN0aW9uLm1ldGEuYXJnLm9yaWdpbmFsQXJncywgY2FjaGVLZXksIG13QXBpLCBhY3Rpb24ubWV0YS5yZXF1ZXN0SWQpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNGdWxmaWxsZWRUaHVuayhhY3Rpb24pKSB7XG4gICAgICBjb25zdCBsaWZlY3ljbGUgPSBsaWZlY3ljbGVNYXBbY2FjaGVLZXldO1xuICAgICAgaWYgKGxpZmVjeWNsZT8udmFsdWVSZXNvbHZlZCkge1xuICAgICAgICBsaWZlY3ljbGUudmFsdWVSZXNvbHZlZCh7XG4gICAgICAgICAgZGF0YTogYWN0aW9uLnBheWxvYWQsXG4gICAgICAgICAgbWV0YTogYWN0aW9uLm1ldGEuYmFzZVF1ZXJ5TWV0YVxuICAgICAgICB9KTtcbiAgICAgICAgZGVsZXRlIGxpZmVjeWNsZS52YWx1ZVJlc29sdmVkO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoYXBpLmludGVybmFsQWN0aW9ucy5yZW1vdmVRdWVyeVJlc3VsdC5tYXRjaChhY3Rpb24pIHx8IGFwaS5pbnRlcm5hbEFjdGlvbnMucmVtb3ZlTXV0YXRpb25SZXN1bHQubWF0Y2goYWN0aW9uKSkge1xuICAgICAgY29uc3QgbGlmZWN5Y2xlID0gbGlmZWN5Y2xlTWFwW2NhY2hlS2V5XTtcbiAgICAgIGlmIChsaWZlY3ljbGUpIHtcbiAgICAgICAgZGVsZXRlIGxpZmVjeWNsZU1hcFtjYWNoZUtleV07XG4gICAgICAgIGxpZmVjeWNsZS5jYWNoZUVudHJ5UmVtb3ZlZCgpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoYXBpLnV0aWwucmVzZXRBcGlTdGF0ZS5tYXRjaChhY3Rpb24pKSB7XG4gICAgICBmb3IgKGNvbnN0IFtjYWNoZUtleTIsIGxpZmVjeWNsZV0gb2YgT2JqZWN0LmVudHJpZXMobGlmZWN5Y2xlTWFwKSkge1xuICAgICAgICBkZWxldGUgbGlmZWN5Y2xlTWFwW2NhY2hlS2V5Ml07XG4gICAgICAgIGxpZmVjeWNsZS5jYWNoZUVudHJ5UmVtb3ZlZCgpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgZnVuY3Rpb24gZ2V0Q2FjaGVLZXkoYWN0aW9uKSB7XG4gICAgaWYgKGlzUXVlcnlUaHVuayhhY3Rpb24pKSByZXR1cm4gYWN0aW9uLm1ldGEuYXJnLnF1ZXJ5Q2FjaGVLZXk7XG4gICAgaWYgKGlzTXV0YXRpb25UaHVuayhhY3Rpb24pKSB7XG4gICAgICByZXR1cm4gYWN0aW9uLm1ldGEuYXJnLmZpeGVkQ2FjaGVLZXkgPz8gYWN0aW9uLm1ldGEucmVxdWVzdElkO1xuICAgIH1cbiAgICBpZiAoYXBpLmludGVybmFsQWN0aW9ucy5yZW1vdmVRdWVyeVJlc3VsdC5tYXRjaChhY3Rpb24pKSByZXR1cm4gYWN0aW9uLnBheWxvYWQucXVlcnlDYWNoZUtleTtcbiAgICBpZiAoYXBpLmludGVybmFsQWN0aW9ucy5yZW1vdmVNdXRhdGlvblJlc3VsdC5tYXRjaChhY3Rpb24pKSByZXR1cm4gZ2V0TXV0YXRpb25DYWNoZUtleShhY3Rpb24ucGF5bG9hZCk7XG4gICAgcmV0dXJuIFwiXCI7XG4gIH1cbiAgZnVuY3Rpb24gaGFuZGxlTmV3S2V5KGVuZHBvaW50TmFtZSwgb3JpZ2luYWxBcmdzLCBxdWVyeUNhY2hlS2V5LCBtd0FwaSwgcmVxdWVzdElkKSB7XG4gICAgY29uc3QgZW5kcG9pbnREZWZpbml0aW9uID0gY29udGV4dC5lbmRwb2ludERlZmluaXRpb25zW2VuZHBvaW50TmFtZV07XG4gICAgY29uc3Qgb25DYWNoZUVudHJ5QWRkZWQgPSBlbmRwb2ludERlZmluaXRpb24/Lm9uQ2FjaGVFbnRyeUFkZGVkO1xuICAgIGlmICghb25DYWNoZUVudHJ5QWRkZWQpIHJldHVybjtcbiAgICBjb25zdCBsaWZlY3ljbGUgPSB7fTtcbiAgICBjb25zdCBjYWNoZUVudHJ5UmVtb3ZlZCA9IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICBsaWZlY3ljbGUuY2FjaGVFbnRyeVJlbW92ZWQgPSByZXNvbHZlO1xuICAgIH0pO1xuICAgIGNvbnN0IGNhY2hlRGF0YUxvYWRlZCA9IFByb21pc2UucmFjZShbbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgIGxpZmVjeWNsZS52YWx1ZVJlc29sdmVkID0gcmVzb2x2ZTtcbiAgICB9KSwgY2FjaGVFbnRyeVJlbW92ZWQudGhlbigoKSA9PiB7XG4gICAgICB0aHJvdyBuZXZlclJlc29sdmVkRXJyb3I7XG4gICAgfSldKTtcbiAgICBjYWNoZURhdGFMb2FkZWQuY2F0Y2goKCkgPT4ge1xuICAgIH0pO1xuICAgIGxpZmVjeWNsZU1hcFtxdWVyeUNhY2hlS2V5XSA9IGxpZmVjeWNsZTtcbiAgICBjb25zdCBzZWxlY3RvciA9IGFwaS5lbmRwb2ludHNbZW5kcG9pbnROYW1lXS5zZWxlY3QoZW5kcG9pbnREZWZpbml0aW9uLnR5cGUgPT09IFwicXVlcnlcIiAvKiBxdWVyeSAqLyA/IG9yaWdpbmFsQXJncyA6IHF1ZXJ5Q2FjaGVLZXkpO1xuICAgIGNvbnN0IGV4dHJhID0gbXdBcGkuZGlzcGF0Y2goKF8sIF9fLCBleHRyYTIpID0+IGV4dHJhMik7XG4gICAgY29uc3QgbGlmZWN5Y2xlQXBpID0ge1xuICAgICAgLi4ubXdBcGksXG4gICAgICBnZXRDYWNoZUVudHJ5OiAoKSA9PiBzZWxlY3Rvcihtd0FwaS5nZXRTdGF0ZSgpKSxcbiAgICAgIHJlcXVlc3RJZCxcbiAgICAgIGV4dHJhLFxuICAgICAgdXBkYXRlQ2FjaGVkRGF0YTogZW5kcG9pbnREZWZpbml0aW9uLnR5cGUgPT09IFwicXVlcnlcIiAvKiBxdWVyeSAqLyA/ICh1cGRhdGVSZWNpcGUpID0+IG13QXBpLmRpc3BhdGNoKGFwaS51dGlsLnVwZGF0ZVF1ZXJ5RGF0YShlbmRwb2ludE5hbWUsIG9yaWdpbmFsQXJncywgdXBkYXRlUmVjaXBlKSkgOiB2b2lkIDAsXG4gICAgICBjYWNoZURhdGFMb2FkZWQsXG4gICAgICBjYWNoZUVudHJ5UmVtb3ZlZFxuICAgIH07XG4gICAgY29uc3QgcnVubmluZ0hhbmRsZXIgPSBvbkNhY2hlRW50cnlBZGRlZChvcmlnaW5hbEFyZ3MsIGxpZmVjeWNsZUFwaSk7XG4gICAgUHJvbWlzZS5yZXNvbHZlKHJ1bm5pbmdIYW5kbGVyKS5jYXRjaCgoZSkgPT4ge1xuICAgICAgaWYgKGUgPT09IG5ldmVyUmVzb2x2ZWRFcnJvcikgcmV0dXJuO1xuICAgICAgdGhyb3cgZTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gaGFuZGxlcjtcbn07XG5cbi8vIHNyYy9xdWVyeS9jb3JlL2J1aWxkTWlkZGxld2FyZS9kZXZNaWRkbGV3YXJlLnRzXG52YXIgYnVpbGREZXZDaGVja0hhbmRsZXIgPSAoe1xuICBhcGksXG4gIGNvbnRleHQ6IHtcbiAgICBhcGlVaWRcbiAgfSxcbiAgcmVkdWNlclBhdGhcbn0pID0+IHtcbiAgcmV0dXJuIChhY3Rpb24sIG13QXBpKSA9PiB7XG4gICAgaWYgKGFwaS51dGlsLnJlc2V0QXBpU3RhdGUubWF0Y2goYWN0aW9uKSkge1xuICAgICAgbXdBcGkuZGlzcGF0Y2goYXBpLmludGVybmFsQWN0aW9ucy5taWRkbGV3YXJlUmVnaXN0ZXJlZChhcGlVaWQpKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBwcm9jZXNzICE9PSBcInVuZGVmaW5lZFwiICYmIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcImRldmVsb3BtZW50XCIpIHtcbiAgICAgIGlmIChhcGkuaW50ZXJuYWxBY3Rpb25zLm1pZGRsZXdhcmVSZWdpc3RlcmVkLm1hdGNoKGFjdGlvbikgJiYgYWN0aW9uLnBheWxvYWQgPT09IGFwaVVpZCAmJiBtd0FwaS5nZXRTdGF0ZSgpW3JlZHVjZXJQYXRoXT8uY29uZmlnPy5taWRkbGV3YXJlUmVnaXN0ZXJlZCA9PT0gXCJjb25mbGljdFwiKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihgVGhlcmUgaXMgYSBtaXNtYXRjaCBiZXR3ZWVuIHNsaWNlIGFuZCBtaWRkbGV3YXJlIGZvciB0aGUgcmVkdWNlclBhdGggXCIke3JlZHVjZXJQYXRofVwiLlxuWW91IGNhbiBvbmx5IGhhdmUgb25lIGFwaSBwZXIgcmVkdWNlciBwYXRoLCB0aGlzIHdpbGwgbGVhZCB0byBjcmFzaGVzIGluIHZhcmlvdXMgc2l0dWF0aW9ucyEke3JlZHVjZXJQYXRoID09PSBcImFwaVwiID8gYFxuSWYgeW91IGhhdmUgbXVsdGlwbGUgYXBpcywgeW91ICpoYXZlKiB0byBzcGVjaWZ5IHRoZSByZWR1Y2VyUGF0aCBvcHRpb24gd2hlbiB1c2luZyBjcmVhdGVBcGkhYCA6IFwiXCJ9YCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xufTtcblxuLy8gc3JjL3F1ZXJ5L2NvcmUvYnVpbGRNaWRkbGV3YXJlL2ludmFsaWRhdGlvbkJ5VGFncy50c1xudmFyIGJ1aWxkSW52YWxpZGF0aW9uQnlUYWdzSGFuZGxlciA9ICh7XG4gIHJlZHVjZXJQYXRoLFxuICBjb250ZXh0LFxuICBjb250ZXh0OiB7XG4gICAgZW5kcG9pbnREZWZpbml0aW9uc1xuICB9LFxuICBtdXRhdGlvblRodW5rLFxuICBxdWVyeVRodW5rLFxuICBhcGksXG4gIGFzc2VydFRhZ1R5cGUsXG4gIHJlZmV0Y2hRdWVyeSxcbiAgaW50ZXJuYWxTdGF0ZVxufSkgPT4ge1xuICBjb25zdCB7XG4gICAgcmVtb3ZlUXVlcnlSZXN1bHRcbiAgfSA9IGFwaS5pbnRlcm5hbEFjdGlvbnM7XG4gIGNvbnN0IGlzVGh1bmtBY3Rpb25XaXRoVGFncyA9IGlzQW55T2YoaXNGdWxmaWxsZWQobXV0YXRpb25UaHVuayksIGlzUmVqZWN0ZWRXaXRoVmFsdWUobXV0YXRpb25UaHVuaykpO1xuICBjb25zdCBpc1F1ZXJ5RW5kID0gaXNBbnlPZihpc0Z1bGZpbGxlZChtdXRhdGlvblRodW5rLCBxdWVyeVRodW5rKSwgaXNSZWplY3RlZChtdXRhdGlvblRodW5rLCBxdWVyeVRodW5rKSk7XG4gIGxldCBwZW5kaW5nVGFnSW52YWxpZGF0aW9ucyA9IFtdO1xuICBjb25zdCBoYW5kbGVyID0gKGFjdGlvbiwgbXdBcGkpID0+IHtcbiAgICBpZiAoaXNUaHVua0FjdGlvbldpdGhUYWdzKGFjdGlvbikpIHtcbiAgICAgIGludmFsaWRhdGVUYWdzKGNhbGN1bGF0ZVByb3ZpZGVkQnlUaHVuayhhY3Rpb24sIFwiaW52YWxpZGF0ZXNUYWdzXCIsIGVuZHBvaW50RGVmaW5pdGlvbnMsIGFzc2VydFRhZ1R5cGUpLCBtd0FwaSk7XG4gICAgfSBlbHNlIGlmIChpc1F1ZXJ5RW5kKGFjdGlvbikpIHtcbiAgICAgIGludmFsaWRhdGVUYWdzKFtdLCBtd0FwaSk7XG4gICAgfSBlbHNlIGlmIChhcGkudXRpbC5pbnZhbGlkYXRlVGFncy5tYXRjaChhY3Rpb24pKSB7XG4gICAgICBpbnZhbGlkYXRlVGFncyhjYWxjdWxhdGVQcm92aWRlZEJ5KGFjdGlvbi5wYXlsb2FkLCB2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGFzc2VydFRhZ1R5cGUpLCBtd0FwaSk7XG4gICAgfVxuICB9O1xuICBmdW5jdGlvbiBoYXNQZW5kaW5nUmVxdWVzdHMoc3RhdGUpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBzdGF0ZS5xdWVyaWVzKSB7XG4gICAgICBpZiAoc3RhdGUucXVlcmllc1trZXldPy5zdGF0dXMgPT09IFwicGVuZGluZ1wiIC8qIHBlbmRpbmcgKi8pIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGtleSBpbiBzdGF0ZS5tdXRhdGlvbnMpIHtcbiAgICAgIGlmIChzdGF0ZS5tdXRhdGlvbnNba2V5XT8uc3RhdHVzID09PSBcInBlbmRpbmdcIiAvKiBwZW5kaW5nICovKSByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGZ1bmN0aW9uIGludmFsaWRhdGVUYWdzKG5ld1RhZ3MsIG13QXBpKSB7XG4gICAgY29uc3Qgcm9vdFN0YXRlID0gbXdBcGkuZ2V0U3RhdGUoKTtcbiAgICBjb25zdCBzdGF0ZSA9IHJvb3RTdGF0ZVtyZWR1Y2VyUGF0aF07XG4gICAgcGVuZGluZ1RhZ0ludmFsaWRhdGlvbnMucHVzaCguLi5uZXdUYWdzKTtcbiAgICBpZiAoc3RhdGUuY29uZmlnLmludmFsaWRhdGlvbkJlaGF2aW9yID09PSBcImRlbGF5ZWRcIiAmJiBoYXNQZW5kaW5nUmVxdWVzdHMoc3RhdGUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHRhZ3MgPSBwZW5kaW5nVGFnSW52YWxpZGF0aW9ucztcbiAgICBwZW5kaW5nVGFnSW52YWxpZGF0aW9ucyA9IFtdO1xuICAgIGlmICh0YWdzLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuICAgIGNvbnN0IHRvSW52YWxpZGF0ZSA9IGFwaS51dGlsLnNlbGVjdEludmFsaWRhdGVkQnkocm9vdFN0YXRlLCB0YWdzKTtcbiAgICBjb250ZXh0LmJhdGNoKCgpID0+IHtcbiAgICAgIGNvbnN0IHZhbHVlc0FycmF5ID0gQXJyYXkuZnJvbSh0b0ludmFsaWRhdGUudmFsdWVzKCkpO1xuICAgICAgZm9yIChjb25zdCB7XG4gICAgICAgIHF1ZXJ5Q2FjaGVLZXlcbiAgICAgIH0gb2YgdmFsdWVzQXJyYXkpIHtcbiAgICAgICAgY29uc3QgcXVlcnlTdWJTdGF0ZSA9IHN0YXRlLnF1ZXJpZXNbcXVlcnlDYWNoZUtleV07XG4gICAgICAgIGNvbnN0IHN1YnNjcmlwdGlvblN1YlN0YXRlID0gaW50ZXJuYWxTdGF0ZS5jdXJyZW50U3Vic2NyaXB0aW9uc1txdWVyeUNhY2hlS2V5XSA/PyB7fTtcbiAgICAgICAgaWYgKHF1ZXJ5U3ViU3RhdGUpIHtcbiAgICAgICAgICBpZiAoY291bnRPYmplY3RLZXlzKHN1YnNjcmlwdGlvblN1YlN0YXRlKSA9PT0gMCkge1xuICAgICAgICAgICAgbXdBcGkuZGlzcGF0Y2gocmVtb3ZlUXVlcnlSZXN1bHQoe1xuICAgICAgICAgICAgICBxdWVyeUNhY2hlS2V5XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChxdWVyeVN1YlN0YXRlLnN0YXR1cyAhPT0gXCJ1bmluaXRpYWxpemVkXCIgLyogdW5pbml0aWFsaXplZCAqLykge1xuICAgICAgICAgICAgbXdBcGkuZGlzcGF0Y2gocmVmZXRjaFF1ZXJ5KHF1ZXJ5U3ViU3RhdGUsIHF1ZXJ5Q2FjaGVLZXkpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICByZXR1cm4gaGFuZGxlcjtcbn07XG5cbi8vIHNyYy9xdWVyeS9jb3JlL2J1aWxkTWlkZGxld2FyZS9wb2xsaW5nLnRzXG52YXIgYnVpbGRQb2xsaW5nSGFuZGxlciA9ICh7XG4gIHJlZHVjZXJQYXRoLFxuICBxdWVyeVRodW5rLFxuICBhcGksXG4gIHJlZmV0Y2hRdWVyeSxcbiAgaW50ZXJuYWxTdGF0ZVxufSkgPT4ge1xuICBjb25zdCBjdXJyZW50UG9sbHMgPSB7fTtcbiAgY29uc3QgaGFuZGxlciA9IChhY3Rpb24sIG13QXBpKSA9PiB7XG4gICAgaWYgKGFwaS5pbnRlcm5hbEFjdGlvbnMudXBkYXRlU3Vic2NyaXB0aW9uT3B0aW9ucy5tYXRjaChhY3Rpb24pIHx8IGFwaS5pbnRlcm5hbEFjdGlvbnMudW5zdWJzY3JpYmVRdWVyeVJlc3VsdC5tYXRjaChhY3Rpb24pKSB7XG4gICAgICB1cGRhdGVQb2xsaW5nSW50ZXJ2YWwoYWN0aW9uLnBheWxvYWQsIG13QXBpKTtcbiAgICB9XG4gICAgaWYgKHF1ZXJ5VGh1bmsucGVuZGluZy5tYXRjaChhY3Rpb24pIHx8IHF1ZXJ5VGh1bmsucmVqZWN0ZWQubWF0Y2goYWN0aW9uKSAmJiBhY3Rpb24ubWV0YS5jb25kaXRpb24pIHtcbiAgICAgIHVwZGF0ZVBvbGxpbmdJbnRlcnZhbChhY3Rpb24ubWV0YS5hcmcsIG13QXBpKTtcbiAgICB9XG4gICAgaWYgKHF1ZXJ5VGh1bmsuZnVsZmlsbGVkLm1hdGNoKGFjdGlvbikgfHwgcXVlcnlUaHVuay5yZWplY3RlZC5tYXRjaChhY3Rpb24pICYmICFhY3Rpb24ubWV0YS5jb25kaXRpb24pIHtcbiAgICAgIHN0YXJ0TmV4dFBvbGwoYWN0aW9uLm1ldGEuYXJnLCBtd0FwaSk7XG4gICAgfVxuICAgIGlmIChhcGkudXRpbC5yZXNldEFwaVN0YXRlLm1hdGNoKGFjdGlvbikpIHtcbiAgICAgIGNsZWFyUG9sbHMoKTtcbiAgICB9XG4gIH07XG4gIGZ1bmN0aW9uIHN0YXJ0TmV4dFBvbGwoe1xuICAgIHF1ZXJ5Q2FjaGVLZXlcbiAgfSwgYXBpMikge1xuICAgIGNvbnN0IHN0YXRlID0gYXBpMi5nZXRTdGF0ZSgpW3JlZHVjZXJQYXRoXTtcbiAgICBjb25zdCBxdWVyeVN1YlN0YXRlID0gc3RhdGUucXVlcmllc1txdWVyeUNhY2hlS2V5XTtcbiAgICBjb25zdCBzdWJzY3JpcHRpb25zID0gaW50ZXJuYWxTdGF0ZS5jdXJyZW50U3Vic2NyaXB0aW9uc1txdWVyeUNhY2hlS2V5XTtcbiAgICBpZiAoIXF1ZXJ5U3ViU3RhdGUgfHwgcXVlcnlTdWJTdGF0ZS5zdGF0dXMgPT09IFwidW5pbml0aWFsaXplZFwiIC8qIHVuaW5pdGlhbGl6ZWQgKi8pIHJldHVybjtcbiAgICBjb25zdCB7XG4gICAgICBsb3dlc3RQb2xsaW5nSW50ZXJ2YWwsXG4gICAgICBza2lwUG9sbGluZ0lmVW5mb2N1c2VkXG4gICAgfSA9IGZpbmRMb3dlc3RQb2xsaW5nSW50ZXJ2YWwoc3Vic2NyaXB0aW9ucyk7XG4gICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUobG93ZXN0UG9sbGluZ0ludGVydmFsKSkgcmV0dXJuO1xuICAgIGNvbnN0IGN1cnJlbnRQb2xsID0gY3VycmVudFBvbGxzW3F1ZXJ5Q2FjaGVLZXldO1xuICAgIGlmIChjdXJyZW50UG9sbD8udGltZW91dCkge1xuICAgICAgY2xlYXJUaW1lb3V0KGN1cnJlbnRQb2xsLnRpbWVvdXQpO1xuICAgICAgY3VycmVudFBvbGwudGltZW91dCA9IHZvaWQgMDtcbiAgICB9XG4gICAgY29uc3QgbmV4dFBvbGxUaW1lc3RhbXAgPSBEYXRlLm5vdygpICsgbG93ZXN0UG9sbGluZ0ludGVydmFsO1xuICAgIGN1cnJlbnRQb2xsc1txdWVyeUNhY2hlS2V5XSA9IHtcbiAgICAgIG5leHRQb2xsVGltZXN0YW1wLFxuICAgICAgcG9sbGluZ0ludGVydmFsOiBsb3dlc3RQb2xsaW5nSW50ZXJ2YWwsXG4gICAgICB0aW1lb3V0OiBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgaWYgKHN0YXRlLmNvbmZpZy5mb2N1c2VkIHx8ICFza2lwUG9sbGluZ0lmVW5mb2N1c2VkKSB7XG4gICAgICAgICAgYXBpMi5kaXNwYXRjaChyZWZldGNoUXVlcnkocXVlcnlTdWJTdGF0ZSwgcXVlcnlDYWNoZUtleSkpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXJ0TmV4dFBvbGwoe1xuICAgICAgICAgIHF1ZXJ5Q2FjaGVLZXlcbiAgICAgICAgfSwgYXBpMik7XG4gICAgICB9LCBsb3dlc3RQb2xsaW5nSW50ZXJ2YWwpXG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiB1cGRhdGVQb2xsaW5nSW50ZXJ2YWwoe1xuICAgIHF1ZXJ5Q2FjaGVLZXlcbiAgfSwgYXBpMikge1xuICAgIGNvbnN0IHN0YXRlID0gYXBpMi5nZXRTdGF0ZSgpW3JlZHVjZXJQYXRoXTtcbiAgICBjb25zdCBxdWVyeVN1YlN0YXRlID0gc3RhdGUucXVlcmllc1txdWVyeUNhY2hlS2V5XTtcbiAgICBjb25zdCBzdWJzY3JpcHRpb25zID0gaW50ZXJuYWxTdGF0ZS5jdXJyZW50U3Vic2NyaXB0aW9uc1txdWVyeUNhY2hlS2V5XTtcbiAgICBpZiAoIXF1ZXJ5U3ViU3RhdGUgfHwgcXVlcnlTdWJTdGF0ZS5zdGF0dXMgPT09IFwidW5pbml0aWFsaXplZFwiIC8qIHVuaW5pdGlhbGl6ZWQgKi8pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgbG93ZXN0UG9sbGluZ0ludGVydmFsXG4gICAgfSA9IGZpbmRMb3dlc3RQb2xsaW5nSW50ZXJ2YWwoc3Vic2NyaXB0aW9ucyk7XG4gICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUobG93ZXN0UG9sbGluZ0ludGVydmFsKSkge1xuICAgICAgY2xlYW51cFBvbGxGb3JLZXkocXVlcnlDYWNoZUtleSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGN1cnJlbnRQb2xsID0gY3VycmVudFBvbGxzW3F1ZXJ5Q2FjaGVLZXldO1xuICAgIGNvbnN0IG5leHRQb2xsVGltZXN0YW1wID0gRGF0ZS5ub3coKSArIGxvd2VzdFBvbGxpbmdJbnRlcnZhbDtcbiAgICBpZiAoIWN1cnJlbnRQb2xsIHx8IG5leHRQb2xsVGltZXN0YW1wIDwgY3VycmVudFBvbGwubmV4dFBvbGxUaW1lc3RhbXApIHtcbiAgICAgIHN0YXJ0TmV4dFBvbGwoe1xuICAgICAgICBxdWVyeUNhY2hlS2V5XG4gICAgICB9LCBhcGkyKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gY2xlYW51cFBvbGxGb3JLZXkoa2V5KSB7XG4gICAgY29uc3QgZXhpc3RpbmdQb2xsID0gY3VycmVudFBvbGxzW2tleV07XG4gICAgaWYgKGV4aXN0aW5nUG9sbD8udGltZW91dCkge1xuICAgICAgY2xlYXJUaW1lb3V0KGV4aXN0aW5nUG9sbC50aW1lb3V0KTtcbiAgICB9XG4gICAgZGVsZXRlIGN1cnJlbnRQb2xsc1trZXldO1xuICB9XG4gIGZ1bmN0aW9uIGNsZWFyUG9sbHMoKSB7XG4gICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoY3VycmVudFBvbGxzKSkge1xuICAgICAgY2xlYW51cFBvbGxGb3JLZXkoa2V5KTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZmluZExvd2VzdFBvbGxpbmdJbnRlcnZhbChzdWJzY3JpYmVycyA9IHt9KSB7XG4gICAgbGV0IHNraXBQb2xsaW5nSWZVbmZvY3VzZWQgPSBmYWxzZTtcbiAgICBsZXQgbG93ZXN0UG9sbGluZ0ludGVydmFsID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgIGZvciAobGV0IGtleSBpbiBzdWJzY3JpYmVycykge1xuICAgICAgaWYgKCEhc3Vic2NyaWJlcnNba2V5XS5wb2xsaW5nSW50ZXJ2YWwpIHtcbiAgICAgICAgbG93ZXN0UG9sbGluZ0ludGVydmFsID0gTWF0aC5taW4oc3Vic2NyaWJlcnNba2V5XS5wb2xsaW5nSW50ZXJ2YWwsIGxvd2VzdFBvbGxpbmdJbnRlcnZhbCk7XG4gICAgICAgIHNraXBQb2xsaW5nSWZVbmZvY3VzZWQgPSBzdWJzY3JpYmVyc1trZXldLnNraXBQb2xsaW5nSWZVbmZvY3VzZWQgfHwgc2tpcFBvbGxpbmdJZlVuZm9jdXNlZDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGxvd2VzdFBvbGxpbmdJbnRlcnZhbCxcbiAgICAgIHNraXBQb2xsaW5nSWZVbmZvY3VzZWRcbiAgICB9O1xuICB9XG4gIHJldHVybiBoYW5kbGVyO1xufTtcblxuLy8gc3JjL3F1ZXJ5L2NvcmUvYnVpbGRNaWRkbGV3YXJlL3F1ZXJ5TGlmZWN5Y2xlLnRzXG52YXIgYnVpbGRRdWVyeUxpZmVjeWNsZUhhbmRsZXIgPSAoe1xuICBhcGksXG4gIGNvbnRleHQsXG4gIHF1ZXJ5VGh1bmssXG4gIG11dGF0aW9uVGh1bmtcbn0pID0+IHtcbiAgY29uc3QgaXNQZW5kaW5nVGh1bmsgPSBpc1BlbmRpbmcocXVlcnlUaHVuaywgbXV0YXRpb25UaHVuayk7XG4gIGNvbnN0IGlzUmVqZWN0ZWRUaHVuayA9IGlzUmVqZWN0ZWQocXVlcnlUaHVuaywgbXV0YXRpb25UaHVuayk7XG4gIGNvbnN0IGlzRnVsbGZpbGxlZFRodW5rID0gaXNGdWxmaWxsZWQocXVlcnlUaHVuaywgbXV0YXRpb25UaHVuayk7XG4gIGNvbnN0IGxpZmVjeWNsZU1hcCA9IHt9O1xuICBjb25zdCBoYW5kbGVyID0gKGFjdGlvbiwgbXdBcGkpID0+IHtcbiAgICBpZiAoaXNQZW5kaW5nVGh1bmsoYWN0aW9uKSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICByZXF1ZXN0SWQsXG4gICAgICAgIGFyZzoge1xuICAgICAgICAgIGVuZHBvaW50TmFtZSxcbiAgICAgICAgICBvcmlnaW5hbEFyZ3NcbiAgICAgICAgfVxuICAgICAgfSA9IGFjdGlvbi5tZXRhO1xuICAgICAgY29uc3QgZW5kcG9pbnREZWZpbml0aW9uID0gY29udGV4dC5lbmRwb2ludERlZmluaXRpb25zW2VuZHBvaW50TmFtZV07XG4gICAgICBjb25zdCBvblF1ZXJ5U3RhcnRlZCA9IGVuZHBvaW50RGVmaW5pdGlvbj8ub25RdWVyeVN0YXJ0ZWQ7XG4gICAgICBpZiAob25RdWVyeVN0YXJ0ZWQpIHtcbiAgICAgICAgY29uc3QgbGlmZWN5Y2xlID0ge307XG4gICAgICAgIGNvbnN0IHF1ZXJ5RnVsZmlsbGVkID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgIGxpZmVjeWNsZS5yZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgICAgICBsaWZlY3ljbGUucmVqZWN0ID0gcmVqZWN0O1xuICAgICAgICB9KTtcbiAgICAgICAgcXVlcnlGdWxmaWxsZWQuY2F0Y2goKCkgPT4ge1xuICAgICAgICB9KTtcbiAgICAgICAgbGlmZWN5Y2xlTWFwW3JlcXVlc3RJZF0gPSBsaWZlY3ljbGU7XG4gICAgICAgIGNvbnN0IHNlbGVjdG9yID0gYXBpLmVuZHBvaW50c1tlbmRwb2ludE5hbWVdLnNlbGVjdChlbmRwb2ludERlZmluaXRpb24udHlwZSA9PT0gXCJxdWVyeVwiIC8qIHF1ZXJ5ICovID8gb3JpZ2luYWxBcmdzIDogcmVxdWVzdElkKTtcbiAgICAgICAgY29uc3QgZXh0cmEgPSBtd0FwaS5kaXNwYXRjaCgoXywgX18sIGV4dHJhMikgPT4gZXh0cmEyKTtcbiAgICAgICAgY29uc3QgbGlmZWN5Y2xlQXBpID0ge1xuICAgICAgICAgIC4uLm13QXBpLFxuICAgICAgICAgIGdldENhY2hlRW50cnk6ICgpID0+IHNlbGVjdG9yKG13QXBpLmdldFN0YXRlKCkpLFxuICAgICAgICAgIHJlcXVlc3RJZCxcbiAgICAgICAgICBleHRyYSxcbiAgICAgICAgICB1cGRhdGVDYWNoZWREYXRhOiBlbmRwb2ludERlZmluaXRpb24udHlwZSA9PT0gXCJxdWVyeVwiIC8qIHF1ZXJ5ICovID8gKHVwZGF0ZVJlY2lwZSkgPT4gbXdBcGkuZGlzcGF0Y2goYXBpLnV0aWwudXBkYXRlUXVlcnlEYXRhKGVuZHBvaW50TmFtZSwgb3JpZ2luYWxBcmdzLCB1cGRhdGVSZWNpcGUpKSA6IHZvaWQgMCxcbiAgICAgICAgICBxdWVyeUZ1bGZpbGxlZFxuICAgICAgICB9O1xuICAgICAgICBvblF1ZXJ5U3RhcnRlZChvcmlnaW5hbEFyZ3MsIGxpZmVjeWNsZUFwaSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc0Z1bGxmaWxsZWRUaHVuayhhY3Rpb24pKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHJlcXVlc3RJZCxcbiAgICAgICAgYmFzZVF1ZXJ5TWV0YVxuICAgICAgfSA9IGFjdGlvbi5tZXRhO1xuICAgICAgbGlmZWN5Y2xlTWFwW3JlcXVlc3RJZF0/LnJlc29sdmUoe1xuICAgICAgICBkYXRhOiBhY3Rpb24ucGF5bG9hZCxcbiAgICAgICAgbWV0YTogYmFzZVF1ZXJ5TWV0YVxuICAgICAgfSk7XG4gICAgICBkZWxldGUgbGlmZWN5Y2xlTWFwW3JlcXVlc3RJZF07XG4gICAgfSBlbHNlIGlmIChpc1JlamVjdGVkVGh1bmsoYWN0aW9uKSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICByZXF1ZXN0SWQsXG4gICAgICAgIHJlamVjdGVkV2l0aFZhbHVlLFxuICAgICAgICBiYXNlUXVlcnlNZXRhXG4gICAgICB9ID0gYWN0aW9uLm1ldGE7XG4gICAgICBsaWZlY3ljbGVNYXBbcmVxdWVzdElkXT8ucmVqZWN0KHtcbiAgICAgICAgZXJyb3I6IGFjdGlvbi5wYXlsb2FkID8/IGFjdGlvbi5lcnJvcixcbiAgICAgICAgaXNVbmhhbmRsZWRFcnJvcjogIXJlamVjdGVkV2l0aFZhbHVlLFxuICAgICAgICBtZXRhOiBiYXNlUXVlcnlNZXRhXG4gICAgICB9KTtcbiAgICAgIGRlbGV0ZSBsaWZlY3ljbGVNYXBbcmVxdWVzdElkXTtcbiAgICB9XG4gIH07XG4gIHJldHVybiBoYW5kbGVyO1xufTtcblxuLy8gc3JjL3F1ZXJ5L2NvcmUvYnVpbGRNaWRkbGV3YXJlL3dpbmRvd0V2ZW50SGFuZGxpbmcudHNcbnZhciBidWlsZFdpbmRvd0V2ZW50SGFuZGxlciA9ICh7XG4gIHJlZHVjZXJQYXRoLFxuICBjb250ZXh0LFxuICBhcGksXG4gIHJlZmV0Y2hRdWVyeSxcbiAgaW50ZXJuYWxTdGF0ZVxufSkgPT4ge1xuICBjb25zdCB7XG4gICAgcmVtb3ZlUXVlcnlSZXN1bHRcbiAgfSA9IGFwaS5pbnRlcm5hbEFjdGlvbnM7XG4gIGNvbnN0IGhhbmRsZXIgPSAoYWN0aW9uLCBtd0FwaSkgPT4ge1xuICAgIGlmIChvbkZvY3VzLm1hdGNoKGFjdGlvbikpIHtcbiAgICAgIHJlZmV0Y2hWYWxpZFF1ZXJpZXMobXdBcGksIFwicmVmZXRjaE9uRm9jdXNcIik7XG4gICAgfVxuICAgIGlmIChvbk9ubGluZS5tYXRjaChhY3Rpb24pKSB7XG4gICAgICByZWZldGNoVmFsaWRRdWVyaWVzKG13QXBpLCBcInJlZmV0Y2hPblJlY29ubmVjdFwiKTtcbiAgICB9XG4gIH07XG4gIGZ1bmN0aW9uIHJlZmV0Y2hWYWxpZFF1ZXJpZXMoYXBpMiwgdHlwZSkge1xuICAgIGNvbnN0IHN0YXRlID0gYXBpMi5nZXRTdGF0ZSgpW3JlZHVjZXJQYXRoXTtcbiAgICBjb25zdCBxdWVyaWVzID0gc3RhdGUucXVlcmllcztcbiAgICBjb25zdCBzdWJzY3JpcHRpb25zID0gaW50ZXJuYWxTdGF0ZS5jdXJyZW50U3Vic2NyaXB0aW9ucztcbiAgICBjb250ZXh0LmJhdGNoKCgpID0+IHtcbiAgICAgIGZvciAoY29uc3QgcXVlcnlDYWNoZUtleSBvZiBPYmplY3Qua2V5cyhzdWJzY3JpcHRpb25zKSkge1xuICAgICAgICBjb25zdCBxdWVyeVN1YlN0YXRlID0gcXVlcmllc1txdWVyeUNhY2hlS2V5XTtcbiAgICAgICAgY29uc3Qgc3Vic2NyaXB0aW9uU3ViU3RhdGUgPSBzdWJzY3JpcHRpb25zW3F1ZXJ5Q2FjaGVLZXldO1xuICAgICAgICBpZiAoIXN1YnNjcmlwdGlvblN1YlN0YXRlIHx8ICFxdWVyeVN1YlN0YXRlKSBjb250aW51ZTtcbiAgICAgICAgY29uc3Qgc2hvdWxkUmVmZXRjaCA9IE9iamVjdC52YWx1ZXMoc3Vic2NyaXB0aW9uU3ViU3RhdGUpLnNvbWUoKHN1YikgPT4gc3ViW3R5cGVdID09PSB0cnVlKSB8fCBPYmplY3QudmFsdWVzKHN1YnNjcmlwdGlvblN1YlN0YXRlKS5ldmVyeSgoc3ViKSA9PiBzdWJbdHlwZV0gPT09IHZvaWQgMCkgJiYgc3RhdGUuY29uZmlnW3R5cGVdO1xuICAgICAgICBpZiAoc2hvdWxkUmVmZXRjaCkge1xuICAgICAgICAgIGlmIChjb3VudE9iamVjdEtleXMoc3Vic2NyaXB0aW9uU3ViU3RhdGUpID09PSAwKSB7XG4gICAgICAgICAgICBhcGkyLmRpc3BhdGNoKHJlbW92ZVF1ZXJ5UmVzdWx0KHtcbiAgICAgICAgICAgICAgcXVlcnlDYWNoZUtleVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgIH0gZWxzZSBpZiAocXVlcnlTdWJTdGF0ZS5zdGF0dXMgIT09IFwidW5pbml0aWFsaXplZFwiIC8qIHVuaW5pdGlhbGl6ZWQgKi8pIHtcbiAgICAgICAgICAgIGFwaTIuZGlzcGF0Y2gocmVmZXRjaFF1ZXJ5KHF1ZXJ5U3ViU3RhdGUsIHF1ZXJ5Q2FjaGVLZXkpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICByZXR1cm4gaGFuZGxlcjtcbn07XG5cbi8vIHNyYy9xdWVyeS9jb3JlL2J1aWxkTWlkZGxld2FyZS9pbmRleC50c1xuZnVuY3Rpb24gYnVpbGRNaWRkbGV3YXJlKGlucHV0KSB7XG4gIGNvbnN0IHtcbiAgICByZWR1Y2VyUGF0aCxcbiAgICBxdWVyeVRodW5rLFxuICAgIGFwaSxcbiAgICBjb250ZXh0XG4gIH0gPSBpbnB1dDtcbiAgY29uc3Qge1xuICAgIGFwaVVpZFxuICB9ID0gY29udGV4dDtcbiAgY29uc3QgYWN0aW9ucyA9IHtcbiAgICBpbnZhbGlkYXRlVGFnczogY3JlYXRlQWN0aW9uKGAke3JlZHVjZXJQYXRofS9pbnZhbGlkYXRlVGFnc2ApXG4gIH07XG4gIGNvbnN0IGlzVGhpc0FwaVNsaWNlQWN0aW9uID0gKGFjdGlvbikgPT4gYWN0aW9uLnR5cGUuc3RhcnRzV2l0aChgJHtyZWR1Y2VyUGF0aH0vYCk7XG4gIGNvbnN0IGhhbmRsZXJCdWlsZGVycyA9IFtidWlsZERldkNoZWNrSGFuZGxlciwgYnVpbGRDYWNoZUNvbGxlY3Rpb25IYW5kbGVyLCBidWlsZEludmFsaWRhdGlvbkJ5VGFnc0hhbmRsZXIsIGJ1aWxkUG9sbGluZ0hhbmRsZXIsIGJ1aWxkQ2FjaGVMaWZlY3ljbGVIYW5kbGVyLCBidWlsZFF1ZXJ5TGlmZWN5Y2xlSGFuZGxlcl07XG4gIGNvbnN0IG1pZGRsZXdhcmUgPSAobXdBcGkpID0+IHtcbiAgICBsZXQgaW5pdGlhbGl6ZWQyID0gZmFsc2U7XG4gICAgY29uc3QgaW50ZXJuYWxTdGF0ZSA9IHtcbiAgICAgIGN1cnJlbnRTdWJzY3JpcHRpb25zOiB7fVxuICAgIH07XG4gICAgY29uc3QgYnVpbGRlckFyZ3MgPSB7XG4gICAgICAuLi5pbnB1dCxcbiAgICAgIGludGVybmFsU3RhdGUsXG4gICAgICByZWZldGNoUXVlcnksXG4gICAgICBpc1RoaXNBcGlTbGljZUFjdGlvblxuICAgIH07XG4gICAgY29uc3QgaGFuZGxlcnMgPSBoYW5kbGVyQnVpbGRlcnMubWFwKChidWlsZCkgPT4gYnVpbGQoYnVpbGRlckFyZ3MpKTtcbiAgICBjb25zdCBiYXRjaGVkQWN0aW9uc0hhbmRsZXIgPSBidWlsZEJhdGNoZWRBY3Rpb25zSGFuZGxlcihidWlsZGVyQXJncyk7XG4gICAgY29uc3Qgd2luZG93RXZlbnRzSGFuZGxlciA9IGJ1aWxkV2luZG93RXZlbnRIYW5kbGVyKGJ1aWxkZXJBcmdzKTtcbiAgICByZXR1cm4gKG5leHQpID0+IHtcbiAgICAgIHJldHVybiAoYWN0aW9uKSA9PiB7XG4gICAgICAgIGlmICghaXNBY3Rpb24oYWN0aW9uKSkge1xuICAgICAgICAgIHJldHVybiBuZXh0KGFjdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpbml0aWFsaXplZDIpIHtcbiAgICAgICAgICBpbml0aWFsaXplZDIgPSB0cnVlO1xuICAgICAgICAgIG13QXBpLmRpc3BhdGNoKGFwaS5pbnRlcm5hbEFjdGlvbnMubWlkZGxld2FyZVJlZ2lzdGVyZWQoYXBpVWlkKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbXdBcGlXaXRoTmV4dCA9IHtcbiAgICAgICAgICAuLi5td0FwaSxcbiAgICAgICAgICBuZXh0XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHN0YXRlQmVmb3JlID0gbXdBcGkuZ2V0U3RhdGUoKTtcbiAgICAgICAgY29uc3QgW2FjdGlvblNob3VsZENvbnRpbnVlLCBpbnRlcm5hbFByb2JlUmVzdWx0XSA9IGJhdGNoZWRBY3Rpb25zSGFuZGxlcihhY3Rpb24sIG13QXBpV2l0aE5leHQsIHN0YXRlQmVmb3JlKTtcbiAgICAgICAgbGV0IHJlcztcbiAgICAgICAgaWYgKGFjdGlvblNob3VsZENvbnRpbnVlKSB7XG4gICAgICAgICAgcmVzID0gbmV4dChhY3Rpb24pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlcyA9IGludGVybmFsUHJvYmVSZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEhbXdBcGkuZ2V0U3RhdGUoKVtyZWR1Y2VyUGF0aF0pIHtcbiAgICAgICAgICB3aW5kb3dFdmVudHNIYW5kbGVyKGFjdGlvbiwgbXdBcGlXaXRoTmV4dCwgc3RhdGVCZWZvcmUpO1xuICAgICAgICAgIGlmIChpc1RoaXNBcGlTbGljZUFjdGlvbihhY3Rpb24pIHx8IGNvbnRleHQuaGFzUmVoeWRyYXRpb25JbmZvKGFjdGlvbikpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaGFuZGxlciBvZiBoYW5kbGVycykge1xuICAgICAgICAgICAgICBoYW5kbGVyKGFjdGlvbiwgbXdBcGlXaXRoTmV4dCwgc3RhdGVCZWZvcmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgfTtcbiAgICB9O1xuICB9O1xuICByZXR1cm4ge1xuICAgIG1pZGRsZXdhcmUsXG4gICAgYWN0aW9uc1xuICB9O1xuICBmdW5jdGlvbiByZWZldGNoUXVlcnkocXVlcnlTdWJTdGF0ZSwgcXVlcnlDYWNoZUtleSwgb3ZlcnJpZGUgPSB7fSkge1xuICAgIHJldHVybiBxdWVyeVRodW5rKHtcbiAgICAgIHR5cGU6IFwicXVlcnlcIixcbiAgICAgIGVuZHBvaW50TmFtZTogcXVlcnlTdWJTdGF0ZS5lbmRwb2ludE5hbWUsXG4gICAgICBvcmlnaW5hbEFyZ3M6IHF1ZXJ5U3ViU3RhdGUub3JpZ2luYWxBcmdzLFxuICAgICAgc3Vic2NyaWJlOiBmYWxzZSxcbiAgICAgIGZvcmNlUmVmZXRjaDogdHJ1ZSxcbiAgICAgIHF1ZXJ5Q2FjaGVLZXksXG4gICAgICAuLi5vdmVycmlkZVxuICAgIH0pO1xuICB9XG59XG5cbi8vIHNyYy9xdWVyeS9jb3JlL21vZHVsZS50c1xudmFyIGNvcmVNb2R1bGVOYW1lID0gLyogQF9fUFVSRV9fICovIFN5bWJvbCgpO1xudmFyIGNvcmVNb2R1bGUgPSAoe1xuICBjcmVhdGVTZWxlY3RvcjogY3JlYXRlU2VsZWN0b3IyID0gY3JlYXRlU2VsZWN0b3Jcbn0gPSB7fSkgPT4gKHtcbiAgbmFtZTogY29yZU1vZHVsZU5hbWUsXG4gIGluaXQoYXBpLCB7XG4gICAgYmFzZVF1ZXJ5LFxuICAgIHRhZ1R5cGVzLFxuICAgIHJlZHVjZXJQYXRoLFxuICAgIHNlcmlhbGl6ZVF1ZXJ5QXJncyxcbiAgICBrZWVwVW51c2VkRGF0YUZvcixcbiAgICByZWZldGNoT25Nb3VudE9yQXJnQ2hhbmdlLFxuICAgIHJlZmV0Y2hPbkZvY3VzLFxuICAgIHJlZmV0Y2hPblJlY29ubmVjdCxcbiAgICBpbnZhbGlkYXRpb25CZWhhdmlvclxuICB9LCBjb250ZXh0KSB7XG4gICAgZW5hYmxlUGF0Y2hlcygpO1xuICAgIGFzc2VydENhc3Qoc2VyaWFsaXplUXVlcnlBcmdzKTtcbiAgICBjb25zdCBhc3NlcnRUYWdUeXBlID0gKHRhZykgPT4ge1xuICAgICAgaWYgKHR5cGVvZiBwcm9jZXNzICE9PSBcInVuZGVmaW5lZFwiICYmIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcImRldmVsb3BtZW50XCIpIHtcbiAgICAgICAgaWYgKCF0YWdUeXBlcy5pbmNsdWRlcyh0YWcudHlwZSkpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGBUYWcgdHlwZSAnJHt0YWcudHlwZX0nIHdhcyB1c2VkLCBidXQgbm90IHNwZWNpZmllZCBpbiBcXGB0YWdUeXBlc1xcYCFgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRhZztcbiAgICB9O1xuICAgIE9iamVjdC5hc3NpZ24oYXBpLCB7XG4gICAgICByZWR1Y2VyUGF0aCxcbiAgICAgIGVuZHBvaW50czoge30sXG4gICAgICBpbnRlcm5hbEFjdGlvbnM6IHtcbiAgICAgICAgb25PbmxpbmUsXG4gICAgICAgIG9uT2ZmbGluZSxcbiAgICAgICAgb25Gb2N1cyxcbiAgICAgICAgb25Gb2N1c0xvc3RcbiAgICAgIH0sXG4gICAgICB1dGlsOiB7fVxuICAgIH0pO1xuICAgIGNvbnN0IHtcbiAgICAgIHF1ZXJ5VGh1bmssXG4gICAgICBtdXRhdGlvblRodW5rLFxuICAgICAgcGF0Y2hRdWVyeURhdGEsXG4gICAgICB1cGRhdGVRdWVyeURhdGEsXG4gICAgICB1cHNlcnRRdWVyeURhdGEsXG4gICAgICBwcmVmZXRjaCxcbiAgICAgIGJ1aWxkTWF0Y2hUaHVua0FjdGlvbnNcbiAgICB9ID0gYnVpbGRUaHVua3Moe1xuICAgICAgYmFzZVF1ZXJ5LFxuICAgICAgcmVkdWNlclBhdGgsXG4gICAgICBjb250ZXh0LFxuICAgICAgYXBpLFxuICAgICAgc2VyaWFsaXplUXVlcnlBcmdzLFxuICAgICAgYXNzZXJ0VGFnVHlwZVxuICAgIH0pO1xuICAgIGNvbnN0IHtcbiAgICAgIHJlZHVjZXIsXG4gICAgICBhY3Rpb25zOiBzbGljZUFjdGlvbnNcbiAgICB9ID0gYnVpbGRTbGljZSh7XG4gICAgICBjb250ZXh0LFxuICAgICAgcXVlcnlUaHVuayxcbiAgICAgIG11dGF0aW9uVGh1bmssXG4gICAgICByZWR1Y2VyUGF0aCxcbiAgICAgIGFzc2VydFRhZ1R5cGUsXG4gICAgICBjb25maWc6IHtcbiAgICAgICAgcmVmZXRjaE9uRm9jdXMsXG4gICAgICAgIHJlZmV0Y2hPblJlY29ubmVjdCxcbiAgICAgICAgcmVmZXRjaE9uTW91bnRPckFyZ0NoYW5nZSxcbiAgICAgICAga2VlcFVudXNlZERhdGFGb3IsXG4gICAgICAgIHJlZHVjZXJQYXRoLFxuICAgICAgICBpbnZhbGlkYXRpb25CZWhhdmlvclxuICAgICAgfVxuICAgIH0pO1xuICAgIHNhZmVBc3NpZ24oYXBpLnV0aWwsIHtcbiAgICAgIHBhdGNoUXVlcnlEYXRhLFxuICAgICAgdXBkYXRlUXVlcnlEYXRhLFxuICAgICAgdXBzZXJ0UXVlcnlEYXRhLFxuICAgICAgcHJlZmV0Y2gsXG4gICAgICByZXNldEFwaVN0YXRlOiBzbGljZUFjdGlvbnMucmVzZXRBcGlTdGF0ZVxuICAgIH0pO1xuICAgIHNhZmVBc3NpZ24oYXBpLmludGVybmFsQWN0aW9ucywgc2xpY2VBY3Rpb25zKTtcbiAgICBjb25zdCB7XG4gICAgICBtaWRkbGV3YXJlLFxuICAgICAgYWN0aW9uczogbWlkZGxld2FyZUFjdGlvbnNcbiAgICB9ID0gYnVpbGRNaWRkbGV3YXJlKHtcbiAgICAgIHJlZHVjZXJQYXRoLFxuICAgICAgY29udGV4dCxcbiAgICAgIHF1ZXJ5VGh1bmssXG4gICAgICBtdXRhdGlvblRodW5rLFxuICAgICAgYXBpLFxuICAgICAgYXNzZXJ0VGFnVHlwZVxuICAgIH0pO1xuICAgIHNhZmVBc3NpZ24oYXBpLnV0aWwsIG1pZGRsZXdhcmVBY3Rpb25zKTtcbiAgICBzYWZlQXNzaWduKGFwaSwge1xuICAgICAgcmVkdWNlcixcbiAgICAgIG1pZGRsZXdhcmVcbiAgICB9KTtcbiAgICBjb25zdCB7XG4gICAgICBidWlsZFF1ZXJ5U2VsZWN0b3IsXG4gICAgICBidWlsZE11dGF0aW9uU2VsZWN0b3IsXG4gICAgICBzZWxlY3RJbnZhbGlkYXRlZEJ5LFxuICAgICAgc2VsZWN0Q2FjaGVkQXJnc0ZvclF1ZXJ5XG4gICAgfSA9IGJ1aWxkU2VsZWN0b3JzKHtcbiAgICAgIHNlcmlhbGl6ZVF1ZXJ5QXJncyxcbiAgICAgIHJlZHVjZXJQYXRoLFxuICAgICAgY3JlYXRlU2VsZWN0b3I6IGNyZWF0ZVNlbGVjdG9yMlxuICAgIH0pO1xuICAgIHNhZmVBc3NpZ24oYXBpLnV0aWwsIHtcbiAgICAgIHNlbGVjdEludmFsaWRhdGVkQnksXG4gICAgICBzZWxlY3RDYWNoZWRBcmdzRm9yUXVlcnlcbiAgICB9KTtcbiAgICBjb25zdCB7XG4gICAgICBidWlsZEluaXRpYXRlUXVlcnksXG4gICAgICBidWlsZEluaXRpYXRlTXV0YXRpb24sXG4gICAgICBnZXRSdW5uaW5nTXV0YXRpb25UaHVuayxcbiAgICAgIGdldFJ1bm5pbmdNdXRhdGlvbnNUaHVuayxcbiAgICAgIGdldFJ1bm5pbmdRdWVyaWVzVGh1bmssXG4gICAgICBnZXRSdW5uaW5nUXVlcnlUaHVua1xuICAgIH0gPSBidWlsZEluaXRpYXRlKHtcbiAgICAgIHF1ZXJ5VGh1bmssXG4gICAgICBtdXRhdGlvblRodW5rLFxuICAgICAgYXBpLFxuICAgICAgc2VyaWFsaXplUXVlcnlBcmdzLFxuICAgICAgY29udGV4dFxuICAgIH0pO1xuICAgIHNhZmVBc3NpZ24oYXBpLnV0aWwsIHtcbiAgICAgIGdldFJ1bm5pbmdNdXRhdGlvblRodW5rLFxuICAgICAgZ2V0UnVubmluZ011dGF0aW9uc1RodW5rLFxuICAgICAgZ2V0UnVubmluZ1F1ZXJ5VGh1bmssXG4gICAgICBnZXRSdW5uaW5nUXVlcmllc1RodW5rXG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6IGNvcmVNb2R1bGVOYW1lLFxuICAgICAgaW5qZWN0RW5kcG9pbnQoZW5kcG9pbnROYW1lLCBkZWZpbml0aW9uKSB7XG4gICAgICAgIGNvbnN0IGFueUFwaSA9IGFwaTtcbiAgICAgICAgYW55QXBpLmVuZHBvaW50c1tlbmRwb2ludE5hbWVdID8/PSB7fTtcbiAgICAgICAgaWYgKGlzUXVlcnlEZWZpbml0aW9uKGRlZmluaXRpb24pKSB7XG4gICAgICAgICAgc2FmZUFzc2lnbihhbnlBcGkuZW5kcG9pbnRzW2VuZHBvaW50TmFtZV0sIHtcbiAgICAgICAgICAgIG5hbWU6IGVuZHBvaW50TmFtZSxcbiAgICAgICAgICAgIHNlbGVjdDogYnVpbGRRdWVyeVNlbGVjdG9yKGVuZHBvaW50TmFtZSwgZGVmaW5pdGlvbiksXG4gICAgICAgICAgICBpbml0aWF0ZTogYnVpbGRJbml0aWF0ZVF1ZXJ5KGVuZHBvaW50TmFtZSwgZGVmaW5pdGlvbilcbiAgICAgICAgICB9LCBidWlsZE1hdGNoVGh1bmtBY3Rpb25zKHF1ZXJ5VGh1bmssIGVuZHBvaW50TmFtZSkpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzTXV0YXRpb25EZWZpbml0aW9uKGRlZmluaXRpb24pKSB7XG4gICAgICAgICAgc2FmZUFzc2lnbihhbnlBcGkuZW5kcG9pbnRzW2VuZHBvaW50TmFtZV0sIHtcbiAgICAgICAgICAgIG5hbWU6IGVuZHBvaW50TmFtZSxcbiAgICAgICAgICAgIHNlbGVjdDogYnVpbGRNdXRhdGlvblNlbGVjdG9yKCksXG4gICAgICAgICAgICBpbml0aWF0ZTogYnVpbGRJbml0aWF0ZU11dGF0aW9uKGVuZHBvaW50TmFtZSlcbiAgICAgICAgICB9LCBidWlsZE1hdGNoVGh1bmtBY3Rpb25zKG11dGF0aW9uVGh1bmssIGVuZHBvaW50TmFtZSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIHNyYy9xdWVyeS9jb3JlL2luZGV4LnRzXG52YXIgY3JlYXRlQXBpID0gLyogQF9fUFVSRV9fICovIGJ1aWxkQ3JlYXRlQXBpKGNvcmVNb2R1bGUoKSk7XG5leHBvcnQge1xuICBRdWVyeVN0YXR1cyxcbiAgX05FVkVSLFxuICBidWlsZENyZWF0ZUFwaSxcbiAgY29weVdpdGhTdHJ1Y3R1cmFsU2hhcmluZyxcbiAgY29yZU1vZHVsZSxcbiAgY29yZU1vZHVsZU5hbWUsXG4gIGNyZWF0ZUFwaSxcbiAgZGVmYXVsdFNlcmlhbGl6ZVF1ZXJ5QXJncyxcbiAgZmFrZUJhc2VRdWVyeSxcbiAgZmV0Y2hCYXNlUXVlcnksXG4gIHJldHJ5LFxuICBzZXR1cExpc3RlbmVycyxcbiAgc2tpcFRva2VuXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cnRrLXF1ZXJ5Lm1vZGVybi5tanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@reduxjs/toolkit/dist/query/rtk-query.modern.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@reduxjs/toolkit/dist/redux-toolkit.modern.mjs":
/*!*********************************************************************!*\
  !*** ./node_modules/@reduxjs/toolkit/dist/redux-toolkit.modern.mjs ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ReducerType: () => (/* binding */ ReducerType),\n/* harmony export */   SHOULD_AUTOBATCH: () => (/* binding */ SHOULD_AUTOBATCH),\n/* harmony export */   TaskAbortError: () => (/* binding */ TaskAbortError),\n/* harmony export */   Tuple: () => (/* binding */ Tuple),\n/* harmony export */   __DO_NOT_USE__ActionTypes: () => (/* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.__DO_NOT_USE__ActionTypes),\n/* harmony export */   addListener: () => (/* binding */ addListener),\n/* harmony export */   applyMiddleware: () => (/* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.applyMiddleware),\n/* harmony export */   asyncThunkCreator: () => (/* binding */ asyncThunkCreator),\n/* harmony export */   autoBatchEnhancer: () => (/* binding */ autoBatchEnhancer),\n/* harmony export */   bindActionCreators: () => (/* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.bindActionCreators),\n/* harmony export */   buildCreateSlice: () => (/* binding */ buildCreateSlice),\n/* harmony export */   clearAllListeners: () => (/* binding */ clearAllListeners),\n/* harmony export */   combineReducers: () => (/* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.combineReducers),\n/* harmony export */   combineSlices: () => (/* binding */ combineSlices),\n/* harmony export */   compose: () => (/* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.compose),\n/* harmony export */   configureStore: () => (/* binding */ configureStore),\n/* harmony export */   createAction: () => (/* binding */ createAction),\n/* harmony export */   createActionCreatorInvariantMiddleware: () => (/* binding */ createActionCreatorInvariantMiddleware),\n/* harmony export */   createAsyncThunk: () => (/* binding */ createAsyncThunk),\n/* harmony export */   createDraftSafeSelector: () => (/* binding */ createDraftSafeSelector),\n/* harmony export */   createDraftSafeSelectorCreator: () => (/* binding */ createDraftSafeSelectorCreator),\n/* harmony export */   createDynamicMiddleware: () => (/* binding */ createDynamicMiddleware),\n/* harmony export */   createEntityAdapter: () => (/* binding */ createEntityAdapter),\n/* harmony export */   createImmutableStateInvariantMiddleware: () => (/* binding */ createImmutableStateInvariantMiddleware),\n/* harmony export */   createListenerMiddleware: () => (/* binding */ createListenerMiddleware),\n/* harmony export */   createNextState: () => (/* reexport safe */ immer__WEBPACK_IMPORTED_MODULE_2__.produce),\n/* harmony export */   createReducer: () => (/* binding */ createReducer),\n/* harmony export */   createSelector: () => (/* reexport safe */ reselect__WEBPACK_IMPORTED_MODULE_1__.createSelector),\n/* harmony export */   createSelectorCreator: () => (/* reexport safe */ reselect__WEBPACK_IMPORTED_MODULE_1__.createSelectorCreator),\n/* harmony export */   createSerializableStateInvariantMiddleware: () => (/* binding */ createSerializableStateInvariantMiddleware),\n/* harmony export */   createSlice: () => (/* binding */ createSlice),\n/* harmony export */   createStore: () => (/* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.createStore),\n/* harmony export */   current: () => (/* reexport safe */ immer__WEBPACK_IMPORTED_MODULE_2__.current),\n/* harmony export */   findNonSerializableValue: () => (/* binding */ findNonSerializableValue),\n/* harmony export */   formatProdErrorMessage: () => (/* binding */ formatProdErrorMessage),\n/* harmony export */   freeze: () => (/* reexport safe */ immer__WEBPACK_IMPORTED_MODULE_2__.freeze),\n/* harmony export */   isAction: () => (/* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.isAction),\n/* harmony export */   isActionCreator: () => (/* binding */ isActionCreator),\n/* harmony export */   isAllOf: () => (/* binding */ isAllOf),\n/* harmony export */   isAnyOf: () => (/* binding */ isAnyOf),\n/* harmony export */   isAsyncThunkAction: () => (/* binding */ isAsyncThunkAction),\n/* harmony export */   isDraft: () => (/* reexport safe */ immer__WEBPACK_IMPORTED_MODULE_2__.isDraft),\n/* harmony export */   isFluxStandardAction: () => (/* binding */ isFSA),\n/* harmony export */   isFulfilled: () => (/* binding */ isFulfilled),\n/* harmony export */   isImmutableDefault: () => (/* binding */ isImmutableDefault),\n/* harmony export */   isPending: () => (/* binding */ isPending),\n/* harmony export */   isPlain: () => (/* binding */ isPlain),\n/* harmony export */   isPlainObject: () => (/* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.isPlainObject),\n/* harmony export */   isRejected: () => (/* binding */ isRejected),\n/* harmony export */   isRejectedWithValue: () => (/* binding */ isRejectedWithValue),\n/* harmony export */   legacy_createStore: () => (/* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.legacy_createStore),\n/* harmony export */   lruMemoize: () => (/* reexport safe */ reselect__WEBPACK_IMPORTED_MODULE_1__.lruMemoize),\n/* harmony export */   miniSerializeError: () => (/* binding */ miniSerializeError),\n/* harmony export */   nanoid: () => (/* binding */ nanoid),\n/* harmony export */   original: () => (/* reexport safe */ immer__WEBPACK_IMPORTED_MODULE_2__.original),\n/* harmony export */   prepareAutoBatched: () => (/* binding */ prepareAutoBatched),\n/* harmony export */   removeListener: () => (/* binding */ removeListener),\n/* harmony export */   unwrapResult: () => (/* binding */ unwrapResult),\n/* harmony export */   weakMapMemoize: () => (/* reexport safe */ reselect__WEBPACK_IMPORTED_MODULE_1__.weakMapMemoize)\n/* harmony export */ });\n/* harmony import */ var redux__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! redux */ \"(ssr)/./node_modules/redux/dist/redux.mjs\");\n/* harmony import */ var immer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! immer */ \"(ssr)/./node_modules/immer/dist/immer.mjs\");\n/* harmony import */ var reselect__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! reselect */ \"(ssr)/./node_modules/reselect/dist/reselect.mjs\");\n/* harmony import */ var redux_thunk__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! redux-thunk */ \"(ssr)/./node_modules/@reduxjs/toolkit/node_modules/redux-thunk/dist/redux-thunk.mjs\");\n// src/index.ts\n\n\n\n\n// src/createDraftSafeSelector.ts\n\n\nvar createDraftSafeSelectorCreator = (...args) => {\n  const createSelector2 = (0,reselect__WEBPACK_IMPORTED_MODULE_1__.createSelectorCreator)(...args);\n  const createDraftSafeSelector2 = Object.assign((...args2) => {\n    const selector = createSelector2(...args2);\n    const wrappedSelector = (value, ...rest) => selector((0,immer__WEBPACK_IMPORTED_MODULE_2__.isDraft)(value) ? (0,immer__WEBPACK_IMPORTED_MODULE_2__.current)(value) : value, ...rest);\n    Object.assign(wrappedSelector, selector);\n    return wrappedSelector;\n  }, {\n    withTypes: () => createDraftSafeSelector2\n  });\n  return createDraftSafeSelector2;\n};\nvar createDraftSafeSelector = /* @__PURE__ */ createDraftSafeSelectorCreator(reselect__WEBPACK_IMPORTED_MODULE_1__.weakMapMemoize);\n\n// src/configureStore.ts\n\n\n// src/devtoolsExtension.ts\n\nvar composeWithDevTools = typeof window !== \"undefined\" && window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ : function() {\n  if (arguments.length === 0) return void 0;\n  if (typeof arguments[0] === \"object\") return redux__WEBPACK_IMPORTED_MODULE_0__.compose;\n  return redux__WEBPACK_IMPORTED_MODULE_0__.compose.apply(null, arguments);\n};\nvar devToolsEnhancer = typeof window !== \"undefined\" && window.__REDUX_DEVTOOLS_EXTENSION__ ? window.__REDUX_DEVTOOLS_EXTENSION__ : function() {\n  return function(noop3) {\n    return noop3;\n  };\n};\n\n// src/getDefaultMiddleware.ts\n\n\n// src/createAction.ts\n\n\n// src/tsHelpers.ts\nvar hasMatchFunction = (v) => {\n  return v && typeof v.match === \"function\";\n};\n\n// src/createAction.ts\nfunction createAction(type, prepareAction) {\n  function actionCreator(...args) {\n    if (prepareAction) {\n      let prepared = prepareAction(...args);\n      if (!prepared) {\n        throw new Error( false ? 0 : \"prepareAction did not return an object\");\n      }\n      return {\n        type,\n        payload: prepared.payload,\n        ...\"meta\" in prepared && {\n          meta: prepared.meta\n        },\n        ...\"error\" in prepared && {\n          error: prepared.error\n        }\n      };\n    }\n    return {\n      type,\n      payload: args[0]\n    };\n  }\n  actionCreator.toString = () => `${type}`;\n  actionCreator.type = type;\n  actionCreator.match = (action) => (0,redux__WEBPACK_IMPORTED_MODULE_0__.isAction)(action) && action.type === type;\n  return actionCreator;\n}\nfunction isActionCreator(action) {\n  return typeof action === \"function\" && \"type\" in action && // hasMatchFunction only wants Matchers but I don't see the point in rewriting it\n  hasMatchFunction(action);\n}\nfunction isFSA(action) {\n  return (0,redux__WEBPACK_IMPORTED_MODULE_0__.isAction)(action) && Object.keys(action).every(isValidKey);\n}\nfunction isValidKey(key) {\n  return [\"type\", \"payload\", \"error\", \"meta\"].indexOf(key) > -1;\n}\n\n// src/actionCreatorInvariantMiddleware.ts\nfunction getMessage(type) {\n  const splitType = type ? `${type}`.split(\"/\") : [];\n  const actionName = splitType[splitType.length - 1] || \"actionCreator\";\n  return `Detected an action creator with type \"${type || \"unknown\"}\" being dispatched. \nMake sure you're calling the action creator before dispatching, i.e. \\`dispatch(${actionName}())\\` instead of \\`dispatch(${actionName})\\`. This is necessary even if the action has no payload.`;\n}\nfunction createActionCreatorInvariantMiddleware(options = {}) {\n  if (false) {}\n  const {\n    isActionCreator: isActionCreator2 = isActionCreator\n  } = options;\n  return () => (next) => (action) => {\n    if (isActionCreator2(action)) {\n      console.warn(getMessage(action.type));\n    }\n    return next(action);\n  };\n}\n\n// src/utils.ts\n\nfunction getTimeMeasureUtils(maxDelay, fnName) {\n  let elapsed = 0;\n  return {\n    measureTime(fn) {\n      const started = Date.now();\n      try {\n        return fn();\n      } finally {\n        const finished = Date.now();\n        elapsed += finished - started;\n      }\n    },\n    warnIfExceeded() {\n      if (elapsed > maxDelay) {\n        console.warn(`${fnName} took ${elapsed}ms, which is more than the warning threshold of ${maxDelay}ms. \nIf your state or actions are very large, you may want to disable the middleware as it might cause too much of a slowdown in development mode. See https://redux-toolkit.js.org/api/getDefaultMiddleware for instructions.\nIt is disabled in production builds, so you don't need to worry about that.`);\n      }\n    }\n  };\n}\nfunction find(iterable, comparator) {\n  for (const entry of iterable) {\n    if (comparator(entry)) {\n      return entry;\n    }\n  }\n  return void 0;\n}\nvar Tuple = class _Tuple extends Array {\n  constructor(...items) {\n    super(...items);\n    Object.setPrototypeOf(this, _Tuple.prototype);\n  }\n  static get [Symbol.species]() {\n    return _Tuple;\n  }\n  concat(...arr) {\n    return super.concat.apply(this, arr);\n  }\n  prepend(...arr) {\n    if (arr.length === 1 && Array.isArray(arr[0])) {\n      return new _Tuple(...arr[0].concat(this));\n    }\n    return new _Tuple(...arr.concat(this));\n  }\n};\nfunction freezeDraftable(val) {\n  return (0,immer__WEBPACK_IMPORTED_MODULE_2__.isDraftable)(val) ? (0,immer__WEBPACK_IMPORTED_MODULE_2__.produce)(val, () => {\n  }) : val;\n}\nfunction emplace(map, key, handler) {\n  if (map.has(key)) {\n    let value = map.get(key);\n    if (handler.update) {\n      value = handler.update(value, key, map);\n      map.set(key, value);\n    }\n    return value;\n  }\n  if (!handler.insert) throw new Error( false ? 0 : \"No insert provided for key not already in map\");\n  const inserted = handler.insert(key, map);\n  map.set(key, inserted);\n  return inserted;\n}\n\n// src/immutableStateInvariantMiddleware.ts\nfunction isImmutableDefault(value) {\n  return typeof value !== \"object\" || value == null || Object.isFrozen(value);\n}\nfunction trackForMutations(isImmutable, ignorePaths, obj) {\n  const trackedProperties = trackProperties(isImmutable, ignorePaths, obj);\n  return {\n    detectMutations() {\n      return detectMutations(isImmutable, ignorePaths, trackedProperties, obj);\n    }\n  };\n}\nfunction trackProperties(isImmutable, ignorePaths = [], obj, path = \"\", checkedObjects = /* @__PURE__ */ new Set()) {\n  const tracked = {\n    value: obj\n  };\n  if (!isImmutable(obj) && !checkedObjects.has(obj)) {\n    checkedObjects.add(obj);\n    tracked.children = {};\n    for (const key in obj) {\n      const childPath = path ? path + \".\" + key : key;\n      if (ignorePaths.length && ignorePaths.indexOf(childPath) !== -1) {\n        continue;\n      }\n      tracked.children[key] = trackProperties(isImmutable, ignorePaths, obj[key], childPath);\n    }\n  }\n  return tracked;\n}\nfunction detectMutations(isImmutable, ignoredPaths = [], trackedProperty, obj, sameParentRef = false, path = \"\") {\n  const prevObj = trackedProperty ? trackedProperty.value : void 0;\n  const sameRef = prevObj === obj;\n  if (sameParentRef && !sameRef && !Number.isNaN(obj)) {\n    return {\n      wasMutated: true,\n      path\n    };\n  }\n  if (isImmutable(prevObj) || isImmutable(obj)) {\n    return {\n      wasMutated: false\n    };\n  }\n  const keysToDetect = {};\n  for (let key in trackedProperty.children) {\n    keysToDetect[key] = true;\n  }\n  for (let key in obj) {\n    keysToDetect[key] = true;\n  }\n  const hasIgnoredPaths = ignoredPaths.length > 0;\n  for (let key in keysToDetect) {\n    const nestedPath = path ? path + \".\" + key : key;\n    if (hasIgnoredPaths) {\n      const hasMatches = ignoredPaths.some((ignored) => {\n        if (ignored instanceof RegExp) {\n          return ignored.test(nestedPath);\n        }\n        return nestedPath === ignored;\n      });\n      if (hasMatches) {\n        continue;\n      }\n    }\n    const result = detectMutations(isImmutable, ignoredPaths, trackedProperty.children[key], obj[key], sameRef, nestedPath);\n    if (result.wasMutated) {\n      return result;\n    }\n  }\n  return {\n    wasMutated: false\n  };\n}\nfunction createImmutableStateInvariantMiddleware(options = {}) {\n  if (false) {} else {\n    let stringify2 = function(obj, serializer, indent, decycler) {\n      return JSON.stringify(obj, getSerialize2(serializer, decycler), indent);\n    }, getSerialize2 = function(serializer, decycler) {\n      let stack = [], keys = [];\n      if (!decycler) decycler = function(_, value) {\n        if (stack[0] === value) return \"[Circular ~]\";\n        return \"[Circular ~.\" + keys.slice(0, stack.indexOf(value)).join(\".\") + \"]\";\n      };\n      return function(key, value) {\n        if (stack.length > 0) {\n          var thisPos = stack.indexOf(this);\n          ~thisPos ? stack.splice(thisPos + 1) : stack.push(this);\n          ~thisPos ? keys.splice(thisPos, Infinity, key) : keys.push(key);\n          if (~stack.indexOf(value)) value = decycler.call(this, key, value);\n        } else stack.push(value);\n        return serializer == null ? value : serializer.call(this, key, value);\n      };\n    };\n    var stringify = stringify2, getSerialize = getSerialize2;\n    let {\n      isImmutable = isImmutableDefault,\n      ignoredPaths,\n      warnAfter = 32\n    } = options;\n    const track = trackForMutations.bind(null, isImmutable, ignoredPaths);\n    return ({\n      getState\n    }) => {\n      let state = getState();\n      let tracker = track(state);\n      let result;\n      return (next) => (action) => {\n        const measureUtils = getTimeMeasureUtils(warnAfter, \"ImmutableStateInvariantMiddleware\");\n        measureUtils.measureTime(() => {\n          state = getState();\n          result = tracker.detectMutations();\n          tracker = track(state);\n          if (result.wasMutated) {\n            throw new Error( false ? 0 : `A state mutation was detected between dispatches, in the path '${result.path || \"\"}'.  This may cause incorrect behavior. (https://redux.js.org/style-guide/style-guide#do-not-mutate-state)`);\n          }\n        });\n        const dispatchedAction = next(action);\n        measureUtils.measureTime(() => {\n          state = getState();\n          result = tracker.detectMutations();\n          tracker = track(state);\n          if (result.wasMutated) {\n            throw new Error( false ? 0 : `A state mutation was detected inside a dispatch, in the path: ${result.path || \"\"}. Take a look at the reducer(s) handling the action ${stringify2(action)}. (https://redux.js.org/style-guide/style-guide#do-not-mutate-state)`);\n          }\n        });\n        measureUtils.warnIfExceeded();\n        return dispatchedAction;\n      };\n    };\n  }\n}\n\n// src/serializableStateInvariantMiddleware.ts\n\nfunction isPlain(val) {\n  const type = typeof val;\n  return val == null || type === \"string\" || type === \"boolean\" || type === \"number\" || Array.isArray(val) || (0,redux__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(val);\n}\nfunction findNonSerializableValue(value, path = \"\", isSerializable = isPlain, getEntries, ignoredPaths = [], cache) {\n  let foundNestedSerializable;\n  if (!isSerializable(value)) {\n    return {\n      keyPath: path || \"<root>\",\n      value\n    };\n  }\n  if (typeof value !== \"object\" || value === null) {\n    return false;\n  }\n  if (cache?.has(value)) return false;\n  const entries = getEntries != null ? getEntries(value) : Object.entries(value);\n  const hasIgnoredPaths = ignoredPaths.length > 0;\n  for (const [key, nestedValue] of entries) {\n    const nestedPath = path ? path + \".\" + key : key;\n    if (hasIgnoredPaths) {\n      const hasMatches = ignoredPaths.some((ignored) => {\n        if (ignored instanceof RegExp) {\n          return ignored.test(nestedPath);\n        }\n        return nestedPath === ignored;\n      });\n      if (hasMatches) {\n        continue;\n      }\n    }\n    if (!isSerializable(nestedValue)) {\n      return {\n        keyPath: nestedPath,\n        value: nestedValue\n      };\n    }\n    if (typeof nestedValue === \"object\") {\n      foundNestedSerializable = findNonSerializableValue(nestedValue, nestedPath, isSerializable, getEntries, ignoredPaths, cache);\n      if (foundNestedSerializable) {\n        return foundNestedSerializable;\n      }\n    }\n  }\n  if (cache && isNestedFrozen(value)) cache.add(value);\n  return false;\n}\nfunction isNestedFrozen(value) {\n  if (!Object.isFrozen(value)) return false;\n  for (const nestedValue of Object.values(value)) {\n    if (typeof nestedValue !== \"object\" || nestedValue === null) continue;\n    if (!isNestedFrozen(nestedValue)) return false;\n  }\n  return true;\n}\nfunction createSerializableStateInvariantMiddleware(options = {}) {\n  if (false) {} else {\n    const {\n      isSerializable = isPlain,\n      getEntries,\n      ignoredActions = [],\n      ignoredActionPaths = [\"meta.arg\", \"meta.baseQueryMeta\"],\n      ignoredPaths = [],\n      warnAfter = 32,\n      ignoreState = false,\n      ignoreActions = false,\n      disableCache = false\n    } = options;\n    const cache = !disableCache && WeakSet ? /* @__PURE__ */ new WeakSet() : void 0;\n    return (storeAPI) => (next) => (action) => {\n      if (!(0,redux__WEBPACK_IMPORTED_MODULE_0__.isAction)(action)) {\n        return next(action);\n      }\n      const result = next(action);\n      const measureUtils = getTimeMeasureUtils(warnAfter, \"SerializableStateInvariantMiddleware\");\n      if (!ignoreActions && !(ignoredActions.length && ignoredActions.indexOf(action.type) !== -1)) {\n        measureUtils.measureTime(() => {\n          const foundActionNonSerializableValue = findNonSerializableValue(action, \"\", isSerializable, getEntries, ignoredActionPaths, cache);\n          if (foundActionNonSerializableValue) {\n            const {\n              keyPath,\n              value\n            } = foundActionNonSerializableValue;\n            console.error(`A non-serializable value was detected in an action, in the path: \\`${keyPath}\\`. Value:`, value, \"\\nTake a look at the logic that dispatched this action: \", action, \"\\n(See https://redux.js.org/faq/actions#why-should-type-be-a-string-or-at-least-serializable-why-should-my-action-types-be-constants)\", \"\\n(To allow non-serializable values see: https://redux-toolkit.js.org/usage/usage-guide#working-with-non-serializable-data)\");\n          }\n        });\n      }\n      if (!ignoreState) {\n        measureUtils.measureTime(() => {\n          const state = storeAPI.getState();\n          const foundStateNonSerializableValue = findNonSerializableValue(state, \"\", isSerializable, getEntries, ignoredPaths, cache);\n          if (foundStateNonSerializableValue) {\n            const {\n              keyPath,\n              value\n            } = foundStateNonSerializableValue;\n            console.error(`A non-serializable value was detected in the state, in the path: \\`${keyPath}\\`. Value:`, value, `\nTake a look at the reducer(s) handling this action type: ${action.type}.\n(See https://redux.js.org/faq/organizing-state#can-i-put-functions-promises-or-other-non-serializable-items-in-my-store-state)`);\n          }\n        });\n        measureUtils.warnIfExceeded();\n      }\n      return result;\n    };\n  }\n}\n\n// src/getDefaultMiddleware.ts\nfunction isBoolean(x) {\n  return typeof x === \"boolean\";\n}\nvar buildGetDefaultMiddleware = () => function getDefaultMiddleware(options) {\n  const {\n    thunk = true,\n    immutableCheck = true,\n    serializableCheck = true,\n    actionCreatorCheck = true\n  } = options ?? {};\n  let middlewareArray = new Tuple();\n  if (thunk) {\n    if (isBoolean(thunk)) {\n      middlewareArray.push(redux_thunk__WEBPACK_IMPORTED_MODULE_3__.thunk);\n    } else {\n      middlewareArray.push((0,redux_thunk__WEBPACK_IMPORTED_MODULE_3__.withExtraArgument)(thunk.extraArgument));\n    }\n  }\n  if (true) {\n    if (immutableCheck) {\n      let immutableOptions = {};\n      if (!isBoolean(immutableCheck)) {\n        immutableOptions = immutableCheck;\n      }\n      middlewareArray.unshift(createImmutableStateInvariantMiddleware(immutableOptions));\n    }\n    if (serializableCheck) {\n      let serializableOptions = {};\n      if (!isBoolean(serializableCheck)) {\n        serializableOptions = serializableCheck;\n      }\n      middlewareArray.push(createSerializableStateInvariantMiddleware(serializableOptions));\n    }\n    if (actionCreatorCheck) {\n      let actionCreatorOptions = {};\n      if (!isBoolean(actionCreatorCheck)) {\n        actionCreatorOptions = actionCreatorCheck;\n      }\n      middlewareArray.unshift(createActionCreatorInvariantMiddleware(actionCreatorOptions));\n    }\n  }\n  return middlewareArray;\n};\n\n// src/autoBatchEnhancer.ts\nvar SHOULD_AUTOBATCH = \"RTK_autoBatch\";\nvar prepareAutoBatched = () => (payload) => ({\n  payload,\n  meta: {\n    [SHOULD_AUTOBATCH]: true\n  }\n});\nvar createQueueWithTimer = (timeout) => {\n  return (notify) => {\n    setTimeout(notify, timeout);\n  };\n};\nvar rAF = typeof window !== \"undefined\" && window.requestAnimationFrame ? window.requestAnimationFrame : createQueueWithTimer(10);\nvar autoBatchEnhancer = (options = {\n  type: \"raf\"\n}) => (next) => (...args) => {\n  const store = next(...args);\n  let notifying = true;\n  let shouldNotifyAtEndOfTick = false;\n  let notificationQueued = false;\n  const listeners = /* @__PURE__ */ new Set();\n  const queueCallback = options.type === \"tick\" ? queueMicrotask : options.type === \"raf\" ? rAF : options.type === \"callback\" ? options.queueNotification : createQueueWithTimer(options.timeout);\n  const notifyListeners = () => {\n    notificationQueued = false;\n    if (shouldNotifyAtEndOfTick) {\n      shouldNotifyAtEndOfTick = false;\n      listeners.forEach((l) => l());\n    }\n  };\n  return Object.assign({}, store, {\n    // Override the base `store.subscribe` method to keep original listeners\n    // from running if we're delaying notifications\n    subscribe(listener2) {\n      const wrappedListener = () => notifying && listener2();\n      const unsubscribe = store.subscribe(wrappedListener);\n      listeners.add(listener2);\n      return () => {\n        unsubscribe();\n        listeners.delete(listener2);\n      };\n    },\n    // Override the base `store.dispatch` method so that we can check actions\n    // for the `shouldAutoBatch` flag and determine if batching is active\n    dispatch(action) {\n      try {\n        notifying = !action?.meta?.[SHOULD_AUTOBATCH];\n        shouldNotifyAtEndOfTick = !notifying;\n        if (shouldNotifyAtEndOfTick) {\n          if (!notificationQueued) {\n            notificationQueued = true;\n            queueCallback(notifyListeners);\n          }\n        }\n        return store.dispatch(action);\n      } finally {\n        notifying = true;\n      }\n    }\n  });\n};\n\n// src/getDefaultEnhancers.ts\nvar buildGetDefaultEnhancers = (middlewareEnhancer) => function getDefaultEnhancers(options) {\n  const {\n    autoBatch = true\n  } = options ?? {};\n  let enhancerArray = new Tuple(middlewareEnhancer);\n  if (autoBatch) {\n    enhancerArray.push(autoBatchEnhancer(typeof autoBatch === \"object\" ? autoBatch : void 0));\n  }\n  return enhancerArray;\n};\n\n// src/configureStore.ts\nfunction configureStore(options) {\n  const getDefaultMiddleware = buildGetDefaultMiddleware();\n  const {\n    reducer = void 0,\n    middleware,\n    devTools = true,\n    preloadedState = void 0,\n    enhancers = void 0\n  } = options || {};\n  let rootReducer;\n  if (typeof reducer === \"function\") {\n    rootReducer = reducer;\n  } else if ((0,redux__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(reducer)) {\n    rootReducer = (0,redux__WEBPACK_IMPORTED_MODULE_0__.combineReducers)(reducer);\n  } else {\n    throw new Error( false ? 0 : \"`reducer` is a required argument, and must be a function or an object of functions that can be passed to combineReducers\");\n  }\n  if ( true && middleware && typeof middleware !== \"function\") {\n    throw new Error( false ? 0 : \"`middleware` field must be a callback\");\n  }\n  let finalMiddleware;\n  if (typeof middleware === \"function\") {\n    finalMiddleware = middleware(getDefaultMiddleware);\n    if ( true && !Array.isArray(finalMiddleware)) {\n      throw new Error( false ? 0 : \"when using a middleware builder function, an array of middleware must be returned\");\n    }\n  } else {\n    finalMiddleware = getDefaultMiddleware();\n  }\n  if ( true && finalMiddleware.some((item) => typeof item !== \"function\")) {\n    throw new Error( false ? 0 : \"each middleware provided to configureStore must be a function\");\n  }\n  let finalCompose = redux__WEBPACK_IMPORTED_MODULE_0__.compose;\n  if (devTools) {\n    finalCompose = composeWithDevTools({\n      // Enable capture of stack traces for dispatched Redux actions\n      trace: \"development\" !== \"production\",\n      ...typeof devTools === \"object\" && devTools\n    });\n  }\n  const middlewareEnhancer = (0,redux__WEBPACK_IMPORTED_MODULE_0__.applyMiddleware)(...finalMiddleware);\n  const getDefaultEnhancers = buildGetDefaultEnhancers(middlewareEnhancer);\n  if ( true && enhancers && typeof enhancers !== \"function\") {\n    throw new Error( false ? 0 : \"`enhancers` field must be a callback\");\n  }\n  let storeEnhancers = typeof enhancers === \"function\" ? enhancers(getDefaultEnhancers) : getDefaultEnhancers();\n  if ( true && !Array.isArray(storeEnhancers)) {\n    throw new Error( false ? 0 : \"`enhancers` callback must return an array\");\n  }\n  if ( true && storeEnhancers.some((item) => typeof item !== \"function\")) {\n    throw new Error( false ? 0 : \"each enhancer provided to configureStore must be a function\");\n  }\n  if ( true && finalMiddleware.length && !storeEnhancers.includes(middlewareEnhancer)) {\n    console.error(\"middlewares were provided, but middleware enhancer was not included in final enhancers - make sure to call `getDefaultEnhancers`\");\n  }\n  const composedEnhancer = finalCompose(...storeEnhancers);\n  return (0,redux__WEBPACK_IMPORTED_MODULE_0__.createStore)(rootReducer, preloadedState, composedEnhancer);\n}\n\n// src/createReducer.ts\n\n\n// src/mapBuilders.ts\nfunction executeReducerBuilderCallback(builderCallback) {\n  const actionsMap = {};\n  const actionMatchers = [];\n  let defaultCaseReducer;\n  const builder = {\n    addCase(typeOrActionCreator, reducer) {\n      if (true) {\n        if (actionMatchers.length > 0) {\n          throw new Error( false ? 0 : \"`builder.addCase` should only be called before calling `builder.addMatcher`\");\n        }\n        if (defaultCaseReducer) {\n          throw new Error( false ? 0 : \"`builder.addCase` should only be called before calling `builder.addDefaultCase`\");\n        }\n      }\n      const type = typeof typeOrActionCreator === \"string\" ? typeOrActionCreator : typeOrActionCreator.type;\n      if (!type) {\n        throw new Error( false ? 0 : \"`builder.addCase` cannot be called with an empty action type\");\n      }\n      if (type in actionsMap) {\n        throw new Error( false ? 0 : `\\`builder.addCase\\` cannot be called with two reducers for the same action type '${type}'`);\n      }\n      actionsMap[type] = reducer;\n      return builder;\n    },\n    addMatcher(matcher, reducer) {\n      if (true) {\n        if (defaultCaseReducer) {\n          throw new Error( false ? 0 : \"`builder.addMatcher` should only be called before calling `builder.addDefaultCase`\");\n        }\n      }\n      actionMatchers.push({\n        matcher,\n        reducer\n      });\n      return builder;\n    },\n    addDefaultCase(reducer) {\n      if (true) {\n        if (defaultCaseReducer) {\n          throw new Error( false ? 0 : \"`builder.addDefaultCase` can only be called once\");\n        }\n      }\n      defaultCaseReducer = reducer;\n      return builder;\n    }\n  };\n  builderCallback(builder);\n  return [actionsMap, actionMatchers, defaultCaseReducer];\n}\n\n// src/createReducer.ts\nfunction isStateFunction(x) {\n  return typeof x === \"function\";\n}\nfunction createReducer(initialState, mapOrBuilderCallback) {\n  if (true) {\n    if (typeof mapOrBuilderCallback === \"object\") {\n      throw new Error( false ? 0 : \"The object notation for `createReducer` has been removed. Please use the 'builder callback' notation instead: https://redux-toolkit.js.org/api/createReducer\");\n    }\n  }\n  let [actionsMap, finalActionMatchers, finalDefaultCaseReducer] = executeReducerBuilderCallback(mapOrBuilderCallback);\n  let getInitialState;\n  if (isStateFunction(initialState)) {\n    getInitialState = () => freezeDraftable(initialState());\n  } else {\n    const frozenInitialState = freezeDraftable(initialState);\n    getInitialState = () => frozenInitialState;\n  }\n  function reducer(state = getInitialState(), action) {\n    let caseReducers = [actionsMap[action.type], ...finalActionMatchers.filter(({\n      matcher\n    }) => matcher(action)).map(({\n      reducer: reducer2\n    }) => reducer2)];\n    if (caseReducers.filter((cr) => !!cr).length === 0) {\n      caseReducers = [finalDefaultCaseReducer];\n    }\n    return caseReducers.reduce((previousState, caseReducer) => {\n      if (caseReducer) {\n        if ((0,immer__WEBPACK_IMPORTED_MODULE_2__.isDraft)(previousState)) {\n          const draft = previousState;\n          const result = caseReducer(draft, action);\n          if (result === void 0) {\n            return previousState;\n          }\n          return result;\n        } else if (!(0,immer__WEBPACK_IMPORTED_MODULE_2__.isDraftable)(previousState)) {\n          const result = caseReducer(previousState, action);\n          if (result === void 0) {\n            if (previousState === null) {\n              return previousState;\n            }\n            throw new Error( false ? 0 : \"A case reducer on a non-draftable value must not return undefined\");\n          }\n          return result;\n        } else {\n          return (0,immer__WEBPACK_IMPORTED_MODULE_2__.produce)(previousState, (draft) => {\n            return caseReducer(draft, action);\n          });\n        }\n      }\n      return previousState;\n    }, state);\n  }\n  reducer.getInitialState = getInitialState;\n  return reducer;\n}\n\n// src/matchers.ts\nvar matches = (matcher, action) => {\n  if (hasMatchFunction(matcher)) {\n    return matcher.match(action);\n  } else {\n    return matcher(action);\n  }\n};\nfunction isAnyOf(...matchers) {\n  return (action) => {\n    return matchers.some((matcher) => matches(matcher, action));\n  };\n}\nfunction isAllOf(...matchers) {\n  return (action) => {\n    return matchers.every((matcher) => matches(matcher, action));\n  };\n}\nfunction hasExpectedRequestMetadata(action, validStatus) {\n  if (!action || !action.meta) return false;\n  const hasValidRequestId = typeof action.meta.requestId === \"string\";\n  const hasValidRequestStatus = validStatus.indexOf(action.meta.requestStatus) > -1;\n  return hasValidRequestId && hasValidRequestStatus;\n}\nfunction isAsyncThunkArray(a) {\n  return typeof a[0] === \"function\" && \"pending\" in a[0] && \"fulfilled\" in a[0] && \"rejected\" in a[0];\n}\nfunction isPending(...asyncThunks) {\n  if (asyncThunks.length === 0) {\n    return (action) => hasExpectedRequestMetadata(action, [\"pending\"]);\n  }\n  if (!isAsyncThunkArray(asyncThunks)) {\n    return isPending()(asyncThunks[0]);\n  }\n  return isAnyOf(...asyncThunks.map((asyncThunk) => asyncThunk.pending));\n}\nfunction isRejected(...asyncThunks) {\n  if (asyncThunks.length === 0) {\n    return (action) => hasExpectedRequestMetadata(action, [\"rejected\"]);\n  }\n  if (!isAsyncThunkArray(asyncThunks)) {\n    return isRejected()(asyncThunks[0]);\n  }\n  return isAnyOf(...asyncThunks.map((asyncThunk) => asyncThunk.rejected));\n}\nfunction isRejectedWithValue(...asyncThunks) {\n  const hasFlag = (action) => {\n    return action && action.meta && action.meta.rejectedWithValue;\n  };\n  if (asyncThunks.length === 0) {\n    return isAllOf(isRejected(...asyncThunks), hasFlag);\n  }\n  if (!isAsyncThunkArray(asyncThunks)) {\n    return isRejectedWithValue()(asyncThunks[0]);\n  }\n  return isAllOf(isRejected(...asyncThunks), hasFlag);\n}\nfunction isFulfilled(...asyncThunks) {\n  if (asyncThunks.length === 0) {\n    return (action) => hasExpectedRequestMetadata(action, [\"fulfilled\"]);\n  }\n  if (!isAsyncThunkArray(asyncThunks)) {\n    return isFulfilled()(asyncThunks[0]);\n  }\n  return isAnyOf(...asyncThunks.map((asyncThunk) => asyncThunk.fulfilled));\n}\nfunction isAsyncThunkAction(...asyncThunks) {\n  if (asyncThunks.length === 0) {\n    return (action) => hasExpectedRequestMetadata(action, [\"pending\", \"fulfilled\", \"rejected\"]);\n  }\n  if (!isAsyncThunkArray(asyncThunks)) {\n    return isAsyncThunkAction()(asyncThunks[0]);\n  }\n  return isAnyOf(...asyncThunks.flatMap((asyncThunk) => [asyncThunk.pending, asyncThunk.rejected, asyncThunk.fulfilled]));\n}\n\n// src/nanoid.ts\nvar urlAlphabet = \"ModuleSymbhasOwnPr-0123456789ABCDEFGHNRVfgctiUvz_KqYTJkLxpZXIjQW\";\nvar nanoid = (size = 21) => {\n  let id = \"\";\n  let i = size;\n  while (i--) {\n    id += urlAlphabet[Math.random() * 64 | 0];\n  }\n  return id;\n};\n\n// src/createAsyncThunk.ts\nvar commonProperties = [\"name\", \"message\", \"stack\", \"code\"];\nvar RejectWithValue = class {\n  constructor(payload, meta) {\n    this.payload = payload;\n    this.meta = meta;\n  }\n  /*\n  type-only property to distinguish between RejectWithValue and FulfillWithMeta\n  does not exist at runtime\n  */\n  _type;\n};\nvar FulfillWithMeta = class {\n  constructor(payload, meta) {\n    this.payload = payload;\n    this.meta = meta;\n  }\n  /*\n  type-only property to distinguish between RejectWithValue and FulfillWithMeta\n  does not exist at runtime\n  */\n  _type;\n};\nvar miniSerializeError = (value) => {\n  if (typeof value === \"object\" && value !== null) {\n    const simpleError = {};\n    for (const property of commonProperties) {\n      if (typeof value[property] === \"string\") {\n        simpleError[property] = value[property];\n      }\n    }\n    return simpleError;\n  }\n  return {\n    message: String(value)\n  };\n};\nvar createAsyncThunk = /* @__PURE__ */ (() => {\n  function createAsyncThunk2(typePrefix, payloadCreator, options) {\n    const fulfilled = createAction(typePrefix + \"/fulfilled\", (payload, requestId, arg, meta) => ({\n      payload,\n      meta: {\n        ...meta || {},\n        arg,\n        requestId,\n        requestStatus: \"fulfilled\"\n      }\n    }));\n    const pending = createAction(typePrefix + \"/pending\", (requestId, arg, meta) => ({\n      payload: void 0,\n      meta: {\n        ...meta || {},\n        arg,\n        requestId,\n        requestStatus: \"pending\"\n      }\n    }));\n    const rejected = createAction(typePrefix + \"/rejected\", (error, requestId, arg, payload, meta) => ({\n      payload,\n      error: (options && options.serializeError || miniSerializeError)(error || \"Rejected\"),\n      meta: {\n        ...meta || {},\n        arg,\n        requestId,\n        rejectedWithValue: !!payload,\n        requestStatus: \"rejected\",\n        aborted: error?.name === \"AbortError\",\n        condition: error?.name === \"ConditionError\"\n      }\n    }));\n    function actionCreator(arg) {\n      return (dispatch, getState, extra) => {\n        const requestId = options?.idGenerator ? options.idGenerator(arg) : nanoid();\n        const abortController = new AbortController();\n        let abortHandler;\n        let abortReason;\n        function abort(reason) {\n          abortReason = reason;\n          abortController.abort();\n        }\n        const promise = async function() {\n          let finalAction;\n          try {\n            let conditionResult = options?.condition?.(arg, {\n              getState,\n              extra\n            });\n            if (isThenable(conditionResult)) {\n              conditionResult = await conditionResult;\n            }\n            if (conditionResult === false || abortController.signal.aborted) {\n              throw {\n                name: \"ConditionError\",\n                message: \"Aborted due to condition callback returning false.\"\n              };\n            }\n            const abortedPromise = new Promise((_, reject) => {\n              abortHandler = () => {\n                reject({\n                  name: \"AbortError\",\n                  message: abortReason || \"Aborted\"\n                });\n              };\n              abortController.signal.addEventListener(\"abort\", abortHandler);\n            });\n            dispatch(pending(requestId, arg, options?.getPendingMeta?.({\n              requestId,\n              arg\n            }, {\n              getState,\n              extra\n            })));\n            finalAction = await Promise.race([abortedPromise, Promise.resolve(payloadCreator(arg, {\n              dispatch,\n              getState,\n              extra,\n              requestId,\n              signal: abortController.signal,\n              abort,\n              rejectWithValue: (value, meta) => {\n                return new RejectWithValue(value, meta);\n              },\n              fulfillWithValue: (value, meta) => {\n                return new FulfillWithMeta(value, meta);\n              }\n            })).then((result) => {\n              if (result instanceof RejectWithValue) {\n                throw result;\n              }\n              if (result instanceof FulfillWithMeta) {\n                return fulfilled(result.payload, requestId, arg, result.meta);\n              }\n              return fulfilled(result, requestId, arg);\n            })]);\n          } catch (err) {\n            finalAction = err instanceof RejectWithValue ? rejected(null, requestId, arg, err.payload, err.meta) : rejected(err, requestId, arg);\n          } finally {\n            if (abortHandler) {\n              abortController.signal.removeEventListener(\"abort\", abortHandler);\n            }\n          }\n          const skipDispatch = options && !options.dispatchConditionRejection && rejected.match(finalAction) && finalAction.meta.condition;\n          if (!skipDispatch) {\n            dispatch(finalAction);\n          }\n          return finalAction;\n        }();\n        return Object.assign(promise, {\n          abort,\n          requestId,\n          arg,\n          unwrap() {\n            return promise.then(unwrapResult);\n          }\n        });\n      };\n    }\n    return Object.assign(actionCreator, {\n      pending,\n      rejected,\n      fulfilled,\n      settled: isAnyOf(rejected, fulfilled),\n      typePrefix\n    });\n  }\n  createAsyncThunk2.withTypes = () => createAsyncThunk2;\n  return createAsyncThunk2;\n})();\nfunction unwrapResult(action) {\n  if (action.meta && action.meta.rejectedWithValue) {\n    throw action.payload;\n  }\n  if (action.error) {\n    throw action.error;\n  }\n  return action.payload;\n}\nfunction isThenable(value) {\n  return value !== null && typeof value === \"object\" && typeof value.then === \"function\";\n}\n\n// src/createSlice.ts\nvar asyncThunkSymbol = /* @__PURE__ */ Symbol.for(\"rtk-slice-createasyncthunk\");\nvar asyncThunkCreator = {\n  [asyncThunkSymbol]: createAsyncThunk\n};\nvar ReducerType = /* @__PURE__ */ ((ReducerType2) => {\n  ReducerType2[\"reducer\"] = \"reducer\";\n  ReducerType2[\"reducerWithPrepare\"] = \"reducerWithPrepare\";\n  ReducerType2[\"asyncThunk\"] = \"asyncThunk\";\n  return ReducerType2;\n})(ReducerType || {});\nfunction getType(slice, actionKey) {\n  return `${slice}/${actionKey}`;\n}\nfunction buildCreateSlice({\n  creators\n} = {}) {\n  const cAT = creators?.asyncThunk?.[asyncThunkSymbol];\n  return function createSlice2(options) {\n    const {\n      name,\n      reducerPath = name\n    } = options;\n    if (!name) {\n      throw new Error( false ? 0 : \"`name` is a required option for createSlice\");\n    }\n    if (typeof process !== \"undefined\" && \"development\" === \"development\") {\n      if (options.initialState === void 0) {\n        console.error(\"You must provide an `initialState` value that is not `undefined`. You may have misspelled `initialState`\");\n      }\n    }\n    const reducers = (typeof options.reducers === \"function\" ? options.reducers(buildReducerCreators()) : options.reducers) || {};\n    const reducerNames = Object.keys(reducers);\n    const context = {\n      sliceCaseReducersByName: {},\n      sliceCaseReducersByType: {},\n      actionCreators: {},\n      sliceMatchers: []\n    };\n    const contextMethods = {\n      addCase(typeOrActionCreator, reducer2) {\n        const type = typeof typeOrActionCreator === \"string\" ? typeOrActionCreator : typeOrActionCreator.type;\n        if (!type) {\n          throw new Error( false ? 0 : \"`context.addCase` cannot be called with an empty action type\");\n        }\n        if (type in context.sliceCaseReducersByType) {\n          throw new Error( false ? 0 : \"`context.addCase` cannot be called with two reducers for the same action type: \" + type);\n        }\n        context.sliceCaseReducersByType[type] = reducer2;\n        return contextMethods;\n      },\n      addMatcher(matcher, reducer2) {\n        context.sliceMatchers.push({\n          matcher,\n          reducer: reducer2\n        });\n        return contextMethods;\n      },\n      exposeAction(name2, actionCreator) {\n        context.actionCreators[name2] = actionCreator;\n        return contextMethods;\n      },\n      exposeCaseReducer(name2, reducer2) {\n        context.sliceCaseReducersByName[name2] = reducer2;\n        return contextMethods;\n      }\n    };\n    reducerNames.forEach((reducerName) => {\n      const reducerDefinition = reducers[reducerName];\n      const reducerDetails = {\n        reducerName,\n        type: getType(name, reducerName),\n        createNotation: typeof options.reducers === \"function\"\n      };\n      if (isAsyncThunkSliceReducerDefinition(reducerDefinition)) {\n        handleThunkCaseReducerDefinition(reducerDetails, reducerDefinition, contextMethods, cAT);\n      } else {\n        handleNormalReducerDefinition(reducerDetails, reducerDefinition, contextMethods);\n      }\n    });\n    function buildReducer() {\n      if (true) {\n        if (typeof options.extraReducers === \"object\") {\n          throw new Error( false ? 0 : \"The object notation for `createSlice.extraReducers` has been removed. Please use the 'builder callback' notation instead: https://redux-toolkit.js.org/api/createSlice\");\n        }\n      }\n      const [extraReducers = {}, actionMatchers = [], defaultCaseReducer = void 0] = typeof options.extraReducers === \"function\" ? executeReducerBuilderCallback(options.extraReducers) : [options.extraReducers];\n      const finalCaseReducers = {\n        ...extraReducers,\n        ...context.sliceCaseReducersByType\n      };\n      return createReducer(options.initialState, (builder) => {\n        for (let key in finalCaseReducers) {\n          builder.addCase(key, finalCaseReducers[key]);\n        }\n        for (let sM of context.sliceMatchers) {\n          builder.addMatcher(sM.matcher, sM.reducer);\n        }\n        for (let m of actionMatchers) {\n          builder.addMatcher(m.matcher, m.reducer);\n        }\n        if (defaultCaseReducer) {\n          builder.addDefaultCase(defaultCaseReducer);\n        }\n      });\n    }\n    const selectSelf = (state) => state;\n    const injectedSelectorCache = /* @__PURE__ */ new Map();\n    let _reducer;\n    function reducer(state, action) {\n      if (!_reducer) _reducer = buildReducer();\n      return _reducer(state, action);\n    }\n    function getInitialState() {\n      if (!_reducer) _reducer = buildReducer();\n      return _reducer.getInitialState();\n    }\n    function makeSelectorProps(reducerPath2, injected = false) {\n      function selectSlice(state) {\n        let sliceState = state[reducerPath2];\n        if (typeof sliceState === \"undefined\") {\n          if (injected) {\n            sliceState = getInitialState();\n          } else if (true) {\n            throw new Error( false ? 0 : \"selectSlice returned undefined for an uninjected slice reducer\");\n          }\n        }\n        return sliceState;\n      }\n      function getSelectors(selectState = selectSelf) {\n        const selectorCache = emplace(injectedSelectorCache, injected, {\n          insert: () => /* @__PURE__ */ new WeakMap()\n        });\n        return emplace(selectorCache, selectState, {\n          insert: () => {\n            const map = {};\n            for (const [name2, selector] of Object.entries(options.selectors ?? {})) {\n              map[name2] = wrapSelector(selector, selectState, getInitialState, injected);\n            }\n            return map;\n          }\n        });\n      }\n      return {\n        reducerPath: reducerPath2,\n        getSelectors,\n        get selectors() {\n          return getSelectors(selectSlice);\n        },\n        selectSlice\n      };\n    }\n    const slice = {\n      name,\n      reducer,\n      actions: context.actionCreators,\n      caseReducers: context.sliceCaseReducersByName,\n      getInitialState,\n      ...makeSelectorProps(reducerPath),\n      injectInto(injectable, {\n        reducerPath: pathOpt,\n        ...config\n      } = {}) {\n        const newReducerPath = pathOpt ?? reducerPath;\n        injectable.inject({\n          reducerPath: newReducerPath,\n          reducer\n        }, config);\n        return {\n          ...slice,\n          ...makeSelectorProps(newReducerPath, true)\n        };\n      }\n    };\n    return slice;\n  };\n}\nfunction wrapSelector(selector, selectState, getInitialState, injected) {\n  function wrapper(rootState, ...args) {\n    let sliceState = selectState(rootState);\n    if (typeof sliceState === \"undefined\") {\n      if (injected) {\n        sliceState = getInitialState();\n      } else if (true) {\n        throw new Error( false ? 0 : \"selectState returned undefined for an uninjected slice reducer\");\n      }\n    }\n    return selector(sliceState, ...args);\n  }\n  wrapper.unwrapped = selector;\n  return wrapper;\n}\nvar createSlice = /* @__PURE__ */ buildCreateSlice();\nfunction buildReducerCreators() {\n  function asyncThunk(payloadCreator, config) {\n    return {\n      _reducerDefinitionType: \"asyncThunk\" /* asyncThunk */,\n      payloadCreator,\n      ...config\n    };\n  }\n  asyncThunk.withTypes = () => asyncThunk;\n  return {\n    reducer(caseReducer) {\n      return Object.assign({\n        // hack so the wrapping function has the same name as the original\n        // we need to create a wrapper so the `reducerDefinitionType` is not assigned to the original\n        [caseReducer.name](...args) {\n          return caseReducer(...args);\n        }\n      }[caseReducer.name], {\n        _reducerDefinitionType: \"reducer\" /* reducer */\n      });\n    },\n    preparedReducer(prepare, reducer) {\n      return {\n        _reducerDefinitionType: \"reducerWithPrepare\" /* reducerWithPrepare */,\n        prepare,\n        reducer\n      };\n    },\n    asyncThunk\n  };\n}\nfunction handleNormalReducerDefinition({\n  type,\n  reducerName,\n  createNotation\n}, maybeReducerWithPrepare, context) {\n  let caseReducer;\n  let prepareCallback;\n  if (\"reducer\" in maybeReducerWithPrepare) {\n    if (createNotation && !isCaseReducerWithPrepareDefinition(maybeReducerWithPrepare)) {\n      throw new Error( false ? 0 : \"Please use the `create.preparedReducer` notation for prepared action creators with the `create` notation.\");\n    }\n    caseReducer = maybeReducerWithPrepare.reducer;\n    prepareCallback = maybeReducerWithPrepare.prepare;\n  } else {\n    caseReducer = maybeReducerWithPrepare;\n  }\n  context.addCase(type, caseReducer).exposeCaseReducer(reducerName, caseReducer).exposeAction(reducerName, prepareCallback ? createAction(type, prepareCallback) : createAction(type));\n}\nfunction isAsyncThunkSliceReducerDefinition(reducerDefinition) {\n  return reducerDefinition._reducerDefinitionType === \"asyncThunk\" /* asyncThunk */;\n}\nfunction isCaseReducerWithPrepareDefinition(reducerDefinition) {\n  return reducerDefinition._reducerDefinitionType === \"reducerWithPrepare\" /* reducerWithPrepare */;\n}\nfunction handleThunkCaseReducerDefinition({\n  type,\n  reducerName\n}, reducerDefinition, context, cAT) {\n  if (!cAT) {\n    throw new Error( false ? 0 : \"Cannot use `create.asyncThunk` in the built-in `createSlice`. Use `buildCreateSlice({ creators: { asyncThunk: asyncThunkCreator } })` to create a customised version of `createSlice`.\");\n  }\n  const {\n    payloadCreator,\n    fulfilled,\n    pending,\n    rejected,\n    settled,\n    options\n  } = reducerDefinition;\n  const thunk = cAT(type, payloadCreator, options);\n  context.exposeAction(reducerName, thunk);\n  if (fulfilled) {\n    context.addCase(thunk.fulfilled, fulfilled);\n  }\n  if (pending) {\n    context.addCase(thunk.pending, pending);\n  }\n  if (rejected) {\n    context.addCase(thunk.rejected, rejected);\n  }\n  if (settled) {\n    context.addMatcher(thunk.settled, settled);\n  }\n  context.exposeCaseReducer(reducerName, {\n    fulfilled: fulfilled || noop,\n    pending: pending || noop,\n    rejected: rejected || noop,\n    settled: settled || noop\n  });\n}\nfunction noop() {\n}\n\n// src/entities/entity_state.ts\nfunction getInitialEntityState() {\n  return {\n    ids: [],\n    entities: {}\n  };\n}\nfunction createInitialStateFactory(stateAdapter) {\n  function getInitialState(additionalState = {}, entities) {\n    const state = Object.assign(getInitialEntityState(), additionalState);\n    return entities ? stateAdapter.setAll(state, entities) : state;\n  }\n  return {\n    getInitialState\n  };\n}\n\n// src/entities/state_selectors.ts\nfunction createSelectorsFactory() {\n  function getSelectors(selectState, options = {}) {\n    const {\n      createSelector: createSelector2 = createDraftSafeSelector\n    } = options;\n    const selectIds = (state) => state.ids;\n    const selectEntities = (state) => state.entities;\n    const selectAll = createSelector2(selectIds, selectEntities, (ids, entities) => ids.map((id) => entities[id]));\n    const selectId = (_, id) => id;\n    const selectById = (entities, id) => entities[id];\n    const selectTotal = createSelector2(selectIds, (ids) => ids.length);\n    if (!selectState) {\n      return {\n        selectIds,\n        selectEntities,\n        selectAll,\n        selectTotal,\n        selectById: createSelector2(selectEntities, selectId, selectById)\n      };\n    }\n    const selectGlobalizedEntities = createSelector2(selectState, selectEntities);\n    return {\n      selectIds: createSelector2(selectState, selectIds),\n      selectEntities: selectGlobalizedEntities,\n      selectAll: createSelector2(selectState, selectAll),\n      selectTotal: createSelector2(selectState, selectTotal),\n      selectById: createSelector2(selectGlobalizedEntities, selectId, selectById)\n    };\n  }\n  return {\n    getSelectors\n  };\n}\n\n// src/entities/state_adapter.ts\n\nvar isDraftTyped = immer__WEBPACK_IMPORTED_MODULE_2__.isDraft;\nfunction createSingleArgumentStateOperator(mutator) {\n  const operator = createStateOperator((_, state) => mutator(state));\n  return function operation(state) {\n    return operator(state, void 0);\n  };\n}\nfunction createStateOperator(mutator) {\n  return function operation(state, arg) {\n    function isPayloadActionArgument(arg2) {\n      return isFSA(arg2);\n    }\n    const runMutator = (draft) => {\n      if (isPayloadActionArgument(arg)) {\n        mutator(arg.payload, draft);\n      } else {\n        mutator(arg, draft);\n      }\n    };\n    if (isDraftTyped(state)) {\n      runMutator(state);\n      return state;\n    }\n    return (0,immer__WEBPACK_IMPORTED_MODULE_2__.produce)(state, runMutator);\n  };\n}\n\n// src/entities/utils.ts\n\nfunction selectIdValue(entity, selectId) {\n  const key = selectId(entity);\n  if ( true && key === void 0) {\n    console.warn(\"The entity passed to the `selectId` implementation returned undefined.\", \"You should probably provide your own `selectId` implementation.\", \"The entity that was passed:\", entity, \"The `selectId` implementation:\", selectId.toString());\n  }\n  return key;\n}\nfunction ensureEntitiesArray(entities) {\n  if (!Array.isArray(entities)) {\n    entities = Object.values(entities);\n  }\n  return entities;\n}\nfunction getCurrent(value) {\n  return (0,immer__WEBPACK_IMPORTED_MODULE_2__.isDraft)(value) ? (0,immer__WEBPACK_IMPORTED_MODULE_2__.current)(value) : value;\n}\nfunction splitAddedUpdatedEntities(newEntities, selectId, state) {\n  newEntities = ensureEntitiesArray(newEntities);\n  const existingIdsArray = getCurrent(state.ids);\n  const existingIds = new Set(existingIdsArray);\n  const added = [];\n  const updated = [];\n  for (const entity of newEntities) {\n    const id = selectIdValue(entity, selectId);\n    if (existingIds.has(id)) {\n      updated.push({\n        id,\n        changes: entity\n      });\n    } else {\n      added.push(entity);\n    }\n  }\n  return [added, updated, existingIdsArray];\n}\n\n// src/entities/unsorted_state_adapter.ts\nfunction createUnsortedStateAdapter(selectId) {\n  function addOneMutably(entity, state) {\n    const key = selectIdValue(entity, selectId);\n    if (key in state.entities) {\n      return;\n    }\n    state.ids.push(key);\n    state.entities[key] = entity;\n  }\n  function addManyMutably(newEntities, state) {\n    newEntities = ensureEntitiesArray(newEntities);\n    for (const entity of newEntities) {\n      addOneMutably(entity, state);\n    }\n  }\n  function setOneMutably(entity, state) {\n    const key = selectIdValue(entity, selectId);\n    if (!(key in state.entities)) {\n      state.ids.push(key);\n    }\n    ;\n    state.entities[key] = entity;\n  }\n  function setManyMutably(newEntities, state) {\n    newEntities = ensureEntitiesArray(newEntities);\n    for (const entity of newEntities) {\n      setOneMutably(entity, state);\n    }\n  }\n  function setAllMutably(newEntities, state) {\n    newEntities = ensureEntitiesArray(newEntities);\n    state.ids = [];\n    state.entities = {};\n    addManyMutably(newEntities, state);\n  }\n  function removeOneMutably(key, state) {\n    return removeManyMutably([key], state);\n  }\n  function removeManyMutably(keys, state) {\n    let didMutate = false;\n    keys.forEach((key) => {\n      if (key in state.entities) {\n        delete state.entities[key];\n        didMutate = true;\n      }\n    });\n    if (didMutate) {\n      state.ids = state.ids.filter((id) => id in state.entities);\n    }\n  }\n  function removeAllMutably(state) {\n    Object.assign(state, {\n      ids: [],\n      entities: {}\n    });\n  }\n  function takeNewKey(keys, update, state) {\n    const original3 = state.entities[update.id];\n    if (original3 === void 0) {\n      return false;\n    }\n    const updated = Object.assign({}, original3, update.changes);\n    const newKey = selectIdValue(updated, selectId);\n    const hasNewKey = newKey !== update.id;\n    if (hasNewKey) {\n      keys[update.id] = newKey;\n      delete state.entities[update.id];\n    }\n    ;\n    state.entities[newKey] = updated;\n    return hasNewKey;\n  }\n  function updateOneMutably(update, state) {\n    return updateManyMutably([update], state);\n  }\n  function updateManyMutably(updates, state) {\n    const newKeys = {};\n    const updatesPerEntity = {};\n    updates.forEach((update) => {\n      if (update.id in state.entities) {\n        updatesPerEntity[update.id] = {\n          id: update.id,\n          // Spreads ignore falsy values, so this works even if there isn't\n          // an existing update already at this key\n          changes: {\n            ...updatesPerEntity[update.id]?.changes,\n            ...update.changes\n          }\n        };\n      }\n    });\n    updates = Object.values(updatesPerEntity);\n    const didMutateEntities = updates.length > 0;\n    if (didMutateEntities) {\n      const didMutateIds = updates.filter((update) => takeNewKey(newKeys, update, state)).length > 0;\n      if (didMutateIds) {\n        state.ids = Object.values(state.entities).map((e) => selectIdValue(e, selectId));\n      }\n    }\n  }\n  function upsertOneMutably(entity, state) {\n    return upsertManyMutably([entity], state);\n  }\n  function upsertManyMutably(newEntities, state) {\n    const [added, updated] = splitAddedUpdatedEntities(newEntities, selectId, state);\n    updateManyMutably(updated, state);\n    addManyMutably(added, state);\n  }\n  return {\n    removeAll: createSingleArgumentStateOperator(removeAllMutably),\n    addOne: createStateOperator(addOneMutably),\n    addMany: createStateOperator(addManyMutably),\n    setOne: createStateOperator(setOneMutably),\n    setMany: createStateOperator(setManyMutably),\n    setAll: createStateOperator(setAllMutably),\n    updateOne: createStateOperator(updateOneMutably),\n    updateMany: createStateOperator(updateManyMutably),\n    upsertOne: createStateOperator(upsertOneMutably),\n    upsertMany: createStateOperator(upsertManyMutably),\n    removeOne: createStateOperator(removeOneMutably),\n    removeMany: createStateOperator(removeManyMutably)\n  };\n}\n\n// src/entities/sorted_state_adapter.ts\nfunction findInsertIndex(sortedItems, item, comparisonFunction) {\n  let lowIndex = 0;\n  let highIndex = sortedItems.length;\n  while (lowIndex < highIndex) {\n    let middleIndex = lowIndex + highIndex >>> 1;\n    const currentItem = sortedItems[middleIndex];\n    const res = comparisonFunction(item, currentItem);\n    if (res >= 0) {\n      lowIndex = middleIndex + 1;\n    } else {\n      highIndex = middleIndex;\n    }\n  }\n  return lowIndex;\n}\nfunction insert(sortedItems, item, comparisonFunction) {\n  const insertAtIndex = findInsertIndex(sortedItems, item, comparisonFunction);\n  sortedItems.splice(insertAtIndex, 0, item);\n  return sortedItems;\n}\nfunction createSortedStateAdapter(selectId, comparer) {\n  const {\n    removeOne,\n    removeMany,\n    removeAll\n  } = createUnsortedStateAdapter(selectId);\n  function addOneMutably(entity, state) {\n    return addManyMutably([entity], state);\n  }\n  function addManyMutably(newEntities, state, existingIds) {\n    newEntities = ensureEntitiesArray(newEntities);\n    const existingKeys = new Set(existingIds ?? getCurrent(state.ids));\n    const models = newEntities.filter((model) => !existingKeys.has(selectIdValue(model, selectId)));\n    if (models.length !== 0) {\n      mergeFunction(state, models);\n    }\n  }\n  function setOneMutably(entity, state) {\n    return setManyMutably([entity], state);\n  }\n  function setManyMutably(newEntities, state) {\n    newEntities = ensureEntitiesArray(newEntities);\n    if (newEntities.length !== 0) {\n      for (const item of newEntities) {\n        delete state.entities[selectId(item)];\n      }\n      mergeFunction(state, newEntities);\n    }\n  }\n  function setAllMutably(newEntities, state) {\n    newEntities = ensureEntitiesArray(newEntities);\n    state.entities = {};\n    state.ids = [];\n    addManyMutably(newEntities, state, []);\n  }\n  function updateOneMutably(update, state) {\n    return updateManyMutably([update], state);\n  }\n  function updateManyMutably(updates, state) {\n    let appliedUpdates = false;\n    let replacedIds = false;\n    for (let update of updates) {\n      const entity = state.entities[update.id];\n      if (!entity) {\n        continue;\n      }\n      appliedUpdates = true;\n      Object.assign(entity, update.changes);\n      const newId = selectId(entity);\n      if (update.id !== newId) {\n        replacedIds = true;\n        delete state.entities[update.id];\n        const oldIndex = state.ids.indexOf(update.id);\n        state.ids[oldIndex] = newId;\n        state.entities[newId] = entity;\n      }\n    }\n    if (appliedUpdates) {\n      mergeFunction(state, [], appliedUpdates, replacedIds);\n    }\n  }\n  function upsertOneMutably(entity, state) {\n    return upsertManyMutably([entity], state);\n  }\n  function upsertManyMutably(newEntities, state) {\n    const [added, updated, existingIdsArray] = splitAddedUpdatedEntities(newEntities, selectId, state);\n    if (updated.length) {\n      updateManyMutably(updated, state);\n    }\n    if (added.length) {\n      addManyMutably(added, state, existingIdsArray);\n    }\n  }\n  function areArraysEqual(a, b) {\n    if (a.length !== b.length) {\n      return false;\n    }\n    for (let i = 0; i < a.length; i++) {\n      if (a[i] === b[i]) {\n        continue;\n      }\n      return false;\n    }\n    return true;\n  }\n  const mergeFunction = (state, addedItems, appliedUpdates, replacedIds) => {\n    const currentEntities = getCurrent(state.entities);\n    const currentIds = getCurrent(state.ids);\n    const stateEntities = state.entities;\n    let ids = currentIds;\n    if (replacedIds) {\n      ids = new Set(currentIds);\n    }\n    let sortedEntities = [];\n    for (const id of ids) {\n      const entity = currentEntities[id];\n      if (entity) {\n        sortedEntities.push(entity);\n      }\n    }\n    const wasPreviouslyEmpty = sortedEntities.length === 0;\n    for (const item of addedItems) {\n      stateEntities[selectId(item)] = item;\n      if (!wasPreviouslyEmpty) {\n        insert(sortedEntities, item, comparer);\n      }\n    }\n    if (wasPreviouslyEmpty) {\n      sortedEntities = addedItems.slice().sort(comparer);\n    } else if (appliedUpdates) {\n      sortedEntities.sort(comparer);\n    }\n    const newSortedIds = sortedEntities.map(selectId);\n    if (!areArraysEqual(currentIds, newSortedIds)) {\n      state.ids = newSortedIds;\n    }\n  };\n  return {\n    removeOne,\n    removeMany,\n    removeAll,\n    addOne: createStateOperator(addOneMutably),\n    updateOne: createStateOperator(updateOneMutably),\n    upsertOne: createStateOperator(upsertOneMutably),\n    setOne: createStateOperator(setOneMutably),\n    setMany: createStateOperator(setManyMutably),\n    setAll: createStateOperator(setAllMutably),\n    addMany: createStateOperator(addManyMutably),\n    updateMany: createStateOperator(updateManyMutably),\n    upsertMany: createStateOperator(upsertManyMutably)\n  };\n}\n\n// src/entities/create_adapter.ts\nfunction createEntityAdapter(options = {}) {\n  const {\n    selectId,\n    sortComparer\n  } = {\n    sortComparer: false,\n    selectId: (instance) => instance.id,\n    ...options\n  };\n  const stateAdapter = sortComparer ? createSortedStateAdapter(selectId, sortComparer) : createUnsortedStateAdapter(selectId);\n  const stateFactory = createInitialStateFactory(stateAdapter);\n  const selectorsFactory = createSelectorsFactory();\n  return {\n    selectId,\n    sortComparer,\n    ...stateFactory,\n    ...selectorsFactory,\n    ...stateAdapter\n  };\n}\n\n// src/listenerMiddleware/index.ts\n\n\n// src/listenerMiddleware/exceptions.ts\nvar task = \"task\";\nvar listener = \"listener\";\nvar completed = \"completed\";\nvar cancelled = \"cancelled\";\nvar taskCancelled = `task-${cancelled}`;\nvar taskCompleted = `task-${completed}`;\nvar listenerCancelled = `${listener}-${cancelled}`;\nvar listenerCompleted = `${listener}-${completed}`;\nvar TaskAbortError = class {\n  constructor(code) {\n    this.code = code;\n    this.message = `${task} ${cancelled} (reason: ${code})`;\n  }\n  name = \"TaskAbortError\";\n  message;\n};\n\n// src/listenerMiddleware/utils.ts\nvar assertFunction = (func, expected) => {\n  if (typeof func !== \"function\") {\n    throw new Error( false ? 0 : `${expected} is not a function`);\n  }\n};\nvar noop2 = () => {\n};\nvar catchRejection = (promise, onError = noop2) => {\n  promise.catch(onError);\n  return promise;\n};\nvar addAbortSignalListener = (abortSignal, callback) => {\n  abortSignal.addEventListener(\"abort\", callback, {\n    once: true\n  });\n  return () => abortSignal.removeEventListener(\"abort\", callback);\n};\nvar abortControllerWithReason = (abortController, reason) => {\n  const signal = abortController.signal;\n  if (signal.aborted) {\n    return;\n  }\n  if (!(\"reason\" in signal)) {\n    Object.defineProperty(signal, \"reason\", {\n      enumerable: true,\n      value: reason,\n      configurable: true,\n      writable: true\n    });\n  }\n  ;\n  abortController.abort(reason);\n};\n\n// src/listenerMiddleware/task.ts\nvar validateActive = (signal) => {\n  if (signal.aborted) {\n    const {\n      reason\n    } = signal;\n    throw new TaskAbortError(reason);\n  }\n};\nfunction raceWithSignal(signal, promise) {\n  let cleanup = noop2;\n  return new Promise((resolve, reject) => {\n    const notifyRejection = () => reject(new TaskAbortError(signal.reason));\n    if (signal.aborted) {\n      notifyRejection();\n      return;\n    }\n    cleanup = addAbortSignalListener(signal, notifyRejection);\n    promise.finally(() => cleanup()).then(resolve, reject);\n  }).finally(() => {\n    cleanup = noop2;\n  });\n}\nvar runTask = async (task2, cleanUp) => {\n  try {\n    await Promise.resolve();\n    const value = await task2();\n    return {\n      status: \"ok\",\n      value\n    };\n  } catch (error) {\n    return {\n      status: error instanceof TaskAbortError ? \"cancelled\" : \"rejected\",\n      error\n    };\n  } finally {\n    cleanUp?.();\n  }\n};\nvar createPause = (signal) => {\n  return (promise) => {\n    return catchRejection(raceWithSignal(signal, promise).then((output) => {\n      validateActive(signal);\n      return output;\n    }));\n  };\n};\nvar createDelay = (signal) => {\n  const pause = createPause(signal);\n  return (timeoutMs) => {\n    return pause(new Promise((resolve) => setTimeout(resolve, timeoutMs)));\n  };\n};\n\n// src/listenerMiddleware/index.ts\nvar {\n  assign\n} = Object;\nvar INTERNAL_NIL_TOKEN = {};\nvar alm = \"listenerMiddleware\";\nvar createFork = (parentAbortSignal, parentBlockingPromises) => {\n  const linkControllers = (controller) => addAbortSignalListener(parentAbortSignal, () => abortControllerWithReason(controller, parentAbortSignal.reason));\n  return (taskExecutor, opts) => {\n    assertFunction(taskExecutor, \"taskExecutor\");\n    const childAbortController = new AbortController();\n    linkControllers(childAbortController);\n    const result = runTask(async () => {\n      validateActive(parentAbortSignal);\n      validateActive(childAbortController.signal);\n      const result2 = await taskExecutor({\n        pause: createPause(childAbortController.signal),\n        delay: createDelay(childAbortController.signal),\n        signal: childAbortController.signal\n      });\n      validateActive(childAbortController.signal);\n      return result2;\n    }, () => abortControllerWithReason(childAbortController, taskCompleted));\n    if (opts?.autoJoin) {\n      parentBlockingPromises.push(result.catch(noop2));\n    }\n    return {\n      result: createPause(parentAbortSignal)(result),\n      cancel() {\n        abortControllerWithReason(childAbortController, taskCancelled);\n      }\n    };\n  };\n};\nvar createTakePattern = (startListening, signal) => {\n  const take = async (predicate, timeout) => {\n    validateActive(signal);\n    let unsubscribe = () => {\n    };\n    const tuplePromise = new Promise((resolve, reject) => {\n      let stopListening = startListening({\n        predicate,\n        effect: (action, listenerApi) => {\n          listenerApi.unsubscribe();\n          resolve([action, listenerApi.getState(), listenerApi.getOriginalState()]);\n        }\n      });\n      unsubscribe = () => {\n        stopListening();\n        reject();\n      };\n    });\n    const promises = [tuplePromise];\n    if (timeout != null) {\n      promises.push(new Promise((resolve) => setTimeout(resolve, timeout, null)));\n    }\n    try {\n      const output = await raceWithSignal(signal, Promise.race(promises));\n      validateActive(signal);\n      return output;\n    } finally {\n      unsubscribe();\n    }\n  };\n  return (predicate, timeout) => catchRejection(take(predicate, timeout));\n};\nvar getListenerEntryPropsFrom = (options) => {\n  let {\n    type,\n    actionCreator,\n    matcher,\n    predicate,\n    effect\n  } = options;\n  if (type) {\n    predicate = createAction(type).match;\n  } else if (actionCreator) {\n    type = actionCreator.type;\n    predicate = actionCreator.match;\n  } else if (matcher) {\n    predicate = matcher;\n  } else if (predicate) {\n  } else {\n    throw new Error( false ? 0 : \"Creating or removing a listener requires one of the known fields for matching an action\");\n  }\n  assertFunction(effect, \"options.listener\");\n  return {\n    predicate,\n    type,\n    effect\n  };\n};\nvar createListenerEntry = /* @__PURE__ */ assign((options) => {\n  const {\n    type,\n    predicate,\n    effect\n  } = getListenerEntryPropsFrom(options);\n  const id = nanoid();\n  const entry = {\n    id,\n    effect,\n    type,\n    predicate,\n    pending: /* @__PURE__ */ new Set(),\n    unsubscribe: () => {\n      throw new Error( false ? 0 : \"Unsubscribe not initialized\");\n    }\n  };\n  return entry;\n}, {\n  withTypes: () => createListenerEntry\n});\nvar cancelActiveListeners = (entry) => {\n  entry.pending.forEach((controller) => {\n    abortControllerWithReason(controller, listenerCancelled);\n  });\n};\nvar createClearListenerMiddleware = (listenerMap) => {\n  return () => {\n    listenerMap.forEach(cancelActiveListeners);\n    listenerMap.clear();\n  };\n};\nvar safelyNotifyError = (errorHandler, errorToNotify, errorInfo) => {\n  try {\n    errorHandler(errorToNotify, errorInfo);\n  } catch (errorHandlerError) {\n    setTimeout(() => {\n      throw errorHandlerError;\n    }, 0);\n  }\n};\nvar addListener = /* @__PURE__ */ assign(/* @__PURE__ */ createAction(`${alm}/add`), {\n  withTypes: () => addListener\n});\nvar clearAllListeners = /* @__PURE__ */ createAction(`${alm}/removeAll`);\nvar removeListener = /* @__PURE__ */ assign(/* @__PURE__ */ createAction(`${alm}/remove`), {\n  withTypes: () => removeListener\n});\nvar defaultErrorHandler = (...args) => {\n  console.error(`${alm}/error`, ...args);\n};\nvar createListenerMiddleware = (middlewareOptions = {}) => {\n  const listenerMap = /* @__PURE__ */ new Map();\n  const {\n    extra,\n    onError = defaultErrorHandler\n  } = middlewareOptions;\n  assertFunction(onError, \"onError\");\n  const insertEntry = (entry) => {\n    entry.unsubscribe = () => listenerMap.delete(entry.id);\n    listenerMap.set(entry.id, entry);\n    return (cancelOptions) => {\n      entry.unsubscribe();\n      if (cancelOptions?.cancelActive) {\n        cancelActiveListeners(entry);\n      }\n    };\n  };\n  const startListening = (options) => {\n    let entry = find(Array.from(listenerMap.values()), (existingEntry) => existingEntry.effect === options.effect);\n    if (!entry) {\n      entry = createListenerEntry(options);\n    }\n    return insertEntry(entry);\n  };\n  assign(startListening, {\n    withTypes: () => startListening\n  });\n  const stopListening = (options) => {\n    const {\n      type,\n      effect,\n      predicate\n    } = getListenerEntryPropsFrom(options);\n    const entry = find(Array.from(listenerMap.values()), (entry2) => {\n      const matchPredicateOrType = typeof type === \"string\" ? entry2.type === type : entry2.predicate === predicate;\n      return matchPredicateOrType && entry2.effect === effect;\n    });\n    if (entry) {\n      entry.unsubscribe();\n      if (options.cancelActive) {\n        cancelActiveListeners(entry);\n      }\n    }\n    return !!entry;\n  };\n  assign(stopListening, {\n    withTypes: () => stopListening\n  });\n  const notifyListener = async (entry, action, api, getOriginalState) => {\n    const internalTaskController = new AbortController();\n    const take = createTakePattern(startListening, internalTaskController.signal);\n    const autoJoinPromises = [];\n    try {\n      entry.pending.add(internalTaskController);\n      await Promise.resolve(entry.effect(\n        action,\n        // Use assign() rather than ... to avoid extra helper functions added to bundle\n        assign({}, api, {\n          getOriginalState,\n          condition: (predicate, timeout) => take(predicate, timeout).then(Boolean),\n          take,\n          delay: createDelay(internalTaskController.signal),\n          pause: createPause(internalTaskController.signal),\n          extra,\n          signal: internalTaskController.signal,\n          fork: createFork(internalTaskController.signal, autoJoinPromises),\n          unsubscribe: entry.unsubscribe,\n          subscribe: () => {\n            listenerMap.set(entry.id, entry);\n          },\n          cancelActiveListeners: () => {\n            entry.pending.forEach((controller, _, set) => {\n              if (controller !== internalTaskController) {\n                abortControllerWithReason(controller, listenerCancelled);\n                set.delete(controller);\n              }\n            });\n          },\n          cancel: () => {\n            abortControllerWithReason(internalTaskController, listenerCancelled);\n            entry.pending.delete(internalTaskController);\n          },\n          throwIfCancelled: () => {\n            validateActive(internalTaskController.signal);\n          }\n        })\n      ));\n    } catch (listenerError) {\n      if (!(listenerError instanceof TaskAbortError)) {\n        safelyNotifyError(onError, listenerError, {\n          raisedBy: \"effect\"\n        });\n      }\n    } finally {\n      await Promise.all(autoJoinPromises);\n      abortControllerWithReason(internalTaskController, listenerCompleted);\n      entry.pending.delete(internalTaskController);\n    }\n  };\n  const clearListenerMiddleware = createClearListenerMiddleware(listenerMap);\n  const middleware = (api) => (next) => (action) => {\n    if (!(0,redux__WEBPACK_IMPORTED_MODULE_0__.isAction)(action)) {\n      return next(action);\n    }\n    if (addListener.match(action)) {\n      return startListening(action.payload);\n    }\n    if (clearAllListeners.match(action)) {\n      clearListenerMiddleware();\n      return;\n    }\n    if (removeListener.match(action)) {\n      return stopListening(action.payload);\n    }\n    let originalState = api.getState();\n    const getOriginalState = () => {\n      if (originalState === INTERNAL_NIL_TOKEN) {\n        throw new Error( false ? 0 : `${alm}: getOriginalState can only be called synchronously`);\n      }\n      return originalState;\n    };\n    let result;\n    try {\n      result = next(action);\n      if (listenerMap.size > 0) {\n        const currentState = api.getState();\n        const listenerEntries = Array.from(listenerMap.values());\n        for (const entry of listenerEntries) {\n          let runListener = false;\n          try {\n            runListener = entry.predicate(action, currentState, originalState);\n          } catch (predicateError) {\n            runListener = false;\n            safelyNotifyError(onError, predicateError, {\n              raisedBy: \"predicate\"\n            });\n          }\n          if (!runListener) {\n            continue;\n          }\n          notifyListener(entry, action, api, getOriginalState);\n        }\n      }\n    } finally {\n      originalState = INTERNAL_NIL_TOKEN;\n    }\n    return result;\n  };\n  return {\n    middleware,\n    startListening,\n    stopListening,\n    clearListeners: clearListenerMiddleware\n  };\n};\n\n// src/dynamicMiddleware/index.ts\n\nvar createMiddlewareEntry = (middleware) => ({\n  id: nanoid(),\n  middleware,\n  applied: /* @__PURE__ */ new Map()\n});\nvar matchInstance = (instanceId) => (action) => action?.meta?.instanceId === instanceId;\nvar createDynamicMiddleware = () => {\n  const instanceId = nanoid();\n  const middlewareMap = /* @__PURE__ */ new Map();\n  const withMiddleware = Object.assign(createAction(\"dynamicMiddleware/add\", (...middlewares) => ({\n    payload: middlewares,\n    meta: {\n      instanceId\n    }\n  })), {\n    withTypes: () => withMiddleware\n  });\n  const addMiddleware = Object.assign(function addMiddleware2(...middlewares) {\n    middlewares.forEach((middleware2) => {\n      let entry = find(Array.from(middlewareMap.values()), (entry2) => entry2.middleware === middleware2);\n      if (!entry) {\n        entry = createMiddlewareEntry(middleware2);\n      }\n      middlewareMap.set(entry.id, entry);\n    });\n  }, {\n    withTypes: () => addMiddleware\n  });\n  const getFinalMiddleware = (api) => {\n    const appliedMiddleware = Array.from(middlewareMap.values()).map((entry) => emplace(entry.applied, api, {\n      insert: () => entry.middleware(api)\n    }));\n    return (0,redux__WEBPACK_IMPORTED_MODULE_0__.compose)(...appliedMiddleware);\n  };\n  const isWithMiddleware = isAllOf(withMiddleware, matchInstance(instanceId));\n  const middleware = (api) => (next) => (action) => {\n    if (isWithMiddleware(action)) {\n      addMiddleware(...action.payload);\n      return api.dispatch;\n    }\n    return getFinalMiddleware(api)(next)(action);\n  };\n  return {\n    middleware,\n    addMiddleware,\n    withMiddleware,\n    instanceId\n  };\n};\n\n// src/combineSlices.ts\n\nvar isSliceLike = (maybeSliceLike) => \"reducerPath\" in maybeSliceLike && typeof maybeSliceLike.reducerPath === \"string\";\nvar getReducers = (slices) => slices.flatMap((sliceOrMap) => isSliceLike(sliceOrMap) ? [[sliceOrMap.reducerPath, sliceOrMap.reducer]] : Object.entries(sliceOrMap));\nvar ORIGINAL_STATE = Symbol.for(\"rtk-state-proxy-original\");\nvar isStateProxy = (value) => !!value && !!value[ORIGINAL_STATE];\nvar stateProxyMap = /* @__PURE__ */ new WeakMap();\nvar createStateProxy = (state, reducerMap) => emplace(stateProxyMap, state, {\n  insert: () => new Proxy(state, {\n    get: (target, prop, receiver) => {\n      if (prop === ORIGINAL_STATE) return target;\n      const result = Reflect.get(target, prop, receiver);\n      if (typeof result === \"undefined\") {\n        const reducer = reducerMap[prop.toString()];\n        if (reducer) {\n          const reducerResult = reducer(void 0, {\n            type: nanoid()\n          });\n          if (typeof reducerResult === \"undefined\") {\n            throw new Error( false ? 0 : `The slice reducer for key \"${prop.toString()}\" returned undefined when called for selector(). If the state passed to the reducer is undefined, you must explicitly return the initial state. The initial state may not be undefined. If you don't want to set a value for this reducer, you can use null instead of undefined.`);\n          }\n          return reducerResult;\n        }\n      }\n      return result;\n    }\n  })\n});\nvar original = (state) => {\n  if (!isStateProxy(state)) {\n    throw new Error( false ? 0 : \"original must be used on state Proxy\");\n  }\n  return state[ORIGINAL_STATE];\n};\nvar noopReducer = (state = {}) => state;\nfunction combineSlices(...slices) {\n  const reducerMap = Object.fromEntries(getReducers(slices));\n  const getReducer = () => Object.keys(reducerMap).length ? (0,redux__WEBPACK_IMPORTED_MODULE_0__.combineReducers)(reducerMap) : noopReducer;\n  let reducer = getReducer();\n  function combinedReducer(state, action) {\n    return reducer(state, action);\n  }\n  combinedReducer.withLazyLoadedSlices = () => combinedReducer;\n  const inject = (slice, config = {}) => {\n    const {\n      reducerPath,\n      reducer: reducerToInject\n    } = slice;\n    const currentReducer = reducerMap[reducerPath];\n    if (!config.overrideExisting && currentReducer && currentReducer !== reducerToInject) {\n      if (typeof process !== \"undefined\" && \"development\" === \"development\") {\n        console.error(`called \\`inject\\` to override already-existing reducer ${reducerPath} without specifying \\`overrideExisting: true\\``);\n      }\n      return combinedReducer;\n    }\n    reducerMap[reducerPath] = reducerToInject;\n    reducer = getReducer();\n    return combinedReducer;\n  };\n  const selector = Object.assign(function makeSelector(selectorFn, selectState) {\n    return function selector2(state, ...args) {\n      return selectorFn(createStateProxy(selectState ? selectState(state, ...args) : state, reducerMap), ...args);\n    };\n  }, {\n    original\n  });\n  return Object.assign(combinedReducer, {\n    inject,\n    selector\n  });\n}\n\n// src/formatProdErrorMessage.ts\nfunction formatProdErrorMessage(code) {\n  return `Minified Redux Toolkit error #${code}; visit https://redux-toolkit.js.org/Errors?code=${code} for the full message or use the non-minified dev environment for full errors. `;\n}\n\n//# sourceMappingURL=redux-toolkit.modern.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlZHV4anMvdG9vbGtpdC9kaXN0L3JlZHV4LXRvb2xraXQubW9kZXJuLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNzQjtBQUNtRjtBQUNpQzs7QUFFMUk7QUFDeUM7QUFDd0I7QUFDakU7QUFDQSwwQkFBMEIsK0RBQXFCO0FBQy9DO0FBQ0E7QUFDQSx5REFBeUQsOENBQU8sVUFBVSw4Q0FBTztBQUNqRjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSw2RUFBNkUsb0RBQWM7O0FBRTNGO0FBQzRIOztBQUU1SDtBQUNnQztBQUNoQztBQUNBO0FBQ0EsK0NBQStDLDBDQUFPO0FBQ3RELFNBQVMsMENBQU87QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQzBFOztBQUUxRTtBQUNpQzs7QUFFakM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLE1BQXFDLEdBQUcsQ0FBeUI7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLEtBQUs7QUFDekM7QUFDQSxvQ0FBb0MsK0NBQVE7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLCtDQUFRO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw4QkFBOEIsS0FBSztBQUNuQztBQUNBLGtEQUFrRCxrQkFBa0I7QUFDcEUsa0ZBQWtGLFdBQVcsOEJBQThCLFdBQVc7QUFDdEk7QUFDQSw0REFBNEQ7QUFDNUQsTUFBTSxLQUFxQyxFQUFFLEVBRTFDO0FBQ0g7QUFDQTtBQUNBLElB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsWUFBWTtB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O0FBQ0EsU0FBUyw4Q0FBUSxVQUFVLDhDQUFRO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsY0FBYztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQzhDOztBQUU5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFVBQVU7QUFDdEMsNEJBQTRCLFVBQVU7QUFDdEMsMkJBQTJCLFNBQVMsR0FBRyxVQUFVO0FB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUM0RDtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSw0QkFBNEIsTUFBcUMsR0FBRyxDQUEwQixpQ0FBaUMsZ0JBQWdCO0FBQy9JO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBLG9CQUFvQixNQUFxQyxHQUFHLENBQTBCO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsNERBQTRELHNEQUFnQjtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsNENBQTRDLGFBQW9CO0FBQ2hFLGdGQUFnRixhQUFhO0FBQzdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSwwQ0FBMEMsT0FBTyxpREFBaUQsTUFBTTtBQUN4RztBQW9ERTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4vbm9kZV9tb2R1bGVzL0ByZWR1eGpzL3Rvb2xraXQvZGlzdC9yZWR1eC10b29sa2l0Lm1vZGVybi5tanM/Yzk1MiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvaW5kZXgudHNcbmV4cG9ydCAqIGZyb20gXCJyZWR1eFwiO1xuaW1wb3J0IHsgcHJvZHVjZSwgY3VycmVudCBhcyBjdXJyZW50MywgZnJlZXplLCBvcmlnaW5hbCBhcyBvcmlnaW5hbDIsIGlzRHJhZnQgYXMgaXNEcmFmdDUgfSBmcm9tIFwiaW1tZXJcIjtcbmltcG9ydCB7IGNyZWF0ZVNlbGVjdG9yLCBjcmVhdGVTZWxlY3RvckNyZWF0b3IgYXMgY3JlYXRlU2VsZWN0b3JDcmVhdG9yMiwgbHJ1TWVtb2l6ZSwgd2Vha01hcE1lbW9pemUgYXMgd2Vha01hcE1lbW9pemUyIH0gZnJvbSBcInJlc2VsZWN0XCI7XG5cbi8vIHNyYy9jcmVhdGVEcmFmdFNhZmVTZWxlY3Rvci50c1xuaW1wb3J0IHsgY3VycmVudCwgaXNEcmFmdCB9IGZyb20gXCJpbW1lclwiO1xuaW1wb3J0IHsgY3JlYXRlU2VsZWN0b3JDcmVhdG9yLCB3ZWFrTWFwTWVtb2l6ZSB9IGZyb20gXCJyZXNlbGVjdFwiO1xudmFyIGNyZWF0ZURyYWZ0U2FmZVNlbGVjdG9yQ3JlYXRvciA9ICguLi5hcmdzKSA9PiB7XG4gIGNvbnN0IGNyZWF0ZVNlbGVjdG9yMiA9IGNyZWF0ZVNlbGVjdG9yQ3JlYXRvciguLi5hcmdzKTtcbiAgY29uc3QgY3JlYXRlRHJhZnRTYWZlU2VsZWN0b3IyID0gT2JqZWN0LmFzc2lnbigoLi4uYXJnczIpID0+IHtcbiAgICBjb25zdCBzZWxlY3RvciA9IGNyZWF0ZVNlbGVjdG9yMiguLi5hcmdzMik7XG4gICAgY29uc3Qgd3JhcHBlZFNlbGVjdG9yID0gKHZhbHVlLCAuLi5yZXN0KSA9PiBzZWxlY3Rvcihpc0RyYWZ0KHZhbHVlKSA/IGN1cnJlbnQodmFsdWUpIDogdmFsdWUsIC4uLnJlc3QpO1xuICAgIE9iamVjdC5hc3NpZ24od3JhcHBlZFNlbGVjdG9yLCBzZWxlY3Rvcik7XG4gICAgcmV0dXJuIHdyYXBwZWRTZWxlY3RvcjtcbiAgfSwge1xuICAgIHdpdGhUeXBlczogKCkgPT4gY3JlYXRlRHJhZnRTYWZlU2VsZWN0b3IyXG4gIH0pO1xuICByZXR1cm4gY3JlYXRlRHJhZnRTYWZlU2VsZWN0b3IyO1xufTtcbnZhciBjcmVhdGVEcmFmdFNhZmVTZWxlY3RvciA9IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVEcmFmdFNhZmVTZWxlY3RvckNyZWF0b3Iod2Vha01hcE1lbW9pemUpO1xuXG4vLyBzcmMvY29uZmlndXJlU3RvcmUudHNcbmltcG9ydCB7IGFwcGx5TWlkZGxld2FyZSwgY3JlYXRlU3RvcmUsIGNvbXBvc2UgYXMgY29tcG9zZTIsIGNvbWJpbmVSZWR1Y2VycywgaXNQbGFpbk9iamVjdCBhcyBpc1BsYWluT2JqZWN0MiB9IGZyb20gXCJyZWR1eFwiO1xuXG4vLyBzcmMvZGV2dG9vbHNFeHRlbnNpb24udHNcbmltcG9ydCB7IGNvbXBvc2UgfSBmcm9tIFwicmVkdXhcIjtcbnZhciBjb21wb3NlV2l0aERldlRvb2xzID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cuX19SRURVWF9ERVZUT09MU19FWFRFTlNJT05fQ09NUE9TRV9fID8gd2luZG93Ll9fUkVEVVhfREVWVE9PTFNfRVhURU5TSU9OX0NPTVBPU0VfXyA6IGZ1bmN0aW9uKCkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHZvaWQgMDtcbiAgaWYgKHR5cGVvZiBhcmd1bWVudHNbMF0gPT09IFwib2JqZWN0XCIpIHJldHVybiBjb21wb3NlO1xuICByZXR1cm4gY29tcG9zZS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcbnZhciBkZXZUb29sc0VuaGFuY2VyID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cuX19SRURVWF9ERVZUT09MU19FWFRFTlNJT05fXyA/IHdpbmRvdy5fX1JFRFVYX0RFVlRPT0xTX0VYVEVOU0lPTl9fIDogZnVuY3Rpb24oKSB7XG4gIHJldHVybiBmdW5jdGlvbihub29wMykge1xuICAgIHJldHVybiBub29wMztcbiAgfTtcbn07XG5cbi8vIHNyYy9nZXREZWZhdWx0TWlkZGxld2FyZS50c1xuaW1wb3J0IHsgdGh1bmsgYXMgdGh1bmtNaWRkbGV3YXJlLCB3aXRoRXh0cmFBcmd1bWVudCB9IGZyb20gXCJyZWR1eC10aHVua1wiO1xuXG4vLyBzcmMvY3JlYXRlQWN0aW9uLnRzXG5pbXBvcnQgeyBpc0FjdGlvbiB9IGZyb20gXCJyZWR1eFwiO1xuXG4vLyBzcmMvdHNIZWxwZXJzLnRzXG52YXIgaGFzTWF0Y2hGdW5jdGlvbiA9ICh2KSA9PiB7XG4gIHJldHVybiB2ICYmIHR5cGVvZiB2Lm1hdGNoID09PSBcImZ1bmN0aW9uXCI7XG59O1xuXG4vLyBzcmMvY3JlYXRlQWN0aW9uLnRzXG5mdW5jdGlvbiBjcmVhdGVBY3Rpb24odHlwZSwgcHJlcGFyZUFjdGlvbikge1xuICBmdW5jdGlvbiBhY3Rpb25DcmVhdG9yKC4uLmFyZ3MpIHtcbiAgICBpZiAocHJlcGFyZUFjdGlvbikge1xuICAgICAgbGV0IHByZXBhcmVkID0gcHJlcGFyZUFjdGlvbiguLi5hcmdzKTtcbiAgICAgIGlmICghcHJlcGFyZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMCkgOiBcInByZXBhcmVBY3Rpb24gZGlkIG5vdCByZXR1cm4gYW4gb2JqZWN0XCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZSxcbiAgICAgICAgcGF5bG9hZDogcHJlcGFyZWQucGF5bG9hZCxcbiAgICAgICAgLi4uXCJtZXRhXCIgaW4gcHJlcGFyZWQgJiYge1xuICAgICAgICAgIG1ldGE6IHByZXBhcmVkLm1ldGFcbiAgICAgICAgfSxcbiAgICAgICAgLi4uXCJlcnJvclwiIGluIHByZXBhcmVkICYmIHtcbiAgICAgICAgICBlcnJvcjogcHJlcGFyZWQuZXJyb3JcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGUsXG4gICAgICBwYXlsb2FkOiBhcmdzWzBdXG4gICAgfTtcbiAgfVxuICBhY3Rpb25DcmVhdG9yLnRvU3RyaW5nID0gKCkgPT4gYCR7dHlwZX1gO1xuICBhY3Rpb25DcmVhdG9yLnR5cGUgPSB0eXBlO1xuICBhY3Rpb25DcmVhdG9yLm1hdGNoID0gKGFjdGlvbikgPT4gaXNBY3Rpb24oYWN0aW9uKSAmJiBhY3Rpb24udHlwZSA9PT0gdHlwZTtcbiAgcmV0dXJuIGFjdGlvbkNyZWF0b3I7XG59XG5mdW5jdGlvbiBpc0FjdGlvbkNyZWF0b3IoYWN0aW9uKSB7XG4gIHJldHVybiB0eXBlb2YgYWN0aW9uID09PSBcImZ1bmN0aW9uXCIgJiYgXCJ0eXBlXCIgaW4gYWN0aW9uICYmIC8vIGhhc01hdGNoRnVuY3Rpb24gb25seSB3YW50cyBNYXRjaGVycyBidXQgSSBkb24ndCBzZWUgdGhlIHBvaW50IGluIHJld3JpdGluZyBpdFxuICBoYXNNYXRjaEZ1bmN0aW9uKGFjdGlvbik7XG59XG5mdW5jdGlvbiBpc0ZTQShhY3Rpb24pIHtcbiAgcmV0dXJuIGlzQWN0aW9uKGFjdGlvbikgJiYgT2JqZWN0LmtleXMoYWN0aW9uKS5ldmVyeShpc1ZhbGlkS2V5KTtcbn1cbmZ1bmN0aW9uIGlzVmFsaWRLZXkoa2V5KSB7XG4gIHJldHVybiBbXCJ0eXBlXCIsIFwicGF5bG9hZFwiLCBcImVycm9yXCIsIFwibWV0YVwiXS5pbmRleE9mKGtleSkgPiAtMTtcbn1cblxuLy8gc3JjL2FjdGlvbkNyZWF0b3JJbnZhcmlhbnRNaWRkbGV3YXJlLnRzXG5mdW5jdGlvbiBnZXRNZXNzYWdlKHR5cGUpIHtcbiAgY29uc3Qgc3BsaXRUeXBlID0gdHlwZSA/IGAke3R5cGV9YC5zcGxpdChcIi9cIikgOiBbXTtcbiAgY29uc3QgYWN0aW9uTmFtZSA9IHNwbGl0VHlwZVtzcGxpdFR5cGUubGVuZ3RoIC0gMV0gfHwgXCJhY3Rpb25DcmVhdG9yXCI7XG4gIHJldHVybiBgRGV0ZWN0ZWQgYW4gYWN0aW9uIGNyZWF0b3Igd2l0aCB0eXBlIFwiJHt0eXBlIHx8IFwidW5rbm93blwifVwiIGJlaW5nIGRpc3BhdGNoZWQuIFxuTWFrZSBzdXJlIHlvdSdyZSBjYWxsaW5nIHRoZSBhY3Rpb24gY3JlYXRvciBiZWZvcmUgZGlzcGF0Y2hpbmcsIGkuZS4gXFxgZGlzcGF0Y2goJHthY3Rpb25OYW1lfSgpKVxcYCBpbnN0ZWFkIG9mIFxcYGRpc3BhdGNoKCR7YWN0aW9uTmFtZX0pXFxgLiBUaGlzIGlzIG5lY2Vzc2FyeSBldmVuIGlmIHRoZSBhY3Rpb24gaGFzIG5vIHBheWxvYWQuYDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUFjdGlvbkNyZWF0b3JJbnZhcmlhbnRNaWRkbGV3YXJlKG9wdGlvbnMgPSB7fSkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgcmV0dXJuICgpID0+IChuZXh0KSA9PiAoYWN0aW9uKSA9PiBuZXh0KGFjdGlvbik7XG4gIH1cbiAgY29uc3Qge1xuICAgIGlzQWN0aW9uQ3JlYXRvcjogaXNBY3Rpb25DcmVhdG9yMiA9IGlzQWN0aW9uQ3JlYXRvclxuICB9ID0gb3B0aW9ucztcbiAgcmV0dXJuICgpID0+IChuZXh0KSA9PiAoYWN0aW9uKSA9PiB7XG4gICAgaWYgKGlzQWN0aW9uQ3JlYXRvcjIoYWN0aW9uKSkge1xuICAgICAgY29uc29sZS53YXJuKGdldE1lc3NhZ2UoYWN0aW9uLnR5cGUpKTtcbiAgICB9XG4gICAgcmV0dXJuIG5leHQoYWN0aW9uKTtcbiAgfTtcbn1cblxuLy8gc3JjL3V0aWxzLnRzXG5pbXBvcnQgeyBwcm9kdWNlIGFzIGNyZWF0ZU5leHRTdGF0ZSwgaXNEcmFmdGFibGUgfSBmcm9tIFwiaW1tZXJcIjtcbmZ1bmN0aW9uIGdldFRpbWVNZWFzdXJlVXRpbHMobWF4RGVsYXksIGZuTmFtZSkge1xuICBsZXQgZWxhcHNlZCA9IDA7XG4gIHJldHVybiB7XG4gICAgbWVhc3VyZVRpbWUoZm4pIHtcbiAgICAgIGNvbnN0IHN0YXJ0ZWQgPSBEYXRlLm5vdygpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGZuKCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBjb25zdCBmaW5pc2hlZCA9IERhdGUubm93KCk7XG4gICAgICAgIGVsYXBzZWQgKz0gZmluaXNoZWQgLSBzdGFydGVkO1xuICAgICAgfVxuICAgIH0sXG4gICAgd2FybklmRXhjZWVkZWQoKSB7XG4gICAgICBpZiAoZWxhcHNlZCA+IG1heERlbGF5KSB7XG4gICAgICAgIGNvbnNvbGUud2FybihgJHtmbk5hbWV9IHRvb2sgJHtlbGFwc2VkfW1zLCB3aGljaCBpcyBtb3JlIHRoYW4gdGhlIHdhcm5pbmcgdGhyZXNob2xkIG9mICR7bWF4RGVsYXl9bXMuIFxuSWYgeW91ciBzdGF0ZSBvciBhY3Rpb25zIGFyZSB2ZXJ5IGxhcmdlLCB5b3UgbWF5IHdhbnQgdG8gZGlzYWJsZSB0aGUgbWlkZGxld2FyZSBhcyBpdCBtaWdodCBjYXVzZSB0b28gbXVjaCBvZiBhIHNsb3dkb3duIGluIGRldmVsb3BtZW50IG1vZGUuIFNlZSBodHRwczovL3JlZHV4LXRvb2xraXQuanMub3JnL2FwaS9nZXREZWZhdWx0TWlkZGxld2FyZSBmb3IgaW5zdHJ1Y3Rpb25zLlxuSXQgaXMgZGlzYWJsZWQgaW4gcHJvZHVjdGlvbiBidWlsZHMsIHNvIHlvdSBkb24ndCBuZWVkIHRvIHdvcnJ5IGFib3V0IHRoYXQuYCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gZmluZChpdGVyYWJsZSwgY29tcGFyYXRvcikge1xuICBmb3IgKGNvbnN0IGVudHJ5IG9mIGl0ZXJhYmxlKSB7XG4gICAgaWYgKGNvbXBhcmF0b3IoZW50cnkpKSB7XG4gICAgICByZXR1cm4gZW50cnk7XG4gICAgfVxuICB9XG4gIHJldHVybiB2b2lkIDA7XG59XG52YXIgVHVwbGUgPSBjbGFzcyBfVHVwbGUgZXh0ZW5kcyBBcnJheSB7XG4gIGNvbnN0cnVjdG9yKC4uLml0ZW1zKSB7XG4gICAgc3VwZXIoLi4uaXRlbXMpO1xuICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBfVHVwbGUucHJvdG90eXBlKTtcbiAgfVxuICBzdGF0aWMgZ2V0IFtTeW1ib2wuc3BlY2llc10oKSB7XG4gICAgcmV0dXJuIF9UdXBsZTtcbiAgfVxuICBjb25jYXQoLi4uYXJyKSB7XG4gICAgcmV0dXJuIHN1cGVyLmNvbmNhdC5hcHBseSh0aGlzLCBhcnIpO1xuICB9XG4gIHByZXBlbmQoLi4uYXJyKSB7XG4gICAgaWYgKGFyci5sZW5ndGggPT09IDEgJiYgQXJyYXkuaXNBcnJheShhcnJbMF0pKSB7XG4gICAgICByZXR1cm4gbmV3IF9UdXBsZSguLi5hcnJbMF0uY29uY2F0KHRoaXMpKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBfVHVwbGUoLi4uYXJyLmNvbmNhdCh0aGlzKSk7XG4gIH1cbn07XG5mdW5jdGlvbiBmcmVlemVEcmFmdGFibGUodmFsKSB7XG4gIHJldHVybiBpc0RyYWZ0YWJsZSh2YWwpID8gY3JlYXRlTmV4dFN0YXRlKHZhbCwgKCkgPT4ge1xuICB9KSA6IHZhbDtcbn1cbmZ1bmN0aW9uIGVtcGxhY2UobWFwLCBrZXksIGhhbmRsZXIpIHtcbiAgaWYgKG1hcC5oYXMoa2V5KSkge1xuICAgIGxldCB2YWx1ZSA9IG1hcC5nZXQoa2V5KTtcbiAgICBpZiAoaGFuZGxlci51cGRhdGUpIHtcbiAgICAgIHZhbHVlID0gaGFuZGxlci51cGRhdGUodmFsdWUsIGtleSwgbWFwKTtcbiAgICAgIG1hcC5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAoIWhhbmRsZXIuaW5zZXJ0KSB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgxMCkgOiBcIk5vIGluc2VydCBwcm92aWRlZCBmb3Iga2V5IG5vdCBhbHJlYWR5IGluIG1hcFwiKTtcbiAgY29uc3QgaW5zZXJ0ZWQgPSBoYW5kbGVyLmluc2VydChrZXksIG1hcCk7XG4gIG1hcC5zZXQoa2V5LCBpbnNlcnRlZCk7XG4gIHJldHVybiBpbnNlcnRlZDtcbn1cblxuLy8gc3JjL2ltbXV0YWJsZVN0YXRlSW52YXJpYW50TWlkZGxld2FyZS50c1xuZnVuY3Rpb24gaXNJbW11dGFibGVEZWZhdWx0KHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIgfHwgdmFsdWUgPT0gbnVsbCB8fCBPYmplY3QuaXNGcm96ZW4odmFsdWUpO1xufVxuZnVuY3Rpb24gdHJhY2tGb3JNdXRhdGlvbnMoaXNJbW11dGFibGUsIGlnbm9yZVBhdGhzLCBvYmopIHtcbiAgY29uc3QgdHJhY2tlZFByb3BlcnRpZXMgPSB0cmFja1Byb3BlcnRpZXMoaXNJbW11dGFibGUsIGlnbm9yZVBhdGhzLCBvYmopO1xuICByZXR1cm4ge1xuICAgIGRldGVjdE11dGF0aW9ucygpIHtcbiAgICAgIHJldHVybiBkZXRlY3RNdXRhdGlvbnMoaXNJbW11dGFibGUsIGlnbm9yZVBhdGhzLCB0cmFja2VkUHJvcGVydGllcywgb2JqKTtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiB0cmFja1Byb3BlcnRpZXMoaXNJbW11dGFibGUsIGlnbm9yZVBhdGhzID0gW10sIG9iaiwgcGF0aCA9IFwiXCIsIGNoZWNrZWRPYmplY3RzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSkge1xuICBjb25zdCB0cmFja2VkID0ge1xuICAgIHZhbHVlOiBvYmpcbiAgfTtcbiAgaWYgKCFpc0ltbXV0YWJsZShvYmopICYmICFjaGVja2VkT2JqZWN0cy5oYXMob2JqKSkge1xuICAgIGNoZWNrZWRPYmplY3RzLmFkZChvYmopO1xuICAgIHRyYWNrZWQuY2hpbGRyZW4gPSB7fTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBvYmopIHtcbiAgICAgIGNvbnN0IGNoaWxkUGF0aCA9IHBhdGggPyBwYXRoICsgXCIuXCIgKyBrZXkgOiBrZXk7XG4gICAgICBpZiAoaWdub3JlUGF0aHMubGVuZ3RoICYmIGlnbm9yZVBhdGhzLmluZGV4T2YoY2hpbGRQYXRoKSAhPT0gLTEpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB0cmFja2VkLmNoaWxkcmVuW2tleV0gPSB0cmFja1Byb3BlcnRpZXMoaXNJbW11dGFibGUsIGlnbm9yZVBhdGhzLCBvYmpba2V5XSwgY2hpbGRQYXRoKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRyYWNrZWQ7XG59XG5mdW5jdGlvbiBkZXRlY3RNdXRhdGlvbnMoaXNJbW11dGFibGUsIGlnbm9yZWRQYXRocyA9IFtdLCB0cmFja2VkUHJvcGVydHksIG9iaiwgc2FtZVBhcmVudFJlZiA9IGZhbHNlLCBwYXRoID0gXCJcIikge1xuICBjb25zdCBwcmV2T2JqID0gdHJhY2tlZFByb3BlcnR5ID8gdHJhY2tlZFByb3BlcnR5LnZhbHVlIDogdm9pZCAwO1xuICBjb25zdCBzYW1lUmVmID0gcHJldk9iaiA9PT0gb2JqO1xuICBpZiAoc2FtZVBhcmVudFJlZiAmJiAhc2FtZVJlZiAmJiAhTnVtYmVyLmlzTmFOKG9iaikpIHtcbiAgICByZXR1cm4ge1xuICAgICAgd2FzTXV0YXRlZDogdHJ1ZSxcbiAgICAgIHBhdGhcbiAgICB9O1xuICB9XG4gIGlmIChpc0ltbXV0YWJsZShwcmV2T2JqKSB8fCBpc0ltbXV0YWJsZShvYmopKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHdhc011dGF0ZWQ6IGZhbHNlXG4gICAgfTtcbiAgfVxuICBjb25zdCBrZXlzVG9EZXRlY3QgPSB7fTtcbiAgZm9yIChsZXQga2V5IGluIHRyYWNrZWRQcm9wZXJ0eS5jaGlsZHJlbikge1xuICAgIGtleXNUb0RldGVjdFtrZXldID0gdHJ1ZTtcbiAgfVxuICBmb3IgKGxldCBrZXkgaW4gb2JqKSB7XG4gICAga2V5c1RvRGV0ZWN0W2tleV0gPSB0cnVlO1xuICB9XG4gIGNvbnN0IGhhc0lnbm9yZWRQYXRocyA9IGlnbm9yZWRQYXRocy5sZW5ndGggPiAwO1xuICBmb3IgKGxldCBrZXkgaW4ga2V5c1RvRGV0ZWN0KSB7XG4gICAgY29uc3QgbmVzdGVkUGF0aCA9IHBhdGggPyBwYXRoICsgXCIuXCIgKyBrZXkgOiBrZXk7XG4gICAgaWYgKGhhc0lnbm9yZWRQYXRocykge1xuICAgICAgY29uc3QgaGFzTWF0Y2hlcyA9IGlnbm9yZWRQYXRocy5zb21lKChpZ25vcmVkKSA9PiB7XG4gICAgICAgIGlmIChpZ25vcmVkIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAgICAgcmV0dXJuIGlnbm9yZWQudGVzdChuZXN0ZWRQYXRoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmVzdGVkUGF0aCA9PT0gaWdub3JlZDtcbiAgICAgIH0pO1xuICAgICAgaWYgKGhhc01hdGNoZXMpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IGRldGVjdE11dGF0aW9ucyhpc0ltbXV0YWJsZSwgaWdub3JlZFBhdGhzLCB0cmFja2VkUHJvcGVydHkuY2hpbGRyZW5ba2V5XSwgb2JqW2tleV0sIHNhbWVSZWYsIG5lc3RlZFBhdGgpO1xuICAgIGlmIChyZXN1bHQud2FzTXV0YXRlZCkge1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB3YXNNdXRhdGVkOiBmYWxzZVxuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlSW1tdXRhYmxlU3RhdGVJbnZhcmlhbnRNaWRkbGV3YXJlKG9wdGlvbnMgPSB7fSkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgcmV0dXJuICgpID0+IChuZXh0KSA9PiAoYWN0aW9uKSA9PiBuZXh0KGFjdGlvbik7XG4gIH0gZWxzZSB7XG4gICAgbGV0IHN0cmluZ2lmeTIgPSBmdW5jdGlvbihvYmosIHNlcmlhbGl6ZXIsIGluZGVudCwgZGVjeWNsZXIpIHtcbiAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShvYmosIGdldFNlcmlhbGl6ZTIoc2VyaWFsaXplciwgZGVjeWNsZXIpLCBpbmRlbnQpO1xuICAgIH0sIGdldFNlcmlhbGl6ZTIgPSBmdW5jdGlvbihzZXJpYWxpemVyLCBkZWN5Y2xlcikge1xuICAgICAgbGV0IHN0YWNrID0gW10sIGtleXMgPSBbXTtcbiAgICAgIGlmICghZGVjeWNsZXIpIGRlY3ljbGVyID0gZnVuY3Rpb24oXywgdmFsdWUpIHtcbiAgICAgICAgaWYgKHN0YWNrWzBdID09PSB2YWx1ZSkgcmV0dXJuIFwiW0NpcmN1bGFyIH5dXCI7XG4gICAgICAgIHJldHVybiBcIltDaXJjdWxhciB+LlwiICsga2V5cy5zbGljZSgwLCBzdGFjay5pbmRleE9mKHZhbHVlKSkuam9pbihcIi5cIikgKyBcIl1cIjtcbiAgICAgIH07XG4gICAgICByZXR1cm4gZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgICBpZiAoc3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgICAgIHZhciB0aGlzUG9zID0gc3RhY2suaW5kZXhPZih0aGlzKTtcbiAgICAgICAgICB+dGhpc1BvcyA/IHN0YWNrLnNwbGljZSh0aGlzUG9zICsgMSkgOiBzdGFjay5wdXNoKHRoaXMpO1xuICAgICAgICAgIH50aGlzUG9zID8ga2V5cy5zcGxpY2UodGhpc1BvcywgSW5maW5pdHksIGtleSkgOiBrZXlzLnB1c2goa2V5KTtcbiAgICAgICAgICBpZiAofnN0YWNrLmluZGV4T2YodmFsdWUpKSB2YWx1ZSA9IGRlY3ljbGVyLmNhbGwodGhpcywga2V5LCB2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSBzdGFjay5wdXNoKHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZXIgPT0gbnVsbCA/IHZhbHVlIDogc2VyaWFsaXplci5jYWxsKHRoaXMsIGtleSwgdmFsdWUpO1xuICAgICAgfTtcbiAgICB9O1xuICAgIHZhciBzdHJpbmdpZnkgPSBzdHJpbmdpZnkyLCBnZXRTZXJpYWxpemUgPSBnZXRTZXJpYWxpemUyO1xuICAgIGxldCB7XG4gICAgICBpc0ltbXV0YWJsZSA9IGlzSW1tdXRhYmxlRGVmYXVsdCxcbiAgICAgIGlnbm9yZWRQYXRocyxcbiAgICAgIHdhcm5BZnRlciA9IDMyXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgdHJhY2sgPSB0cmFja0Zvck11dGF0aW9ucy5iaW5kKG51bGwsIGlzSW1tdXRhYmxlLCBpZ25vcmVkUGF0aHMpO1xuICAgIHJldHVybiAoe1xuICAgICAgZ2V0U3RhdGVcbiAgICB9KSA9PiB7XG4gICAgICBsZXQgc3RhdGUgPSBnZXRTdGF0ZSgpO1xuICAgICAgbGV0IHRyYWNrZXIgPSB0cmFjayhzdGF0ZSk7XG4gICAgICBsZXQgcmVzdWx0O1xuICAgICAgcmV0dXJuIChuZXh0KSA9PiAoYWN0aW9uKSA9PiB7XG4gICAgICAgIGNvbnN0IG1lYXN1cmVVdGlscyA9IGdldFRpbWVNZWFzdXJlVXRpbHMod2FybkFmdGVyLCBcIkltbXV0YWJsZVN0YXRlSW52YXJpYW50TWlkZGxld2FyZVwiKTtcbiAgICAgICAgbWVhc3VyZVV0aWxzLm1lYXN1cmVUaW1lKCgpID0+IHtcbiAgICAgICAgICBzdGF0ZSA9IGdldFN0YXRlKCk7XG4gICAgICAgICAgcmVzdWx0ID0gdHJhY2tlci5kZXRlY3RNdXRhdGlvbnMoKTtcbiAgICAgICAgICB0cmFja2VyID0gdHJhY2soc3RhdGUpO1xuICAgICAgICAgIGlmIChyZXN1bHQud2FzTXV0YXRlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMTkpIDogYEEgc3RhdGUgbXV0YXRpb24gd2FzIGRldGVjdGVkIGJldHdlZW4gZGlzcGF0Y2hlcywgaW4gdGhlIHBhdGggJyR7cmVzdWx0LnBhdGggfHwgXCJcIn0nLiAgVGhpcyBtYXkgY2F1c2UgaW5jb3JyZWN0IGJlaGF2aW9yLiAoaHR0cHM6Ly9yZWR1eC5qcy5vcmcvc3R5bGUtZ3VpZGUvc3R5bGUtZ3VpZGUjZG8tbm90LW11dGF0ZS1zdGF0ZSlgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBkaXNwYXRjaGVkQWN0aW9uID0gbmV4dChhY3Rpb24pO1xuICAgICAgICBtZWFzdXJlVXRpbHMubWVhc3VyZVRpbWUoKCkgPT4ge1xuICAgICAgICAgIHN0YXRlID0gZ2V0U3RhdGUoKTtcbiAgICAgICAgICByZXN1bHQgPSB0cmFja2VyLmRldGVjdE11dGF0aW9ucygpO1xuICAgICAgICAgIHRyYWNrZXIgPSB0cmFjayhzdGF0ZSk7XG4gICAgICAgICAgaWYgKHJlc3VsdC53YXNNdXRhdGVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgyMCkgOiBgQSBzdGF0ZSBtdXRhdGlvbiB3YXMgZGV0ZWN0ZWQgaW5zaWRlIGEgZGlzcGF0Y2gsIGluIHRoZSBwYXRoOiAke3Jlc3VsdC5wYXRoIHx8IFwiXCJ9LiBUYWtlIGEgbG9vayBhdCB0aGUgcmVkdWNlcihzKSBoYW5kbGluZyB0aGUgYWN0aW9uICR7c3RyaW5naWZ5MihhY3Rpb24pfS4gKGh0dHBzOi8vcmVkdXguanMub3JnL3N0eWxlLWd1aWRlL3N0eWxlLWd1aWRlI2RvLW5vdC1tdXRhdGUtc3RhdGUpYCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgbWVhc3VyZVV0aWxzLndhcm5JZkV4Y2VlZGVkKCk7XG4gICAgICAgIHJldHVybiBkaXNwYXRjaGVkQWN0aW9uO1xuICAgICAgfTtcbiAgICB9O1xuICB9XG59XG5cbi8vIHNyYy9zZXJpYWxpemFibGVTdGF0ZUludmFyaWFudE1pZGRsZXdhcmUudHNcbmltcG9ydCB7IGlzQWN0aW9uIGFzIGlzQWN0aW9uMiwgaXNQbGFpbk9iamVjdCB9IGZyb20gXCJyZWR1eFwiO1xuZnVuY3Rpb24gaXNQbGFpbih2YWwpIHtcbiAgY29uc3QgdHlwZSA9IHR5cGVvZiB2YWw7XG4gIHJldHVybiB2YWwgPT0gbnVsbCB8fCB0eXBlID09PSBcInN0cmluZ1wiIHx8IHR5cGUgPT09IFwiYm9vbGVhblwiIHx8IHR5cGUgPT09IFwibnVtYmVyXCIgfHwgQXJyYXkuaXNBcnJheSh2YWwpIHx8IGlzUGxhaW5PYmplY3QodmFsKTtcbn1cbmZ1bmN0aW9uIGZpbmROb25TZXJpYWxpemFibGVWYWx1ZSh2YWx1ZSwgcGF0aCA9IFwiXCIsIGlzU2VyaWFsaXphYmxlID0gaXNQbGFpbiwgZ2V0RW50cmllcywgaWdub3JlZFBhdGhzID0gW10sIGNhY2hlKSB7XG4gIGxldCBmb3VuZE5lc3RlZFNlcmlhbGl6YWJsZTtcbiAgaWYgKCFpc1NlcmlhbGl6YWJsZSh2YWx1ZSkpIHtcbiAgICByZXR1cm4ge1xuICAgICAga2V5UGF0aDogcGF0aCB8fCBcIjxyb290PlwiLFxuICAgICAgdmFsdWVcbiAgICB9O1xuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIgfHwgdmFsdWUgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGNhY2hlPy5oYXModmFsdWUpKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IGVudHJpZXMgPSBnZXRFbnRyaWVzICE9IG51bGwgPyBnZXRFbnRyaWVzKHZhbHVlKSA6IE9iamVjdC5lbnRyaWVzKHZhbHVlKTtcbiAgY29uc3QgaGFzSWdub3JlZFBhdGhzID0gaWdub3JlZFBhdGhzLmxlbmd0aCA+IDA7XG4gIGZvciAoY29uc3QgW2tleSwgbmVzdGVkVmFsdWVdIG9mIGVudHJpZXMpIHtcbiAgICBjb25zdCBuZXN0ZWRQYXRoID0gcGF0aCA/IHBhdGggKyBcIi5cIiArIGtleSA6IGtleTtcbiAgICBpZiAoaGFzSWdub3JlZFBhdGhzKSB7XG4gICAgICBjb25zdCBoYXNNYXRjaGVzID0gaWdub3JlZFBhdGhzLnNvbWUoKGlnbm9yZWQpID0+IHtcbiAgICAgICAgaWYgKGlnbm9yZWQgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgICByZXR1cm4gaWdub3JlZC50ZXN0KG5lc3RlZFBhdGgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXN0ZWRQYXRoID09PSBpZ25vcmVkO1xuICAgICAgfSk7XG4gICAgICBpZiAoaGFzTWF0Y2hlcykge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFpc1NlcmlhbGl6YWJsZShuZXN0ZWRWYWx1ZSkpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGtleVBhdGg6IG5lc3RlZFBhdGgsXG4gICAgICAgIHZhbHVlOiBuZXN0ZWRWYWx1ZVxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBuZXN0ZWRWYWx1ZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgZm91bmROZXN0ZWRTZXJpYWxpemFibGUgPSBmaW5kTm9uU2VyaWFsaXphYmxlVmFsdWUobmVzdGVkVmFsdWUsIG5lc3RlZFBhdGgsIGlzU2VyaWFsaXphYmxlLCBnZXRFbnRyaWVzLCBpZ25vcmVkUGF0aHMsIGNhY2hlKTtcbiAgICAgIGlmIChmb3VuZE5lc3RlZFNlcmlhbGl6YWJsZSkge1xuICAgICAgICByZXR1cm4gZm91bmROZXN0ZWRTZXJpYWxpemFibGU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChjYWNoZSAmJiBpc05lc3RlZEZyb3plbih2YWx1ZSkpIGNhY2hlLmFkZCh2YWx1ZSk7XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGlzTmVzdGVkRnJvemVuKHZhbHVlKSB7XG4gIGlmICghT2JqZWN0LmlzRnJvemVuKHZhbHVlKSkgcmV0dXJuIGZhbHNlO1xuICBmb3IgKGNvbnN0IG5lc3RlZFZhbHVlIG9mIE9iamVjdC52YWx1ZXModmFsdWUpKSB7XG4gICAgaWYgKHR5cGVvZiBuZXN0ZWRWYWx1ZSAhPT0gXCJvYmplY3RcIiB8fCBuZXN0ZWRWYWx1ZSA9PT0gbnVsbCkgY29udGludWU7XG4gICAgaWYgKCFpc05lc3RlZEZyb3plbihuZXN0ZWRWYWx1ZSkpIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVNlcmlhbGl6YWJsZVN0YXRlSW52YXJpYW50TWlkZGxld2FyZShvcHRpb25zID0ge30pIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIikge1xuICAgIHJldHVybiAoKSA9PiAobmV4dCkgPT4gKGFjdGlvbikgPT4gbmV4dChhY3Rpb24pO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IHtcbiAgICAgIGlzU2VyaWFsaXphYmxlID0gaXNQbGFpbixcbiAgICAgIGdldEVudHJpZXMsXG4gICAgICBpZ25vcmVkQWN0aW9ucyA9IFtdLFxuICAgICAgaWdub3JlZEFjdGlvblBhdGhzID0gW1wibWV0YS5hcmdcIiwgXCJtZXRhLmJhc2VRdWVyeU1ldGFcIl0sXG4gICAgICBpZ25vcmVkUGF0aHMgPSBbXSxcbiAgICAgIHdhcm5BZnRlciA9IDMyLFxuICAgICAgaWdub3JlU3RhdGUgPSBmYWxzZSxcbiAgICAgIGlnbm9yZUFjdGlvbnMgPSBmYWxzZSxcbiAgICAgIGRpc2FibGVDYWNoZSA9IGZhbHNlXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgY2FjaGUgPSAhZGlzYWJsZUNhY2hlICYmIFdlYWtTZXQgPyAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtTZXQoKSA6IHZvaWQgMDtcbiAgICByZXR1cm4gKHN0b3JlQVBJKSA9PiAobmV4dCkgPT4gKGFjdGlvbikgPT4ge1xuICAgICAgaWYgKCFpc0FjdGlvbjIoYWN0aW9uKSkge1xuICAgICAgICByZXR1cm4gbmV4dChhY3Rpb24pO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVzdWx0ID0gbmV4dChhY3Rpb24pO1xuICAgICAgY29uc3QgbWVhc3VyZVV0aWxzID0gZ2V0VGltZU1lYXN1cmVVdGlscyh3YXJuQWZ0ZXIsIFwiU2VyaWFsaXphYmxlU3RhdGVJbnZhcmlhbnRNaWRkbGV3YXJlXCIpO1xuICAgICAgaWYgKCFpZ25vcmVBY3Rpb25zICYmICEoaWdub3JlZEFjdGlvbnMubGVuZ3RoICYmIGlnbm9yZWRBY3Rpb25zLmluZGV4T2YoYWN0aW9uLnR5cGUpICE9PSAtMSkpIHtcbiAgICAgICAgbWVhc3VyZVV0aWxzLm1lYXN1cmVUaW1lKCgpID0+IHtcbiAgICAgICAgICBjb25zdCBmb3VuZEFjdGlvbk5vblNlcmlhbGl6YWJsZVZhbHVlID0gZmluZE5vblNlcmlhbGl6YWJsZVZhbHVlKGFjdGlvbiwgXCJcIiwgaXNTZXJpYWxpemFibGUsIGdldEVudHJpZXMsIGlnbm9yZWRBY3Rpb25QYXRocywgY2FjaGUpO1xuICAgICAgICAgIGlmIChmb3VuZEFjdGlvbk5vblNlcmlhbGl6YWJsZVZhbHVlKSB7XG4gICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgIGtleVBhdGgsXG4gICAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgICB9ID0gZm91bmRBY3Rpb25Ob25TZXJpYWxpemFibGVWYWx1ZTtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEEgbm9uLXNlcmlhbGl6YWJsZSB2YWx1ZSB3YXMgZGV0ZWN0ZWQgaW4gYW4gYWN0aW9uLCBpbiB0aGUgcGF0aDogXFxgJHtrZXlQYXRofVxcYC4gVmFsdWU6YCwgdmFsdWUsIFwiXFxuVGFrZSBhIGxvb2sgYXQgdGhlIGxvZ2ljIHRoYXQgZGlzcGF0Y2hlZCB0aGlzIGFjdGlvbjogXCIsIGFjdGlvbiwgXCJcXG4oU2VlIGh0dHBzOi8vcmVkdXguanMub3JnL2ZhcS9hY3Rpb25zI3doeS1zaG91bGQtdHlwZS1iZS1hLXN0cmluZy1vci1hdC1sZWFzdC1zZXJpYWxpemFibGUtd2h5LXNob3VsZC1teS1hY3Rpb24tdHlwZXMtYmUtY29uc3RhbnRzKVwiLCBcIlxcbihUbyBhbGxvdyBub24tc2VyaWFsaXphYmxlIHZhbHVlcyBzZWU6IGh0dHBzOi8vcmVkdXgtdG9vbGtpdC5qcy5vcmcvdXNhZ2UvdXNhZ2UtZ3VpZGUjd29ya2luZy13aXRoLW5vbi1zZXJpYWxpemFibGUtZGF0YSlcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmICghaWdub3JlU3RhdGUpIHtcbiAgICAgICAgbWVhc3VyZVV0aWxzLm1lYXN1cmVUaW1lKCgpID0+IHtcbiAgICAgICAgICBjb25zdCBzdGF0ZSA9IHN0b3JlQVBJLmdldFN0YXRlKCk7XG4gICAgICAgICAgY29uc3QgZm91bmRTdGF0ZU5vblNlcmlhbGl6YWJsZVZhbHVlID0gZmluZE5vblNlcmlhbGl6YWJsZVZhbHVlKHN0YXRlLCBcIlwiLCBpc1NlcmlhbGl6YWJsZSwgZ2V0RW50cmllcywgaWdub3JlZFBhdGhzLCBjYWNoZSk7XG4gICAgICAgICAgaWYgKGZvdW5kU3RhdGVOb25TZXJpYWxpemFibGVWYWx1ZSkge1xuICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICBrZXlQYXRoLFxuICAgICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICAgfSA9IGZvdW5kU3RhdGVOb25TZXJpYWxpemFibGVWYWx1ZTtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEEgbm9uLXNlcmlhbGl6YWJsZSB2YWx1ZSB3YXMgZGV0ZWN0ZWQgaW4gdGhlIHN0YXRlLCBpbiB0aGUgcGF0aDogXFxgJHtrZXlQYXRofVxcYC4gVmFsdWU6YCwgdmFsdWUsIGBcblRha2UgYSBsb29rIGF0IHRoZSByZWR1Y2VyKHMpIGhhbmRsaW5nIHRoaXMgYWN0aW9uIHR5cGU6ICR7YWN0aW9uLnR5cGV9LlxuKFNlZSBodHRwczovL3JlZHV4LmpzLm9yZy9mYXEvb3JnYW5pemluZy1zdGF0ZSNjYW4taS1wdXQtZnVuY3Rpb25zLXByb21pc2VzLW9yLW90aGVyLW5vbi1zZXJpYWxpemFibGUtaXRlbXMtaW4tbXktc3RvcmUtc3RhdGUpYCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgbWVhc3VyZVV0aWxzLndhcm5JZkV4Y2VlZGVkKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gIH1cbn1cblxuLy8gc3JjL2dldERlZmF1bHRNaWRkbGV3YXJlLnRzXG5mdW5jdGlvbiBpc0Jvb2xlYW4oeCkge1xuICByZXR1cm4gdHlwZW9mIHggPT09IFwiYm9vbGVhblwiO1xufVxudmFyIGJ1aWxkR2V0RGVmYXVsdE1pZGRsZXdhcmUgPSAoKSA9PiBmdW5jdGlvbiBnZXREZWZhdWx0TWlkZGxld2FyZShvcHRpb25zKSB7XG4gIGNvbnN0IHtcbiAgICB0aHVuayA9IHRydWUsXG4gICAgaW1tdXRhYmxlQ2hlY2sgPSB0cnVlLFxuICAgIHNlcmlhbGl6YWJsZUNoZWNrID0gdHJ1ZSxcbiAgICBhY3Rpb25DcmVhdG9yQ2hlY2sgPSB0cnVlXG4gIH0gPSBvcHRpb25zID8/IHt9O1xuICBsZXQgbWlkZGxld2FyZUFycmF5ID0gbmV3IFR1cGxlKCk7XG4gIGlmICh0aHVuaykge1xuICAgIGlmIChpc0Jvb2xlYW4odGh1bmspKSB7XG4gICAgICBtaWRkbGV3YXJlQXJyYXkucHVzaCh0aHVua01pZGRsZXdhcmUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBtaWRkbGV3YXJlQXJyYXkucHVzaCh3aXRoRXh0cmFBcmd1bWVudCh0aHVuay5leHRyYUFyZ3VtZW50KSk7XG4gICAgfVxuICB9XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICBpZiAoaW1tdXRhYmxlQ2hlY2spIHtcbiAgICAgIGxldCBpbW11dGFibGVPcHRpb25zID0ge307XG4gICAgICBpZiAoIWlzQm9vbGVhbihpbW11dGFibGVDaGVjaykpIHtcbiAgICAgICAgaW1tdXRhYmxlT3B0aW9ucyA9IGltbXV0YWJsZUNoZWNrO1xuICAgICAgfVxuICAgICAgbWlkZGxld2FyZUFycmF5LnVuc2hpZnQoY3JlYXRlSW1tdXRhYmxlU3RhdGVJbnZhcmlhbnRNaWRkbGV3YXJlKGltbXV0YWJsZU9wdGlvbnMpKTtcbiAgICB9XG4gICAgaWYgKHNlcmlhbGl6YWJsZUNoZWNrKSB7XG4gICAgICBsZXQgc2VyaWFsaXphYmxlT3B0aW9ucyA9IHt9O1xuICAgICAgaWYgKCFpc0Jvb2xlYW4oc2VyaWFsaXphYmxlQ2hlY2spKSB7XG4gICAgICAgIHNlcmlhbGl6YWJsZU9wdGlvbnMgPSBzZXJpYWxpemFibGVDaGVjaztcbiAgICAgIH1cbiAgICAgIG1pZGRsZXdhcmVBcnJheS5wdXNoKGNyZWF0ZVNlcmlhbGl6YWJsZVN0YXRlSW52YXJpYW50TWlkZGxld2FyZShzZXJpYWxpemFibGVPcHRpb25zKSk7XG4gICAgfVxuICAgIGlmIChhY3Rpb25DcmVhdG9yQ2hlY2spIHtcbiAgICAgIGxldCBhY3Rpb25DcmVhdG9yT3B0aW9ucyA9IHt9O1xuICAgICAgaWYgKCFpc0Jvb2xlYW4oYWN0aW9uQ3JlYXRvckNoZWNrKSkge1xuICAgICAgICBhY3Rpb25DcmVhdG9yT3B0aW9ucyA9IGFjdGlvbkNyZWF0b3JDaGVjaztcbiAgICAgIH1cbiAgICAgIG1pZGRsZXdhcmVBcnJheS51bnNoaWZ0KGNyZWF0ZUFjdGlvbkNyZWF0b3JJbnZhcmlhbnRNaWRkbGV3YXJlKGFjdGlvbkNyZWF0b3JPcHRpb25zKSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBtaWRkbGV3YXJlQXJyYXk7XG59O1xuXG4vLyBzcmMvYXV0b0JhdGNoRW5oYW5jZXIudHNcbnZhciBTSE9VTERfQVVUT0JBVENIID0gXCJSVEtfYXV0b0JhdGNoXCI7XG52YXIgcHJlcGFyZUF1dG9CYXRjaGVkID0gKCkgPT4gKHBheWxvYWQpID0+ICh7XG4gIHBheWxvYWQsXG4gIG1ldGE6IHtcbiAgICBbU0hPVUxEX0FVVE9CQVRDSF06IHRydWVcbiAgfVxufSk7XG52YXIgY3JlYXRlUXVldWVXaXRoVGltZXIgPSAodGltZW91dCkgPT4ge1xuICByZXR1cm4gKG5vdGlmeSkgPT4ge1xuICAgIHNldFRpbWVvdXQobm90aWZ5LCB0aW1lb3V0KTtcbiAgfTtcbn07XG52YXIgckFGID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lID8gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSA6IGNyZWF0ZVF1ZXVlV2l0aFRpbWVyKDEwKTtcbnZhciBhdXRvQmF0Y2hFbmhhbmNlciA9IChvcHRpb25zID0ge1xuICB0eXBlOiBcInJhZlwiXG59KSA9PiAobmV4dCkgPT4gKC4uLmFyZ3MpID0+IHtcbiAgY29uc3Qgc3RvcmUgPSBuZXh0KC4uLmFyZ3MpO1xuICBsZXQgbm90aWZ5aW5nID0gdHJ1ZTtcbiAgbGV0IHNob3VsZE5vdGlmeUF0RW5kT2ZUaWNrID0gZmFsc2U7XG4gIGxldCBub3RpZmljYXRpb25RdWV1ZWQgPSBmYWxzZTtcbiAgY29uc3QgbGlzdGVuZXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgY29uc3QgcXVldWVDYWxsYmFjayA9IG9wdGlvbnMudHlwZSA9PT0gXCJ0aWNrXCIgPyBxdWV1ZU1pY3JvdGFzayA6IG9wdGlvbnMudHlwZSA9PT0gXCJyYWZcIiA/IHJBRiA6IG9wdGlvbnMudHlwZSA9PT0gXCJjYWxsYmFja1wiID8gb3B0aW9ucy5xdWV1ZU5vdGlmaWNhdGlvbiA6IGNyZWF0ZVF1ZXVlV2l0aFRpbWVyKG9wdGlvbnMudGltZW91dCk7XG4gIGNvbnN0IG5vdGlmeUxpc3RlbmVycyA9ICgpID0+IHtcbiAgICBub3RpZmljYXRpb25RdWV1ZWQgPSBmYWxzZTtcbiAgICBpZiAoc2hvdWxkTm90aWZ5QXRFbmRPZlRpY2spIHtcbiAgICAgIHNob3VsZE5vdGlmeUF0RW5kT2ZUaWNrID0gZmFsc2U7XG4gICAgICBsaXN0ZW5lcnMuZm9yRWFjaCgobCkgPT4gbCgpKTtcbiAgICB9XG4gIH07XG4gIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBzdG9yZSwge1xuICAgIC8vIE92ZXJyaWRlIHRoZSBiYXNlIGBzdG9yZS5zdWJzY3JpYmVgIG1ldGhvZCB0byBrZWVwIG9yaWdpbmFsIGxpc3RlbmVyc1xuICAgIC8vIGZyb20gcnVubmluZyBpZiB3ZSdyZSBkZWxheWluZyBub3RpZmljYXRpb25zXG4gICAgc3Vic2NyaWJlKGxpc3RlbmVyMikge1xuICAgICAgY29uc3Qgd3JhcHBlZExpc3RlbmVyID0gKCkgPT4gbm90aWZ5aW5nICYmIGxpc3RlbmVyMigpO1xuICAgICAgY29uc3QgdW5zdWJzY3JpYmUgPSBzdG9yZS5zdWJzY3JpYmUod3JhcHBlZExpc3RlbmVyKTtcbiAgICAgIGxpc3RlbmVycy5hZGQobGlzdGVuZXIyKTtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIHVuc3Vic2NyaWJlKCk7XG4gICAgICAgIGxpc3RlbmVycy5kZWxldGUobGlzdGVuZXIyKTtcbiAgICAgIH07XG4gICAgfSxcbiAgICAvLyBPdmVycmlkZSB0aGUgYmFzZSBgc3RvcmUuZGlzcGF0Y2hgIG1ldGhvZCBzbyB0aGF0IHdlIGNhbiBjaGVjayBhY3Rpb25zXG4gICAgLy8gZm9yIHRoZSBgc2hvdWxkQXV0b0JhdGNoYCBmbGFnIGFuZCBkZXRlcm1pbmUgaWYgYmF0Y2hpbmcgaXMgYWN0aXZlXG4gICAgZGlzcGF0Y2goYWN0aW9uKSB7XG4gICAgICB0cnkge1xuICAgICAgICBub3RpZnlpbmcgPSAhYWN0aW9uPy5tZXRhPy5bU0hPVUxEX0FVVE9CQVRDSF07XG4gICAgICAgIHNob3VsZE5vdGlmeUF0RW5kT2ZUaWNrID0gIW5vdGlmeWluZztcbiAgICAgICAgaWYgKHNob3VsZE5vdGlmeUF0RW5kT2ZUaWNrKSB7XG4gICAgICAgICAgaWYgKCFub3RpZmljYXRpb25RdWV1ZWQpIHtcbiAgICAgICAgICAgIG5vdGlmaWNhdGlvblF1ZXVlZCA9IHRydWU7XG4gICAgICAgICAgICBxdWV1ZUNhbGxiYWNrKG5vdGlmeUxpc3RlbmVycyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdG9yZS5kaXNwYXRjaChhY3Rpb24pO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgbm90aWZ5aW5nID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufTtcblxuLy8gc3JjL2dldERlZmF1bHRFbmhhbmNlcnMudHNcbnZhciBidWlsZEdldERlZmF1bHRFbmhhbmNlcnMgPSAobWlkZGxld2FyZUVuaGFuY2VyKSA9PiBmdW5jdGlvbiBnZXREZWZhdWx0RW5oYW5jZXJzKG9wdGlvbnMpIHtcbiAgY29uc3Qge1xuICAgIGF1dG9CYXRjaCA9IHRydWVcbiAgfSA9IG9wdGlvbnMgPz8ge307XG4gIGxldCBlbmhhbmNlckFycmF5ID0gbmV3IFR1cGxlKG1pZGRsZXdhcmVFbmhhbmNlcik7XG4gIGlmIChhdXRvQmF0Y2gpIHtcbiAgICBlbmhhbmNlckFycmF5LnB1c2goYXV0b0JhdGNoRW5oYW5jZXIodHlwZW9mIGF1dG9CYXRjaCA9PT0gXCJvYmplY3RcIiA/IGF1dG9CYXRjaCA6IHZvaWQgMCkpO1xuICB9XG4gIHJldHVybiBlbmhhbmNlckFycmF5O1xufTtcblxuLy8gc3JjL2NvbmZpZ3VyZVN0b3JlLnRzXG5mdW5jdGlvbiBjb25maWd1cmVTdG9yZShvcHRpb25zKSB7XG4gIGNvbnN0IGdldERlZmF1bHRNaWRkbGV3YXJlID0gYnVpbGRHZXREZWZhdWx0TWlkZGxld2FyZSgpO1xuICBjb25zdCB7XG4gICAgcmVkdWNlciA9IHZvaWQgMCxcbiAgICBtaWRkbGV3YXJlLFxuICAgIGRldlRvb2xzID0gdHJ1ZSxcbiAgICBwcmVsb2FkZWRTdGF0ZSA9IHZvaWQgMCxcbiAgICBlbmhhbmNlcnMgPSB2b2lkIDBcbiAgfSA9IG9wdGlvbnMgfHwge307XG4gIGxldCByb290UmVkdWNlcjtcbiAgaWYgKHR5cGVvZiByZWR1Y2VyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICByb290UmVkdWNlciA9IHJlZHVjZXI7XG4gIH0gZWxzZSBpZiAoaXNQbGFpbk9iamVjdDIocmVkdWNlcikpIHtcbiAgICByb290UmVkdWNlciA9IGNvbWJpbmVSZWR1Y2VycyhyZWR1Y2VyKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgxKSA6IFwiYHJlZHVjZXJgIGlzIGEgcmVxdWlyZWQgYXJndW1lbnQsIGFuZCBtdXN0IGJlIGEgZnVuY3Rpb24gb3IgYW4gb2JqZWN0IG9mIGZ1bmN0aW9ucyB0aGF0IGNhbiBiZSBwYXNzZWQgdG8gY29tYmluZVJlZHVjZXJzXCIpO1xuICB9XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgbWlkZGxld2FyZSAmJiB0eXBlb2YgbWlkZGxld2FyZSAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMikgOiBcImBtaWRkbGV3YXJlYCBmaWVsZCBtdXN0IGJlIGEgY2FsbGJhY2tcIik7XG4gIH1cbiAgbGV0IGZpbmFsTWlkZGxld2FyZTtcbiAgaWYgKHR5cGVvZiBtaWRkbGV3YXJlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBmaW5hbE1pZGRsZXdhcmUgPSBtaWRkbGV3YXJlKGdldERlZmF1bHRNaWRkbGV3YXJlKTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmICFBcnJheS5pc0FycmF5KGZpbmFsTWlkZGxld2FyZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDMpIDogXCJ3aGVuIHVzaW5nIGEgbWlkZGxld2FyZSBidWlsZGVyIGZ1bmN0aW9uLCBhbiBhcnJheSBvZiBtaWRkbGV3YXJlIG11c3QgYmUgcmV0dXJuZWRcIik7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZpbmFsTWlkZGxld2FyZSA9IGdldERlZmF1bHRNaWRkbGV3YXJlKCk7XG4gIH1cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBmaW5hbE1pZGRsZXdhcmUuc29tZSgoaXRlbSkgPT4gdHlwZW9mIGl0ZW0gIT09IFwiZnVuY3Rpb25cIikpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSg0KSA6IFwiZWFjaCBtaWRkbGV3YXJlIHByb3ZpZGVkIHRvIGNvbmZpZ3VyZVN0b3JlIG11c3QgYmUgYSBmdW5jdGlvblwiKTtcbiAgfVxuICBsZXQgZmluYWxDb21wb3NlID0gY29tcG9zZTI7XG4gIGlmIChkZXZUb29scykge1xuICAgIGZpbmFsQ29tcG9zZSA9IGNvbXBvc2VXaXRoRGV2VG9vbHMoe1xuICAgICAgLy8gRW5hYmxlIGNhcHR1cmUgb2Ygc3RhY2sgdHJhY2VzIGZvciBkaXNwYXRjaGVkIFJlZHV4IGFjdGlvbnNcbiAgICAgIHRyYWNlOiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIsXG4gICAgICAuLi50eXBlb2YgZGV2VG9vbHMgPT09IFwib2JqZWN0XCIgJiYgZGV2VG9vbHNcbiAgICB9KTtcbiAgfVxuICBjb25zdCBtaWRkbGV3YXJlRW5oYW5jZXIgPSBhcHBseU1pZGRsZXdhcmUoLi4uZmluYWxNaWRkbGV3YXJlKTtcbiAgY29uc3QgZ2V0RGVmYXVsdEVuaGFuY2VycyA9IGJ1aWxkR2V0RGVmYXVsdEVuaGFuY2VycyhtaWRkbGV3YXJlRW5oYW5jZXIpO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIGVuaGFuY2VycyAmJiB0eXBlb2YgZW5oYW5jZXJzICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSg1KSA6IFwiYGVuaGFuY2Vyc2AgZmllbGQgbXVzdCBiZSBhIGNhbGxiYWNrXCIpO1xuICB9XG4gIGxldCBzdG9yZUVuaGFuY2VycyA9IHR5cGVvZiBlbmhhbmNlcnMgPT09IFwiZnVuY3Rpb25cIiA/IGVuaGFuY2VycyhnZXREZWZhdWx0RW5oYW5jZXJzKSA6IGdldERlZmF1bHRFbmhhbmNlcnMoKTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiAhQXJyYXkuaXNBcnJheShzdG9yZUVuaGFuY2VycykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSg2KSA6IFwiYGVuaGFuY2Vyc2AgY2FsbGJhY2sgbXVzdCByZXR1cm4gYW4gYXJyYXlcIik7XG4gIH1cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBzdG9yZUVuaGFuY2Vycy5zb21lKChpdGVtKSA9PiB0eXBlb2YgaXRlbSAhPT0gXCJmdW5jdGlvblwiKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDcpIDogXCJlYWNoIGVuaGFuY2VyIHByb3ZpZGVkIHRvIGNvbmZpZ3VyZVN0b3JlIG11c3QgYmUgYSBmdW5jdGlvblwiKTtcbiAgfVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIGZpbmFsTWlkZGxld2FyZS5sZW5ndGggJiYgIXN0b3JlRW5oYW5jZXJzLmluY2x1ZGVzKG1pZGRsZXdhcmVFbmhhbmNlcikpIHtcbiAgICBjb25zb2xlLmVycm9yKFwibWlkZGxld2FyZXMgd2VyZSBwcm92aWRlZCwgYnV0IG1pZGRsZXdhcmUgZW5oYW5jZXIgd2FzIG5vdCBpbmNsdWRlZCBpbiBmaW5hbCBlbmhhbmNlcnMgLSBtYWtlIHN1cmUgdG8gY2FsbCBgZ2V0RGVmYXVsdEVuaGFuY2Vyc2BcIik7XG4gIH1cbiAgY29uc3QgY29tcG9zZWRFbmhhbmNlciA9IGZpbmFsQ29tcG9zZSguLi5zdG9yZUVuaGFuY2Vycyk7XG4gIHJldHVybiBjcmVhdGVTdG9yZShyb290UmVkdWNlciwgcHJlbG9hZGVkU3RhdGUsIGNvbXBvc2VkRW5oYW5jZXIpO1xufVxuXG4vLyBzcmMvY3JlYXRlUmVkdWNlci50c1xuaW1wb3J0IHsgcHJvZHVjZSBhcyBjcmVhdGVOZXh0U3RhdGUyLCBpc0RyYWZ0IGFzIGlzRHJhZnQyLCBpc0RyYWZ0YWJsZSBhcyBpc0RyYWZ0YWJsZTIgfSBmcm9tIFwiaW1tZXJcIjtcblxuLy8gc3JjL21hcEJ1aWxkZXJzLnRzXG5mdW5jdGlvbiBleGVjdXRlUmVkdWNlckJ1aWxkZXJDYWxsYmFjayhidWlsZGVyQ2FsbGJhY2spIHtcbiAgY29uc3QgYWN0aW9uc01hcCA9IHt9O1xuICBjb25zdCBhY3Rpb25NYXRjaGVycyA9IFtdO1xuICBsZXQgZGVmYXVsdENhc2VSZWR1Y2VyO1xuICBjb25zdCBidWlsZGVyID0ge1xuICAgIGFkZENhc2UodHlwZU9yQWN0aW9uQ3JlYXRvciwgcmVkdWNlcikge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICBpZiAoYWN0aW9uTWF0Y2hlcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDI2KSA6IFwiYGJ1aWxkZXIuYWRkQ2FzZWAgc2hvdWxkIG9ubHkgYmUgY2FsbGVkIGJlZm9yZSBjYWxsaW5nIGBidWlsZGVyLmFkZE1hdGNoZXJgXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkZWZhdWx0Q2FzZVJlZHVjZXIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgyNykgOiBcImBidWlsZGVyLmFkZENhc2VgIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBiZWZvcmUgY2FsbGluZyBgYnVpbGRlci5hZGREZWZhdWx0Q2FzZWBcIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IHR5cGUgPSB0eXBlb2YgdHlwZU9yQWN0aW9uQ3JlYXRvciA9PT0gXCJzdHJpbmdcIiA/IHR5cGVPckFjdGlvbkNyZWF0b3IgOiB0eXBlT3JBY3Rpb25DcmVhdG9yLnR5cGU7XG4gICAgICBpZiAoIXR5cGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMjgpIDogXCJgYnVpbGRlci5hZGRDYXNlYCBjYW5ub3QgYmUgY2FsbGVkIHdpdGggYW4gZW1wdHkgYWN0aW9uIHR5cGVcIik7XG4gICAgICB9XG4gICAgICBpZiAodHlwZSBpbiBhY3Rpb25zTWFwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDI5KSA6IGBcXGBidWlsZGVyLmFkZENhc2VcXGAgY2Fubm90IGJlIGNhbGxlZCB3aXRoIHR3byByZWR1Y2VycyBmb3IgdGhlIHNhbWUgYWN0aW9uIHR5cGUgJyR7dHlwZX0nYCk7XG4gICAgICB9XG4gICAgICBhY3Rpb25zTWFwW3R5cGVdID0gcmVkdWNlcjtcbiAgICAgIHJldHVybiBidWlsZGVyO1xuICAgIH0sXG4gICAgYWRkTWF0Y2hlcihtYXRjaGVyLCByZWR1Y2VyKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgIGlmIChkZWZhdWx0Q2FzZVJlZHVjZXIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgzMCkgOiBcImBidWlsZGVyLmFkZE1hdGNoZXJgIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBiZWZvcmUgY2FsbGluZyBgYnVpbGRlci5hZGREZWZhdWx0Q2FzZWBcIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGFjdGlvbk1hdGNoZXJzLnB1c2goe1xuICAgICAgICBtYXRjaGVyLFxuICAgICAgICByZWR1Y2VyXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBidWlsZGVyO1xuICAgIH0sXG4gICAgYWRkRGVmYXVsdENhc2UocmVkdWNlcikge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICBpZiAoZGVmYXVsdENhc2VSZWR1Y2VyKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMzEpIDogXCJgYnVpbGRlci5hZGREZWZhdWx0Q2FzZWAgY2FuIG9ubHkgYmUgY2FsbGVkIG9uY2VcIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGRlZmF1bHRDYXNlUmVkdWNlciA9IHJlZHVjZXI7XG4gICAgICByZXR1cm4gYnVpbGRlcjtcbiAgICB9XG4gIH07XG4gIGJ1aWxkZXJDYWxsYmFjayhidWlsZGVyKTtcbiAgcmV0dXJuIFthY3Rpb25zTWFwLCBhY3Rpb25NYXRjaGVycywgZGVmYXVsdENhc2VSZWR1Y2VyXTtcbn1cblxuLy8gc3JjL2NyZWF0ZVJlZHVjZXIudHNcbmZ1bmN0aW9uIGlzU3RhdGVGdW5jdGlvbih4KSB7XG4gIHJldHVybiB0eXBlb2YgeCA9PT0gXCJmdW5jdGlvblwiO1xufVxuZnVuY3Rpb24gY3JlYXRlUmVkdWNlcihpbml0aWFsU3RhdGUsIG1hcE9yQnVpbGRlckNhbGxiYWNrKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICBpZiAodHlwZW9mIG1hcE9yQnVpbGRlckNhbGxiYWNrID09PSBcIm9iamVjdFwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSg4KSA6IFwiVGhlIG9iamVjdCBub3RhdGlvbiBmb3IgYGNyZWF0ZVJlZHVjZXJgIGhhcyBiZWVuIHJlbW92ZWQuIFBsZWFzZSB1c2UgdGhlICdidWlsZGVyIGNhbGxiYWNrJyBub3RhdGlvbiBpbnN0ZWFkOiBodHRwczovL3JlZHV4LXRvb2xraXQuanMub3JnL2FwaS9jcmVhdGVSZWR1Y2VyXCIpO1xuICAgIH1cbiAgfVxuICBsZXQgW2FjdGlvbnNNYXAsIGZpbmFsQWN0aW9uTWF0Y2hlcnMsIGZpbmFsRGVmYXVsdENhc2VSZWR1Y2VyXSA9IGV4ZWN1dGVSZWR1Y2VyQnVpbGRlckNhbGxiYWNrKG1hcE9yQnVpbGRlckNhbGxiYWNrKTtcbiAgbGV0IGdldEluaXRpYWxTdGF0ZTtcbiAgaWYgKGlzU3RhdGVGdW5jdGlvbihpbml0aWFsU3RhdGUpKSB7XG4gICAgZ2V0SW5pdGlhbFN0YXRlID0gKCkgPT4gZnJlZXplRHJhZnRhYmxlKGluaXRpYWxTdGF0ZSgpKTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBmcm96ZW5Jbml0aWFsU3RhdGUgPSBmcmVlemVEcmFmdGFibGUoaW5pdGlhbFN0YXRlKTtcbiAgICBnZXRJbml0aWFsU3RhdGUgPSAoKSA9PiBmcm96ZW5Jbml0aWFsU3RhdGU7XG4gIH1cbiAgZnVuY3Rpb24gcmVkdWNlcihzdGF0ZSA9IGdldEluaXRpYWxTdGF0ZSgpLCBhY3Rpb24pIHtcbiAgICBsZXQgY2FzZVJlZHVjZXJzID0gW2FjdGlvbnNNYXBbYWN0aW9uLnR5cGVdLCAuLi5maW5hbEFjdGlvbk1hdGNoZXJzLmZpbHRlcigoe1xuICAgICAgbWF0Y2hlclxuICAgIH0pID0+IG1hdGNoZXIoYWN0aW9uKSkubWFwKCh7XG4gICAgICByZWR1Y2VyOiByZWR1Y2VyMlxuICAgIH0pID0+IHJlZHVjZXIyKV07XG4gICAgaWYgKGNhc2VSZWR1Y2Vycy5maWx0ZXIoKGNyKSA9PiAhIWNyKS5sZW5ndGggPT09IDApIHtcbiAgICAgIGNhc2VSZWR1Y2VycyA9IFtmaW5hbERlZmF1bHRDYXNlUmVkdWNlcl07XG4gICAgfVxuICAgIHJldHVybiBjYXNlUmVkdWNlcnMucmVkdWNlKChwcmV2aW91c1N0YXRlLCBjYXNlUmVkdWNlcikgPT4ge1xuICAgICAgaWYgKGNhc2VSZWR1Y2VyKSB7XG4gICAgICAgIGlmIChpc0RyYWZ0MihwcmV2aW91c1N0YXRlKSkge1xuICAgICAgICAgIGNvbnN0IGRyYWZ0ID0gcHJldmlvdXNTdGF0ZTtcbiAgICAgICAgICBjb25zdCByZXN1bHQgPSBjYXNlUmVkdWNlcihkcmFmdCwgYWN0aW9uKTtcbiAgICAgICAgICBpZiAocmVzdWx0ID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHJldHVybiBwcmV2aW91c1N0YXRlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9IGVsc2UgaWYgKCFpc0RyYWZ0YWJsZTIocHJldmlvdXNTdGF0ZSkpIHtcbiAgICAgICAgICBjb25zdCByZXN1bHQgPSBjYXNlUmVkdWNlcihwcmV2aW91c1N0YXRlLCBhY3Rpb24pO1xuICAgICAgICAgIGlmIChyZXN1bHQgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgaWYgKHByZXZpb3VzU3RhdGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHByZXZpb3VzU3RhdGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSg5KSA6IFwiQSBjYXNlIHJlZHVjZXIgb24gYSBub24tZHJhZnRhYmxlIHZhbHVlIG11c3Qgbm90IHJldHVybiB1bmRlZmluZWRcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZU5leHRTdGF0ZTIocHJldmlvdXNTdGF0ZSwgKGRyYWZ0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gY2FzZVJlZHVjZXIoZHJhZnQsIGFjdGlvbik7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBwcmV2aW91c1N0YXRlO1xuICAgIH0sIHN0YXRlKTtcbiAgfVxuICByZWR1Y2VyLmdldEluaXRpYWxTdGF0ZSA9IGdldEluaXRpYWxTdGF0ZTtcbiAgcmV0dXJuIHJlZHVjZXI7XG59XG5cbi8vIHNyYy9tYXRjaGVycy50c1xudmFyIG1hdGNoZXMgPSAobWF0Y2hlciwgYWN0aW9uKSA9PiB7XG4gIGlmIChoYXNNYXRjaEZ1bmN0aW9uKG1hdGNoZXIpKSB7XG4gICAgcmV0dXJuIG1hdGNoZXIubWF0Y2goYWN0aW9uKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbWF0Y2hlcihhY3Rpb24pO1xuICB9XG59O1xuZnVuY3Rpb24gaXNBbnlPZiguLi5tYXRjaGVycykge1xuICByZXR1cm4gKGFjdGlvbikgPT4ge1xuICAgIHJldHVybiBtYXRjaGVycy5zb21lKChtYXRjaGVyKSA9PiBtYXRjaGVzKG1hdGNoZXIsIGFjdGlvbikpO1xuICB9O1xufVxuZnVuY3Rpb24gaXNBbGxPZiguLi5tYXRjaGVycykge1xuICByZXR1cm4gKGFjdGlvbikgPT4ge1xuICAgIHJldHVybiBtYXRjaGVycy5ldmVyeSgobWF0Y2hlcikgPT4gbWF0Y2hlcyhtYXRjaGVyLCBhY3Rpb24pKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGhhc0V4cGVjdGVkUmVxdWVzdE1ldGFkYXRhKGFjdGlvbiwgdmFsaWRTdGF0dXMpIHtcbiAgaWYgKCFhY3Rpb24gfHwgIWFjdGlvbi5tZXRhKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IGhhc1ZhbGlkUmVxdWVzdElkID0gdHlwZW9mIGFjdGlvbi5tZXRhLnJlcXVlc3RJZCA9PT0gXCJzdHJpbmdcIjtcbiAgY29uc3QgaGFzVmFsaWRSZXF1ZXN0U3RhdHVzID0gdmFsaWRTdGF0dXMuaW5kZXhPZihhY3Rpb24ubWV0YS5yZXF1ZXN0U3RhdHVzKSA+IC0xO1xuICByZXR1cm4gaGFzVmFsaWRSZXF1ZXN0SWQgJiYgaGFzVmFsaWRSZXF1ZXN0U3RhdHVzO1xufVxuZnVuY3Rpb24gaXNBc3luY1RodW5rQXJyYXkoYSkge1xuICByZXR1cm4gdHlwZW9mIGFbMF0gPT09IFwiZnVuY3Rpb25cIiAmJiBcInBlbmRpbmdcIiBpbiBhWzBdICYmIFwiZnVsZmlsbGVkXCIgaW4gYVswXSAmJiBcInJlamVjdGVkXCIgaW4gYVswXTtcbn1cbmZ1bmN0aW9uIGlzUGVuZGluZyguLi5hc3luY1RodW5rcykge1xuICBpZiAoYXN5bmNUaHVua3MubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIChhY3Rpb24pID0+IGhhc0V4cGVjdGVkUmVxdWVzdE1ldGFkYXRhKGFjdGlvbiwgW1wicGVuZGluZ1wiXSk7XG4gIH1cbiAgaWYgKCFpc0FzeW5jVGh1bmtBcnJheShhc3luY1RodW5rcykpIHtcbiAgICByZXR1cm4gaXNQZW5kaW5nKCkoYXN5bmNUaHVua3NbMF0pO1xuICB9XG4gIHJldHVybiBpc0FueU9mKC4uLmFzeW5jVGh1bmtzLm1hcCgoYXN5bmNUaHVuaykgPT4gYXN5bmNUaHVuay5wZW5kaW5nKSk7XG59XG5mdW5jdGlvbiBpc1JlamVjdGVkKC4uLmFzeW5jVGh1bmtzKSB7XG4gIGlmIChhc3luY1RodW5rcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gKGFjdGlvbikgPT4gaGFzRXhwZWN0ZWRSZXF1ZXN0TWV0YWRhdGEoYWN0aW9uLCBbXCJyZWplY3RlZFwiXSk7XG4gIH1cbiAgaWYgKCFpc0FzeW5jVGh1bmtBcnJheShhc3luY1RodW5rcykpIHtcbiAgICByZXR1cm4gaXNSZWplY3RlZCgpKGFzeW5jVGh1bmtzWzBdKTtcbiAgfVxuICByZXR1cm4gaXNBbnlPZiguLi5hc3luY1RodW5rcy5tYXAoKGFzeW5jVGh1bmspID0+IGFzeW5jVGh1bmsucmVqZWN0ZWQpKTtcbn1cbmZ1bmN0aW9uIGlzUmVqZWN0ZWRXaXRoVmFsdWUoLi4uYXN5bmNUaHVua3MpIHtcbiAgY29uc3QgaGFzRmxhZyA9IChhY3Rpb24pID0+IHtcbiAgICByZXR1cm4gYWN0aW9uICYmIGFjdGlvbi5tZXRhICYmIGFjdGlvbi5tZXRhLnJlamVjdGVkV2l0aFZhbHVlO1xuICB9O1xuICBpZiAoYXN5bmNUaHVua3MubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIGlzQWxsT2YoaXNSZWplY3RlZCguLi5hc3luY1RodW5rcyksIGhhc0ZsYWcpO1xuICB9XG4gIGlmICghaXNBc3luY1RodW5rQXJyYXkoYXN5bmNUaHVua3MpKSB7XG4gICAgcmV0dXJuIGlzUmVqZWN0ZWRXaXRoVmFsdWUoKShhc3luY1RodW5rc1swXSk7XG4gIH1cbiAgcmV0dXJuIGlzQWxsT2YoaXNSZWplY3RlZCguLi5hc3luY1RodW5rcyksIGhhc0ZsYWcpO1xufVxuZnVuY3Rpb24gaXNGdWxmaWxsZWQoLi4uYXN5bmNUaHVua3MpIHtcbiAgaWYgKGFzeW5jVGh1bmtzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiAoYWN0aW9uKSA9PiBoYXNFeHBlY3RlZFJlcXVlc3RNZXRhZGF0YShhY3Rpb24sIFtcImZ1bGZpbGxlZFwiXSk7XG4gIH1cbiAgaWYgKCFpc0FzeW5jVGh1bmtBcnJheShhc3luY1RodW5rcykpIHtcbiAgICByZXR1cm4gaXNGdWxmaWxsZWQoKShhc3luY1RodW5rc1swXSk7XG4gIH1cbiAgcmV0dXJuIGlzQW55T2YoLi4uYXN5bmNUaHVua3MubWFwKChhc3luY1RodW5rKSA9PiBhc3luY1RodW5rLmZ1bGZpbGxlZCkpO1xufVxuZnVuY3Rpb24gaXNBc3luY1RodW5rQWN0aW9uKC4uLmFzeW5jVGh1bmtzKSB7XG4gIGlmIChhc3luY1RodW5rcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gKGFjdGlvbikgPT4gaGFzRXhwZWN0ZWRSZXF1ZXN0TWV0YWRhdGEoYWN0aW9uLCBbXCJwZW5kaW5nXCIsIFwiZnVsZmlsbGVkXCIsIFwicmVqZWN0ZWRcIl0pO1xuICB9XG4gIGlmICghaXNBc3luY1RodW5rQXJyYXkoYXN5bmNUaHVua3MpKSB7XG4gICAgcmV0dXJuIGlzQXN5bmNUaHVua0FjdGlvbigpKGFzeW5jVGh1bmtzWzBdKTtcbiAgfVxuICByZXR1cm4gaXNBbnlPZiguLi5hc3luY1RodW5rcy5mbGF0TWFwKChhc3luY1RodW5rKSA9PiBbYXN5bmNUaHVuay5wZW5kaW5nLCBhc3luY1RodW5rLnJlamVjdGVkLCBhc3luY1RodW5rLmZ1bGZpbGxlZF0pKTtcbn1cblxuLy8gc3JjL25hbm9pZC50c1xudmFyIHVybEFscGhhYmV0ID0gXCJNb2R1bGVTeW1iaGFzT3duUHItMDEyMzQ1Njc4OUFCQ0RFRkdITlJWZmdjdGlVdnpfS3FZVEprTHhwWlhJalFXXCI7XG52YXIgbmFub2lkID0gKHNpemUgPSAyMSkgPT4ge1xuICBsZXQgaWQgPSBcIlwiO1xuICBsZXQgaSA9IHNpemU7XG4gIHdoaWxlIChpLS0pIHtcbiAgICBpZCArPSB1cmxBbHBoYWJldFtNYXRoLnJhbmRvbSgpICogNjQgfCAwXTtcbiAgfVxuICByZXR1cm4gaWQ7XG59O1xuXG4vLyBzcmMvY3JlYXRlQXN5bmNUaHVuay50c1xudmFyIGNvbW1vblByb3BlcnRpZXMgPSBbXCJuYW1lXCIsIFwibWVzc2FnZVwiLCBcInN0YWNrXCIsIFwiY29kZVwiXTtcbnZhciBSZWplY3RXaXRoVmFsdWUgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHBheWxvYWQsIG1ldGEpIHtcbiAgICB0aGlzLnBheWxvYWQgPSBwYXlsb2FkO1xuICAgIHRoaXMubWV0YSA9IG1ldGE7XG4gIH1cbiAgLypcbiAgdHlwZS1vbmx5IHByb3BlcnR5IHRvIGRpc3Rpbmd1aXNoIGJldHdlZW4gUmVqZWN0V2l0aFZhbHVlIGFuZCBGdWxmaWxsV2l0aE1ldGFcbiAgZG9lcyBub3QgZXhpc3QgYXQgcnVudGltZVxuICAqL1xuICBfdHlwZTtcbn07XG52YXIgRnVsZmlsbFdpdGhNZXRhID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihwYXlsb2FkLCBtZXRhKSB7XG4gICAgdGhpcy5wYXlsb2FkID0gcGF5bG9hZDtcbiAgICB0aGlzLm1ldGEgPSBtZXRhO1xuICB9XG4gIC8qXG4gIHR5cGUtb25seSBwcm9wZXJ0eSB0byBkaXN0aW5ndWlzaCBiZXR3ZWVuIFJlamVjdFdpdGhWYWx1ZSBhbmQgRnVsZmlsbFdpdGhNZXRhXG4gIGRvZXMgbm90IGV4aXN0IGF0IHJ1bnRpbWVcbiAgKi9cbiAgX3R5cGU7XG59O1xudmFyIG1pbmlTZXJpYWxpemVFcnJvciA9ICh2YWx1ZSkgPT4ge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmIHZhbHVlICE9PSBudWxsKSB7XG4gICAgY29uc3Qgc2ltcGxlRXJyb3IgPSB7fTtcbiAgICBmb3IgKGNvbnN0IHByb3BlcnR5IG9mIGNvbW1vblByb3BlcnRpZXMpIHtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWVbcHJvcGVydHldID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHNpbXBsZUVycm9yW3Byb3BlcnR5XSA9IHZhbHVlW3Byb3BlcnR5XTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNpbXBsZUVycm9yO1xuICB9XG4gIHJldHVybiB7XG4gICAgbWVzc2FnZTogU3RyaW5nKHZhbHVlKVxuICB9O1xufTtcbnZhciBjcmVhdGVBc3luY1RodW5rID0gLyogQF9fUFVSRV9fICovICgoKSA9PiB7XG4gIGZ1bmN0aW9uIGNyZWF0ZUFzeW5jVGh1bmsyKHR5cGVQcmVmaXgsIHBheWxvYWRDcmVhdG9yLCBvcHRpb25zKSB7XG4gICAgY29uc3QgZnVsZmlsbGVkID0gY3JlYXRlQWN0aW9uKHR5cGVQcmVmaXggKyBcIi9mdWxmaWxsZWRcIiwgKHBheWxvYWQsIHJlcXVlc3RJZCwgYXJnLCBtZXRhKSA9PiAoe1xuICAgICAgcGF5bG9hZCxcbiAgICAgIG1ldGE6IHtcbiAgICAgICAgLi4ubWV0YSB8fCB7fSxcbiAgICAgICAgYXJnLFxuICAgICAgICByZXF1ZXN0SWQsXG4gICAgICAgIHJlcXVlc3RTdGF0dXM6IFwiZnVsZmlsbGVkXCJcbiAgICAgIH1cbiAgICB9KSk7XG4gICAgY29uc3QgcGVuZGluZyA9IGNyZWF0ZUFjdGlvbih0eXBlUHJlZml4ICsgXCIvcGVuZGluZ1wiLCAocmVxdWVzdElkLCBhcmcsIG1ldGEpID0+ICh7XG4gICAgICBwYXlsb2FkOiB2b2lkIDAsXG4gICAgICBtZXRhOiB7XG4gICAgICAgIC4uLm1ldGEgfHwge30sXG4gICAgICAgIGFyZyxcbiAgICAgICAgcmVxdWVzdElkLFxuICAgICAgICByZXF1ZXN0U3RhdHVzOiBcInBlbmRpbmdcIlxuICAgICAgfVxuICAgIH0pKTtcbiAgICBjb25zdCByZWplY3RlZCA9IGNyZWF0ZUFjdGlvbih0eXBlUHJlZml4ICsgXCIvcmVqZWN0ZWRcIiwgKGVycm9yLCByZXF1ZXN0SWQsIGFyZywgcGF5bG9hZCwgbWV0YSkgPT4gKHtcbiAgICAgIHBheWxvYWQsXG4gICAgICBlcnJvcjogKG9wdGlvbnMgJiYgb3B0aW9ucy5zZXJpYWxpemVFcnJvciB8fCBtaW5pU2VyaWFsaXplRXJyb3IpKGVycm9yIHx8IFwiUmVqZWN0ZWRcIiksXG4gICAgICBtZXRhOiB7XG4gICAgICAgIC4uLm1ldGEgfHwge30sXG4gICAgICAgIGFyZyxcbiAgICAgICAgcmVxdWVzdElkLFxuICAgICAgICByZWplY3RlZFdpdGhWYWx1ZTogISFwYXlsb2FkLFxuICAgICAgICByZXF1ZXN0U3RhdHVzOiBcInJlamVjdGVkXCIsXG4gICAgICAgIGFib3J0ZWQ6IGVycm9yPy5uYW1lID09PSBcIkFib3J0RXJyb3JcIixcbiAgICAgICAgY29uZGl0aW9uOiBlcnJvcj8ubmFtZSA9PT0gXCJDb25kaXRpb25FcnJvclwiXG4gICAgICB9XG4gICAgfSkpO1xuICAgIGZ1bmN0aW9uIGFjdGlvbkNyZWF0b3IoYXJnKSB7XG4gICAgICByZXR1cm4gKGRpc3BhdGNoLCBnZXRTdGF0ZSwgZXh0cmEpID0+IHtcbiAgICAgICAgY29uc3QgcmVxdWVzdElkID0gb3B0aW9ucz8uaWRHZW5lcmF0b3IgPyBvcHRpb25zLmlkR2VuZXJhdG9yKGFyZykgOiBuYW5vaWQoKTtcbiAgICAgICAgY29uc3QgYWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgICAgICBsZXQgYWJvcnRIYW5kbGVyO1xuICAgICAgICBsZXQgYWJvcnRSZWFzb247XG4gICAgICAgIGZ1bmN0aW9uIGFib3J0KHJlYXNvbikge1xuICAgICAgICAgIGFib3J0UmVhc29uID0gcmVhc29uO1xuICAgICAgICAgIGFib3J0Q29udHJvbGxlci5hYm9ydCgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByb21pc2UgPSBhc3luYyBmdW5jdGlvbigpIHtcbiAgICAgICAgICBsZXQgZmluYWxBY3Rpb247XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxldCBjb25kaXRpb25SZXN1bHQgPSBvcHRpb25zPy5jb25kaXRpb24/LihhcmcsIHtcbiAgICAgICAgICAgICAgZ2V0U3RhdGUsXG4gICAgICAgICAgICAgIGV4dHJhXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChpc1RoZW5hYmxlKGNvbmRpdGlvblJlc3VsdCkpIHtcbiAgICAgICAgICAgICAgY29uZGl0aW9uUmVzdWx0ID0gYXdhaXQgY29uZGl0aW9uUmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvbmRpdGlvblJlc3VsdCA9PT0gZmFsc2UgfHwgYWJvcnRDb250cm9sbGVyLnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgICAgICAgIHRocm93IHtcbiAgICAgICAgICAgICAgICBuYW1lOiBcIkNvbmRpdGlvbkVycm9yXCIsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogXCJBYm9ydGVkIGR1ZSB0byBjb25kaXRpb24gY2FsbGJhY2sgcmV0dXJuaW5nIGZhbHNlLlwiXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBhYm9ydGVkUHJvbWlzZSA9IG5ldyBQcm9taXNlKChfLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgYWJvcnRIYW5kbGVyID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIHJlamVjdCh7XG4gICAgICAgICAgICAgICAgICBuYW1lOiBcIkFib3J0RXJyb3JcIixcbiAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGFib3J0UmVhc29uIHx8IFwiQWJvcnRlZFwiXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIGFib3J0Q29udHJvbGxlci5zaWduYWwuYWRkRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIGFib3J0SGFuZGxlcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGRpc3BhdGNoKHBlbmRpbmcocmVxdWVzdElkLCBhcmcsIG9wdGlvbnM/LmdldFBlbmRpbmdNZXRhPy4oe1xuICAgICAgICAgICAgICByZXF1ZXN0SWQsXG4gICAgICAgICAgICAgIGFyZ1xuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBnZXRTdGF0ZSxcbiAgICAgICAgICAgICAgZXh0cmFcbiAgICAgICAgICAgIH0pKSk7XG4gICAgICAgICAgICBmaW5hbEFjdGlvbiA9IGF3YWl0IFByb21pc2UucmFjZShbYWJvcnRlZFByb21pc2UsIFByb21pc2UucmVzb2x2ZShwYXlsb2FkQ3JlYXRvcihhcmcsIHtcbiAgICAgICAgICAgICAgZGlzcGF0Y2gsXG4gICAgICAgICAgICAgIGdldFN0YXRlLFxuICAgICAgICAgICAgICBleHRyYSxcbiAgICAgICAgICAgICAgcmVxdWVzdElkLFxuICAgICAgICAgICAgICBzaWduYWw6IGFib3J0Q29udHJvbGxlci5zaWduYWwsXG4gICAgICAgICAgICAgIGFib3J0LFxuICAgICAgICAgICAgICByZWplY3RXaXRoVmFsdWU6ICh2YWx1ZSwgbWV0YSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUmVqZWN0V2l0aFZhbHVlKHZhbHVlLCBtZXRhKTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgZnVsZmlsbFdpdGhWYWx1ZTogKHZhbHVlLCBtZXRhKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBGdWxmaWxsV2l0aE1ldGEodmFsdWUsIG1ldGEpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSkudGhlbigocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBSZWplY3RXaXRoVmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyByZXN1bHQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIEZ1bGZpbGxXaXRoTWV0YSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmdWxmaWxsZWQocmVzdWx0LnBheWxvYWQsIHJlcXVlc3RJZCwgYXJnLCByZXN1bHQubWV0YSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIGZ1bGZpbGxlZChyZXN1bHQsIHJlcXVlc3RJZCwgYXJnKTtcbiAgICAgICAgICAgIH0pXSk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBmaW5hbEFjdGlvbiA9IGVyciBpbnN0YW5jZW9mIFJlamVjdFdpdGhWYWx1ZSA/IHJlamVjdGVkKG51bGwsIHJlcXVlc3RJZCwgYXJnLCBlcnIucGF5bG9hZCwgZXJyLm1ldGEpIDogcmVqZWN0ZWQoZXJyLCByZXF1ZXN0SWQsIGFyZyk7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIGlmIChhYm9ydEhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgYWJvcnRDb250cm9sbGVyLnNpZ25hbC5yZW1vdmVFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgYWJvcnRIYW5kbGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3Qgc2tpcERpc3BhdGNoID0gb3B0aW9ucyAmJiAhb3B0aW9ucy5kaXNwYXRjaENvbmRpdGlvblJlamVjdGlvbiAmJiByZWplY3RlZC5tYXRjaChmaW5hbEFjdGlvbikgJiYgZmluYWxBY3Rpb24ubWV0YS5jb25kaXRpb247XG4gICAgICAgICAgaWYgKCFza2lwRGlzcGF0Y2gpIHtcbiAgICAgICAgICAgIGRpc3BhdGNoKGZpbmFsQWN0aW9uKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGZpbmFsQWN0aW9uO1xuICAgICAgICB9KCk7XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHByb21pc2UsIHtcbiAgICAgICAgICBhYm9ydCxcbiAgICAgICAgICByZXF1ZXN0SWQsXG4gICAgICAgICAgYXJnLFxuICAgICAgICAgIHVud3JhcCgpIHtcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlLnRoZW4odW53cmFwUmVzdWx0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oYWN0aW9uQ3JlYXRvciwge1xuICAgICAgcGVuZGluZyxcbiAgICAgIHJlamVjdGVkLFxuICAgICAgZnVsZmlsbGVkLFxuICAgICAgc2V0dGxlZDogaXNBbnlPZihyZWplY3RlZCwgZnVsZmlsbGVkKSxcbiAgICAgIHR5cGVQcmVmaXhcbiAgICB9KTtcbiAgfVxuICBjcmVhdGVBc3luY1RodW5rMi53aXRoVHlwZXMgPSAoKSA9PiBjcmVhdGVBc3luY1RodW5rMjtcbiAgcmV0dXJuIGNyZWF0ZUFzeW5jVGh1bmsyO1xufSkoKTtcbmZ1bmN0aW9uIHVud3JhcFJlc3VsdChhY3Rpb24pIHtcbiAgaWYgKGFjdGlvbi5tZXRhICYmIGFjdGlvbi5tZXRhLnJlamVjdGVkV2l0aFZhbHVlKSB7XG4gICAgdGhyb3cgYWN0aW9uLnBheWxvYWQ7XG4gIH1cbiAgaWYgKGFjdGlvbi5lcnJvcikge1xuICAgIHRocm93IGFjdGlvbi5lcnJvcjtcbiAgfVxuICByZXR1cm4gYWN0aW9uLnBheWxvYWQ7XG59XG5mdW5jdGlvbiBpc1RoZW5hYmxlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIHZhbHVlLnRoZW4gPT09IFwiZnVuY3Rpb25cIjtcbn1cblxuLy8gc3JjL2NyZWF0ZVNsaWNlLnRzXG52YXIgYXN5bmNUaHVua1N5bWJvbCA9IC8qIEBfX1BVUkVfXyAqLyBTeW1ib2wuZm9yKFwicnRrLXNsaWNlLWNyZWF0ZWFzeW5jdGh1bmtcIik7XG52YXIgYXN5bmNUaHVua0NyZWF0b3IgPSB7XG4gIFthc3luY1RodW5rU3ltYm9sXTogY3JlYXRlQXN5bmNUaHVua1xufTtcbnZhciBSZWR1Y2VyVHlwZSA9IC8qIEBfX1BVUkVfXyAqLyAoKFJlZHVjZXJUeXBlMikgPT4ge1xuICBSZWR1Y2VyVHlwZTJbXCJyZWR1Y2VyXCJdID0gXCJyZWR1Y2VyXCI7XG4gIFJlZHVjZXJUeXBlMltcInJlZHVjZXJXaXRoUHJlcGFyZVwiXSA9IFwicmVkdWNlcldpdGhQcmVwYXJlXCI7XG4gIFJlZHVjZXJUeXBlMltcImFzeW5jVGh1bmtcIl0gPSBcImFzeW5jVGh1bmtcIjtcbiAgcmV0dXJuIFJlZHVjZXJUeXBlMjtcbn0pKFJlZHVjZXJUeXBlIHx8IHt9KTtcbmZ1bmN0aW9uIGdldFR5cGUoc2xpY2UsIGFjdGlvbktleSkge1xuICByZXR1cm4gYCR7c2xpY2V9LyR7YWN0aW9uS2V5fWA7XG59XG5mdW5jdGlvbiBidWlsZENyZWF0ZVNsaWNlKHtcbiAgY3JlYXRvcnNcbn0gPSB7fSkge1xuICBjb25zdCBjQVQgPSBjcmVhdG9ycz8uYXN5bmNUaHVuaz8uW2FzeW5jVGh1bmtTeW1ib2xdO1xuICByZXR1cm4gZnVuY3Rpb24gY3JlYXRlU2xpY2UyKG9wdGlvbnMpIHtcbiAgICBjb25zdCB7XG4gICAgICBuYW1lLFxuICAgICAgcmVkdWNlclBhdGggPSBuYW1lXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgaWYgKCFuYW1lKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgxMSkgOiBcImBuYW1lYCBpcyBhIHJlcXVpcmVkIG9wdGlvbiBmb3IgY3JlYXRlU2xpY2VcIik7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgcHJvY2VzcyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJkZXZlbG9wbWVudFwiKSB7XG4gICAgICBpZiAob3B0aW9ucy5pbml0aWFsU3RhdGUgPT09IHZvaWQgMCkge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiWW91IG11c3QgcHJvdmlkZSBhbiBgaW5pdGlhbFN0YXRlYCB2YWx1ZSB0aGF0IGlzIG5vdCBgdW5kZWZpbmVkYC4gWW91IG1heSBoYXZlIG1pc3NwZWxsZWQgYGluaXRpYWxTdGF0ZWBcIik7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHJlZHVjZXJzID0gKHR5cGVvZiBvcHRpb25zLnJlZHVjZXJzID09PSBcImZ1bmN0aW9uXCIgPyBvcHRpb25zLnJlZHVjZXJzKGJ1aWxkUmVkdWNlckNyZWF0b3JzKCkpIDogb3B0aW9ucy5yZWR1Y2VycykgfHwge307XG4gICAgY29uc3QgcmVkdWNlck5hbWVzID0gT2JqZWN0LmtleXMocmVkdWNlcnMpO1xuICAgIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgICBzbGljZUNhc2VSZWR1Y2Vyc0J5TmFtZToge30sXG4gICAgICBzbGljZUNhc2VSZWR1Y2Vyc0J5VHlwZToge30sXG4gICAgICBhY3Rpb25DcmVhdG9yczoge30sXG4gICAgICBzbGljZU1hdGNoZXJzOiBbXVxuICAgIH07XG4gICAgY29uc3QgY29udGV4dE1ldGhvZHMgPSB7XG4gICAgICBhZGRDYXNlKHR5cGVPckFjdGlvbkNyZWF0b3IsIHJlZHVjZXIyKSB7XG4gICAgICAgIGNvbnN0IHR5cGUgPSB0eXBlb2YgdHlwZU9yQWN0aW9uQ3JlYXRvciA9PT0gXCJzdHJpbmdcIiA/IHR5cGVPckFjdGlvbkNyZWF0b3IgOiB0eXBlT3JBY3Rpb25DcmVhdG9yLnR5cGU7XG4gICAgICAgIGlmICghdHlwZSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDEyKSA6IFwiYGNvbnRleHQuYWRkQ2FzZWAgY2Fubm90IGJlIGNhbGxlZCB3aXRoIGFuIGVtcHR5IGFjdGlvbiB0eXBlXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlIGluIGNvbnRleHQuc2xpY2VDYXNlUmVkdWNlcnNCeVR5cGUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgxMykgOiBcImBjb250ZXh0LmFkZENhc2VgIGNhbm5vdCBiZSBjYWxsZWQgd2l0aCB0d28gcmVkdWNlcnMgZm9yIHRoZSBzYW1lIGFjdGlvbiB0eXBlOiBcIiArIHR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRleHQuc2xpY2VDYXNlUmVkdWNlcnNCeVR5cGVbdHlwZV0gPSByZWR1Y2VyMjtcbiAgICAgICAgcmV0dXJuIGNvbnRleHRNZXRob2RzO1xuICAgICAgfSxcbiAgICAgIGFkZE1hdGNoZXIobWF0Y2hlciwgcmVkdWNlcjIpIHtcbiAgICAgICAgY29udGV4dC5zbGljZU1hdGNoZXJzLnB1c2goe1xuICAgICAgICAgIG1hdGNoZXIsXG4gICAgICAgICAgcmVkdWNlcjogcmVkdWNlcjJcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjb250ZXh0TWV0aG9kcztcbiAgICAgIH0sXG4gICAgICBleHBvc2VBY3Rpb24obmFtZTIsIGFjdGlvbkNyZWF0b3IpIHtcbiAgICAgICAgY29udGV4dC5hY3Rpb25DcmVhdG9yc1tuYW1lMl0gPSBhY3Rpb25DcmVhdG9yO1xuICAgICAgICByZXR1cm4gY29udGV4dE1ldGhvZHM7XG4gICAgICB9LFxuICAgICAgZXhwb3NlQ2FzZVJlZHVjZXIobmFtZTIsIHJlZHVjZXIyKSB7XG4gICAgICAgIGNvbnRleHQuc2xpY2VDYXNlUmVkdWNlcnNCeU5hbWVbbmFtZTJdID0gcmVkdWNlcjI7XG4gICAgICAgIHJldHVybiBjb250ZXh0TWV0aG9kcztcbiAgICAgIH1cbiAgICB9O1xuICAgIHJlZHVjZXJOYW1lcy5mb3JFYWNoKChyZWR1Y2VyTmFtZSkgPT4ge1xuICAgICAgY29uc3QgcmVkdWNlckRlZmluaXRpb24gPSByZWR1Y2Vyc1tyZWR1Y2VyTmFtZV07XG4gICAgICBjb25zdCByZWR1Y2VyRGV0YWlscyA9IHtcbiAgICAgICAgcmVkdWNlck5hbWUsXG4gICAgICAgIHR5cGU6IGdldFR5cGUobmFtZSwgcmVkdWNlck5hbWUpLFxuICAgICAgICBjcmVhdGVOb3RhdGlvbjogdHlwZW9mIG9wdGlvbnMucmVkdWNlcnMgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgfTtcbiAgICAgIGlmIChpc0FzeW5jVGh1bmtTbGljZVJlZHVjZXJEZWZpbml0aW9uKHJlZHVjZXJEZWZpbml0aW9uKSkge1xuICAgICAgICBoYW5kbGVUaHVua0Nhc2VSZWR1Y2VyRGVmaW5pdGlvbihyZWR1Y2VyRGV0YWlscywgcmVkdWNlckRlZmluaXRpb24sIGNvbnRleHRNZXRob2RzLCBjQVQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaGFuZGxlTm9ybWFsUmVkdWNlckRlZmluaXRpb24ocmVkdWNlckRldGFpbHMsIHJlZHVjZXJEZWZpbml0aW9uLCBjb250ZXh0TWV0aG9kcyk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgZnVuY3Rpb24gYnVpbGRSZWR1Y2VyKCkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMuZXh0cmFSZWR1Y2VycyA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDE0KSA6IFwiVGhlIG9iamVjdCBub3RhdGlvbiBmb3IgYGNyZWF0ZVNsaWNlLmV4dHJhUmVkdWNlcnNgIGhhcyBiZWVuIHJlbW92ZWQuIFBsZWFzZSB1c2UgdGhlICdidWlsZGVyIGNhbGxiYWNrJyBub3RhdGlvbiBpbnN0ZWFkOiBodHRwczovL3JlZHV4LXRvb2xraXQuanMub3JnL2FwaS9jcmVhdGVTbGljZVwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgW2V4dHJhUmVkdWNlcnMgPSB7fSwgYWN0aW9uTWF0Y2hlcnMgPSBbXSwgZGVmYXVsdENhc2VSZWR1Y2VyID0gdm9pZCAwXSA9IHR5cGVvZiBvcHRpb25zLmV4dHJhUmVkdWNlcnMgPT09IFwiZnVuY3Rpb25cIiA/IGV4ZWN1dGVSZWR1Y2VyQnVpbGRlckNhbGxiYWNrKG9wdGlvbnMuZXh0cmFSZWR1Y2VycykgOiBbb3B0aW9ucy5leHRyYVJlZHVjZXJzXTtcbiAgICAgIGNvbnN0IGZpbmFsQ2FzZVJlZHVjZXJzID0ge1xuICAgICAgICAuLi5leHRyYVJlZHVjZXJzLFxuICAgICAgICAuLi5jb250ZXh0LnNsaWNlQ2FzZVJlZHVjZXJzQnlUeXBlXG4gICAgICB9O1xuICAgICAgcmV0dXJuIGNyZWF0ZVJlZHVjZXIob3B0aW9ucy5pbml0aWFsU3RhdGUsIChidWlsZGVyKSA9PiB7XG4gICAgICAgIGZvciAobGV0IGtleSBpbiBmaW5hbENhc2VSZWR1Y2Vycykge1xuICAgICAgICAgIGJ1aWxkZXIuYWRkQ2FzZShrZXksIGZpbmFsQ2FzZVJlZHVjZXJzW2tleV0pO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IHNNIG9mIGNvbnRleHQuc2xpY2VNYXRjaGVycykge1xuICAgICAgICAgIGJ1aWxkZXIuYWRkTWF0Y2hlcihzTS5tYXRjaGVyLCBzTS5yZWR1Y2VyKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBtIG9mIGFjdGlvbk1hdGNoZXJzKSB7XG4gICAgICAgICAgYnVpbGRlci5hZGRNYXRjaGVyKG0ubWF0Y2hlciwgbS5yZWR1Y2VyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVmYXVsdENhc2VSZWR1Y2VyKSB7XG4gICAgICAgICAgYnVpbGRlci5hZGREZWZhdWx0Q2FzZShkZWZhdWx0Q2FzZVJlZHVjZXIpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3Qgc2VsZWN0U2VsZiA9IChzdGF0ZSkgPT4gc3RhdGU7XG4gICAgY29uc3QgaW5qZWN0ZWRTZWxlY3RvckNhY2hlID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICBsZXQgX3JlZHVjZXI7XG4gICAgZnVuY3Rpb24gcmVkdWNlcihzdGF0ZSwgYWN0aW9uKSB7XG4gICAgICBpZiAoIV9yZWR1Y2VyKSBfcmVkdWNlciA9IGJ1aWxkUmVkdWNlcigpO1xuICAgICAgcmV0dXJuIF9yZWR1Y2VyKHN0YXRlLCBhY3Rpb24pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRJbml0aWFsU3RhdGUoKSB7XG4gICAgICBpZiAoIV9yZWR1Y2VyKSBfcmVkdWNlciA9IGJ1aWxkUmVkdWNlcigpO1xuICAgICAgcmV0dXJuIF9yZWR1Y2VyLmdldEluaXRpYWxTdGF0ZSgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtYWtlU2VsZWN0b3JQcm9wcyhyZWR1Y2VyUGF0aDIsIGluamVjdGVkID0gZmFsc2UpIHtcbiAgICAgIGZ1bmN0aW9uIHNlbGVjdFNsaWNlKHN0YXRlKSB7XG4gICAgICAgIGxldCBzbGljZVN0YXRlID0gc3RhdGVbcmVkdWNlclBhdGgyXTtcbiAgICAgICAgaWYgKHR5cGVvZiBzbGljZVN0YXRlID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgaWYgKGluamVjdGVkKSB7XG4gICAgICAgICAgICBzbGljZVN0YXRlID0gZ2V0SW5pdGlhbFN0YXRlKCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDE1KSA6IFwic2VsZWN0U2xpY2UgcmV0dXJuZWQgdW5kZWZpbmVkIGZvciBhbiB1bmluamVjdGVkIHNsaWNlIHJlZHVjZXJcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzbGljZVN0YXRlO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gZ2V0U2VsZWN0b3JzKHNlbGVjdFN0YXRlID0gc2VsZWN0U2VsZikge1xuICAgICAgICBjb25zdCBzZWxlY3RvckNhY2hlID0gZW1wbGFjZShpbmplY3RlZFNlbGVjdG9yQ2FjaGUsIGluamVjdGVkLCB7XG4gICAgICAgICAgaW5zZXJ0OiAoKSA9PiAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGVtcGxhY2Uoc2VsZWN0b3JDYWNoZSwgc2VsZWN0U3RhdGUsIHtcbiAgICAgICAgICBpbnNlcnQ6ICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG1hcCA9IHt9O1xuICAgICAgICAgICAgZm9yIChjb25zdCBbbmFtZTIsIHNlbGVjdG9yXSBvZiBPYmplY3QuZW50cmllcyhvcHRpb25zLnNlbGVjdG9ycyA/PyB7fSkpIHtcbiAgICAgICAgICAgICAgbWFwW25hbWUyXSA9IHdyYXBTZWxlY3RvcihzZWxlY3Rvciwgc2VsZWN0U3RhdGUsIGdldEluaXRpYWxTdGF0ZSwgaW5qZWN0ZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1hcDtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmVkdWNlclBhdGg6IHJlZHVjZXJQYXRoMixcbiAgICAgICAgZ2V0U2VsZWN0b3JzLFxuICAgICAgICBnZXQgc2VsZWN0b3JzKCkge1xuICAgICAgICAgIHJldHVybiBnZXRTZWxlY3RvcnMoc2VsZWN0U2xpY2UpO1xuICAgICAgICB9LFxuICAgICAgICBzZWxlY3RTbGljZVxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3Qgc2xpY2UgPSB7XG4gICAgICBuYW1lLFxuICAgICAgcmVkdWNlcixcbiAgICAgIGFjdGlvbnM6IGNvbnRleHQuYWN0aW9uQ3JlYXRvcnMsXG4gICAgICBjYXNlUmVkdWNlcnM6IGNvbnRleHQuc2xpY2VDYXNlUmVkdWNlcnNCeU5hbWUsXG4gICAgICBnZXRJbml0aWFsU3RhdGUsXG4gICAgICAuLi5tYWtlU2VsZWN0b3JQcm9wcyhyZWR1Y2VyUGF0aCksXG4gICAgICBpbmplY3RJbnRvKGluamVjdGFibGUsIHtcbiAgICAgICAgcmVkdWNlclBhdGg6IHBhdGhPcHQsXG4gICAgICAgIC4uLmNvbmZpZ1xuICAgICAgfSA9IHt9KSB7XG4gICAgICAgIGNvbnN0IG5ld1JlZHVjZXJQYXRoID0gcGF0aE9wdCA/PyByZWR1Y2VyUGF0aDtcbiAgICAgICAgaW5qZWN0YWJsZS5pbmplY3Qoe1xuICAgICAgICAgIHJlZHVjZXJQYXRoOiBuZXdSZWR1Y2VyUGF0aCxcbiAgICAgICAgICByZWR1Y2VyXG4gICAgICAgIH0sIGNvbmZpZyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgLi4uc2xpY2UsXG4gICAgICAgICAgLi4ubWFrZVNlbGVjdG9yUHJvcHMobmV3UmVkdWNlclBhdGgsIHRydWUpXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gc2xpY2U7XG4gIH07XG59XG5mdW5jdGlvbiB3cmFwU2VsZWN0b3Ioc2VsZWN0b3IsIHNlbGVjdFN0YXRlLCBnZXRJbml0aWFsU3RhdGUsIGluamVjdGVkKSB7XG4gIGZ1bmN0aW9uIHdyYXBwZXIocm9vdFN0YXRlLCAuLi5hcmdzKSB7XG4gICAgbGV0IHNsaWNlU3RhdGUgPSBzZWxlY3RTdGF0ZShyb290U3RhdGUpO1xuICAgIGlmICh0eXBlb2Ygc2xpY2VTdGF0ZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgaWYgKGluamVjdGVkKSB7XG4gICAgICAgIHNsaWNlU3RhdGUgPSBnZXRJbml0aWFsU3RhdGUoKTtcbiAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDE2KSA6IFwic2VsZWN0U3RhdGUgcmV0dXJuZWQgdW5kZWZpbmVkIGZvciBhbiB1bmluamVjdGVkIHNsaWNlIHJlZHVjZXJcIik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzZWxlY3RvcihzbGljZVN0YXRlLCAuLi5hcmdzKTtcbiAgfVxuICB3cmFwcGVyLnVud3JhcHBlZCA9IHNlbGVjdG9yO1xuICByZXR1cm4gd3JhcHBlcjtcbn1cbnZhciBjcmVhdGVTbGljZSA9IC8qIEBfX1BVUkVfXyAqLyBidWlsZENyZWF0ZVNsaWNlKCk7XG5mdW5jdGlvbiBidWlsZFJlZHVjZXJDcmVhdG9ycygpIHtcbiAgZnVuY3Rpb24gYXN5bmNUaHVuayhwYXlsb2FkQ3JlYXRvciwgY29uZmlnKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIF9yZWR1Y2VyRGVmaW5pdGlvblR5cGU6IFwiYXN5bmNUaHVua1wiIC8qIGFzeW5jVGh1bmsgKi8sXG4gICAgICBwYXlsb2FkQ3JlYXRvcixcbiAgICAgIC4uLmNvbmZpZ1xuICAgIH07XG4gIH1cbiAgYXN5bmNUaHVuay53aXRoVHlwZXMgPSAoKSA9PiBhc3luY1RodW5rO1xuICByZXR1cm4ge1xuICAgIHJlZHVjZXIoY2FzZVJlZHVjZXIpIHtcbiAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgLy8gaGFjayBzbyB0aGUgd3JhcHBpbmcgZnVuY3Rpb24gaGFzIHRoZSBzYW1lIG5hbWUgYXMgdGhlIG9yaWdpbmFsXG4gICAgICAgIC8vIHdlIG5lZWQgdG8gY3JlYXRlIGEgd3JhcHBlciBzbyB0aGUgYHJlZHVjZXJEZWZpbml0aW9uVHlwZWAgaXMgbm90IGFzc2lnbmVkIHRvIHRoZSBvcmlnaW5hbFxuICAgICAgICBbY2FzZVJlZHVjZXIubmFtZV0oLi4uYXJncykge1xuICAgICAgICAgIHJldHVybiBjYXNlUmVkdWNlciguLi5hcmdzKTtcbiAgICAgICAgfVxuICAgICAgfVtjYXNlUmVkdWNlci5uYW1lXSwge1xuICAgICAgICBfcmVkdWNlckRlZmluaXRpb25UeXBlOiBcInJlZHVjZXJcIiAvKiByZWR1Y2VyICovXG4gICAgICB9KTtcbiAgICB9LFxuICAgIHByZXBhcmVkUmVkdWNlcihwcmVwYXJlLCByZWR1Y2VyKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBfcmVkdWNlckRlZmluaXRpb25UeXBlOiBcInJlZHVjZXJXaXRoUHJlcGFyZVwiIC8qIHJlZHVjZXJXaXRoUHJlcGFyZSAqLyxcbiAgICAgICAgcHJlcGFyZSxcbiAgICAgICAgcmVkdWNlclxuICAgICAgfTtcbiAgICB9LFxuICAgIGFzeW5jVGh1bmtcbiAgfTtcbn1cbmZ1bmN0aW9uIGhhbmRsZU5vcm1hbFJlZHVjZXJEZWZpbml0aW9uKHtcbiAgdHlwZSxcbiAgcmVkdWNlck5hbWUsXG4gIGNyZWF0ZU5vdGF0aW9uXG59LCBtYXliZVJlZHVjZXJXaXRoUHJlcGFyZSwgY29udGV4dCkge1xuICBsZXQgY2FzZVJlZHVjZXI7XG4gIGxldCBwcmVwYXJlQ2FsbGJhY2s7XG4gIGlmIChcInJlZHVjZXJcIiBpbiBtYXliZVJlZHVjZXJXaXRoUHJlcGFyZSkge1xuICAgIGlmIChjcmVhdGVOb3RhdGlvbiAmJiAhaXNDYXNlUmVkdWNlcldpdGhQcmVwYXJlRGVmaW5pdGlvbihtYXliZVJlZHVjZXJXaXRoUHJlcGFyZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDE3KSA6IFwiUGxlYXNlIHVzZSB0aGUgYGNyZWF0ZS5wcmVwYXJlZFJlZHVjZXJgIG5vdGF0aW9uIGZvciBwcmVwYXJlZCBhY3Rpb24gY3JlYXRvcnMgd2l0aCB0aGUgYGNyZWF0ZWAgbm90YXRpb24uXCIpO1xuICAgIH1cbiAgICBjYXNlUmVkdWNlciA9IG1heWJlUmVkdWNlcldpdGhQcmVwYXJlLnJlZHVjZXI7XG4gICAgcHJlcGFyZUNhbGxiYWNrID0gbWF5YmVSZWR1Y2VyV2l0aFByZXBhcmUucHJlcGFyZTtcbiAgfSBlbHNlIHtcbiAgICBjYXNlUmVkdWNlciA9IG1heWJlUmVkdWNlcldpdGhQcmVwYXJlO1xuICB9XG4gIGNvbnRleHQuYWRkQ2FzZSh0eXBlLCBjYXNlUmVkdWNlcikuZXhwb3NlQ2FzZVJlZHVjZXIocmVkdWNlck5hbWUsIGNhc2VSZWR1Y2VyKS5leHBvc2VBY3Rpb24ocmVkdWNlck5hbWUsIHByZXBhcmVDYWxsYmFjayA/IGNyZWF0ZUFjdGlvbih0eXBlLCBwcmVwYXJlQ2FsbGJhY2spIDogY3JlYXRlQWN0aW9uKHR5cGUpKTtcbn1cbmZ1bmN0aW9uIGlzQXN5bmNUaHVua1NsaWNlUmVkdWNlckRlZmluaXRpb24ocmVkdWNlckRlZmluaXRpb24pIHtcbiAgcmV0dXJuIHJlZHVjZXJEZWZpbml0aW9uLl9yZWR1Y2VyRGVmaW5pdGlvblR5cGUgPT09IFwiYXN5bmNUaHVua1wiIC8qIGFzeW5jVGh1bmsgKi87XG59XG5mdW5jdGlvbiBpc0Nhc2VSZWR1Y2VyV2l0aFByZXBhcmVEZWZpbml0aW9uKHJlZHVjZXJEZWZpbml0aW9uKSB7XG4gIHJldHVybiByZWR1Y2VyRGVmaW5pdGlvbi5fcmVkdWNlckRlZmluaXRpb25UeXBlID09PSBcInJlZHVjZXJXaXRoUHJlcGFyZVwiIC8qIHJlZHVjZXJXaXRoUHJlcGFyZSAqLztcbn1cbmZ1bmN0aW9uIGhhbmRsZVRodW5rQ2FzZVJlZHVjZXJEZWZpbml0aW9uKHtcbiAgdHlwZSxcbiAgcmVkdWNlck5hbWVcbn0sIHJlZHVjZXJEZWZpbml0aW9uLCBjb250ZXh0LCBjQVQpIHtcbiAgaWYgKCFjQVQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgxOCkgOiBcIkNhbm5vdCB1c2UgYGNyZWF0ZS5hc3luY1RodW5rYCBpbiB0aGUgYnVpbHQtaW4gYGNyZWF0ZVNsaWNlYC4gVXNlIGBidWlsZENyZWF0ZVNsaWNlKHsgY3JlYXRvcnM6IHsgYXN5bmNUaHVuazogYXN5bmNUaHVua0NyZWF0b3IgfSB9KWAgdG8gY3JlYXRlIGEgY3VzdG9taXNlZCB2ZXJzaW9uIG9mIGBjcmVhdGVTbGljZWAuXCIpO1xuICB9XG4gIGNvbnN0IHtcbiAgICBwYXlsb2FkQ3JlYXRvcixcbiAgICBmdWxmaWxsZWQsXG4gICAgcGVuZGluZyxcbiAgICByZWplY3RlZCxcbiAgICBzZXR0bGVkLFxuICAgIG9wdGlvbnNcbiAgfSA9IHJlZHVjZXJEZWZpbml0aW9uO1xuICBjb25zdCB0aHVuayA9IGNBVCh0eXBlLCBwYXlsb2FkQ3JlYXRvciwgb3B0aW9ucyk7XG4gIGNvbnRleHQuZXhwb3NlQWN0aW9uKHJlZHVjZXJOYW1lLCB0aHVuayk7XG4gIGlmIChmdWxmaWxsZWQpIHtcbiAgICBjb250ZXh0LmFkZENhc2UodGh1bmsuZnVsZmlsbGVkLCBmdWxmaWxsZWQpO1xuICB9XG4gIGlmIChwZW5kaW5nKSB7XG4gICAgY29udGV4dC5hZGRDYXNlKHRodW5rLnBlbmRpbmcsIHBlbmRpbmcpO1xuICB9XG4gIGlmIChyZWplY3RlZCkge1xuICAgIGNvbnRleHQuYWRkQ2FzZSh0aHVuay5yZWplY3RlZCwgcmVqZWN0ZWQpO1xuICB9XG4gIGlmIChzZXR0bGVkKSB7XG4gICAgY29udGV4dC5hZGRNYXRjaGVyKHRodW5rLnNldHRsZWQsIHNldHRsZWQpO1xuICB9XG4gIGNvbnRleHQuZXhwb3NlQ2FzZVJlZHVjZXIocmVkdWNlck5hbWUsIHtcbiAgICBmdWxmaWxsZWQ6IGZ1bGZpbGxlZCB8fCBub29wLFxuICAgIHBlbmRpbmc6IHBlbmRpbmcgfHwgbm9vcCxcbiAgICByZWplY3RlZDogcmVqZWN0ZWQgfHwgbm9vcCxcbiAgICBzZXR0bGVkOiBzZXR0bGVkIHx8IG5vb3BcbiAgfSk7XG59XG5mdW5jdGlvbiBub29wKCkge1xufVxuXG4vLyBzcmMvZW50aXRpZXMvZW50aXR5X3N0YXRlLnRzXG5mdW5jdGlvbiBnZXRJbml0aWFsRW50aXR5U3RhdGUoKSB7XG4gIHJldHVybiB7XG4gICAgaWRzOiBbXSxcbiAgICBlbnRpdGllczoge31cbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUluaXRpYWxTdGF0ZUZhY3Rvcnkoc3RhdGVBZGFwdGVyKSB7XG4gIGZ1bmN0aW9uIGdldEluaXRpYWxTdGF0ZShhZGRpdGlvbmFsU3RhdGUgPSB7fSwgZW50aXRpZXMpIHtcbiAgICBjb25zdCBzdGF0ZSA9IE9iamVjdC5hc3NpZ24oZ2V0SW5pdGlhbEVudGl0eVN0YXRlKCksIGFkZGl0aW9uYWxTdGF0ZSk7XG4gICAgcmV0dXJuIGVudGl0aWVzID8gc3RhdGVBZGFwdGVyLnNldEFsbChzdGF0ZSwgZW50aXRpZXMpIDogc3RhdGU7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBnZXRJbml0aWFsU3RhdGVcbiAgfTtcbn1cblxuLy8gc3JjL2VudGl0aWVzL3N0YXRlX3NlbGVjdG9ycy50c1xuZnVuY3Rpb24gY3JlYXRlU2VsZWN0b3JzRmFjdG9yeSgpIHtcbiAgZnVuY3Rpb24gZ2V0U2VsZWN0b3JzKHNlbGVjdFN0YXRlLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7XG4gICAgICBjcmVhdGVTZWxlY3RvcjogY3JlYXRlU2VsZWN0b3IyID0gY3JlYXRlRHJhZnRTYWZlU2VsZWN0b3JcbiAgICB9ID0gb3B0aW9ucztcbiAgICBjb25zdCBzZWxlY3RJZHMgPSAoc3RhdGUpID0+IHN0YXRlLmlkcztcbiAgICBjb25zdCBzZWxlY3RFbnRpdGllcyA9IChzdGF0ZSkgPT4gc3RhdGUuZW50aXRpZXM7XG4gICAgY29uc3Qgc2VsZWN0QWxsID0gY3JlYXRlU2VsZWN0b3IyKHNlbGVjdElkcywgc2VsZWN0RW50aXRpZXMsIChpZHMsIGVudGl0aWVzKSA9PiBpZHMubWFwKChpZCkgPT4gZW50aXRpZXNbaWRdKSk7XG4gICAgY29uc3Qgc2VsZWN0SWQgPSAoXywgaWQpID0+IGlkO1xuICAgIGNvbnN0IHNlbGVjdEJ5SWQgPSAoZW50aXRpZXMsIGlkKSA9PiBlbnRpdGllc1tpZF07XG4gICAgY29uc3Qgc2VsZWN0VG90YWwgPSBjcmVhdGVTZWxlY3RvcjIoc2VsZWN0SWRzLCAoaWRzKSA9PiBpZHMubGVuZ3RoKTtcbiAgICBpZiAoIXNlbGVjdFN0YXRlKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzZWxlY3RJZHMsXG4gICAgICAgIHNlbGVjdEVudGl0aWVzLFxuICAgICAgICBzZWxlY3RBbGwsXG4gICAgICAgIHNlbGVjdFRvdGFsLFxuICAgICAgICBzZWxlY3RCeUlkOiBjcmVhdGVTZWxlY3RvcjIoc2VsZWN0RW50aXRpZXMsIHNlbGVjdElkLCBzZWxlY3RCeUlkKVxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3Qgc2VsZWN0R2xvYmFsaXplZEVudGl0aWVzID0gY3JlYXRlU2VsZWN0b3IyKHNlbGVjdFN0YXRlLCBzZWxlY3RFbnRpdGllcyk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNlbGVjdElkczogY3JlYXRlU2VsZWN0b3IyKHNlbGVjdFN0YXRlLCBzZWxlY3RJZHMpLFxuICAgICAgc2VsZWN0RW50aXRpZXM6IHNlbGVjdEdsb2JhbGl6ZWRFbnRpdGllcyxcbiAgICAgIHNlbGVjdEFsbDogY3JlYXRlU2VsZWN0b3IyKHNlbGVjdFN0YXRlLCBzZWxlY3RBbGwpLFxuICAgICAgc2VsZWN0VG90YWw6IGNyZWF0ZVNlbGVjdG9yMihzZWxlY3RTdGF0ZSwgc2VsZWN0VG90YWwpLFxuICAgICAgc2VsZWN0QnlJZDogY3JlYXRlU2VsZWN0b3IyKHNlbGVjdEdsb2JhbGl6ZWRFbnRpdGllcywgc2VsZWN0SWQsIHNlbGVjdEJ5SWQpXG4gICAgfTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGdldFNlbGVjdG9yc1xuICB9O1xufVxuXG4vLyBzcmMvZW50aXRpZXMvc3RhdGVfYWRhcHRlci50c1xuaW1wb3J0IHsgcHJvZHVjZSBhcyBjcmVhdGVOZXh0U3RhdGUzLCBpc0RyYWZ0IGFzIGlzRHJhZnQzIH0gZnJvbSBcImltbWVyXCI7XG52YXIgaXNEcmFmdFR5cGVkID0gaXNEcmFmdDM7XG5mdW5jdGlvbiBjcmVhdGVTaW5nbGVBcmd1bWVudFN0YXRlT3BlcmF0b3IobXV0YXRvcikge1xuICBjb25zdCBvcGVyYXRvciA9IGNyZWF0ZVN0YXRlT3BlcmF0b3IoKF8sIHN0YXRlKSA9PiBtdXRhdG9yKHN0YXRlKSk7XG4gIHJldHVybiBmdW5jdGlvbiBvcGVyYXRpb24oc3RhdGUpIHtcbiAgICByZXR1cm4gb3BlcmF0b3Ioc3RhdGUsIHZvaWQgMCk7XG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVTdGF0ZU9wZXJhdG9yKG11dGF0b3IpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIG9wZXJhdGlvbihzdGF0ZSwgYXJnKSB7XG4gICAgZnVuY3Rpb24gaXNQYXlsb2FkQWN0aW9uQXJndW1lbnQoYXJnMikge1xuICAgICAgcmV0dXJuIGlzRlNBKGFyZzIpO1xuICAgIH1cbiAgICBjb25zdCBydW5NdXRhdG9yID0gKGRyYWZ0KSA9PiB7XG4gICAgICBpZiAoaXNQYXlsb2FkQWN0aW9uQXJndW1lbnQoYXJnKSkge1xuICAgICAgICBtdXRhdG9yKGFyZy5wYXlsb2FkLCBkcmFmdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtdXRhdG9yKGFyZywgZHJhZnQpO1xuICAgICAgfVxuICAgIH07XG4gICAgaWYgKGlzRHJhZnRUeXBlZChzdGF0ZSkpIHtcbiAgICAgIHJ1bk11dGF0b3Ioc3RhdGUpO1xuICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlTmV4dFN0YXRlMyhzdGF0ZSwgcnVuTXV0YXRvcik7XG4gIH07XG59XG5cbi8vIHNyYy9lbnRpdGllcy91dGlscy50c1xuaW1wb3J0IHsgY3VycmVudCBhcyBjdXJyZW50MiwgaXNEcmFmdCBhcyBpc0RyYWZ0NCB9IGZyb20gXCJpbW1lclwiO1xuZnVuY3Rpb24gc2VsZWN0SWRWYWx1ZShlbnRpdHksIHNlbGVjdElkKSB7XG4gIGNvbnN0IGtleSA9IHNlbGVjdElkKGVudGl0eSk7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYga2V5ID09PSB2b2lkIDApIHtcbiAgICBjb25zb2xlLndhcm4oXCJUaGUgZW50aXR5IHBhc3NlZCB0byB0aGUgYHNlbGVjdElkYCBpbXBsZW1lbnRhdGlvbiByZXR1cm5lZCB1bmRlZmluZWQuXCIsIFwiWW91IHNob3VsZCBwcm9iYWJseSBwcm92aWRlIHlvdXIgb3duIGBzZWxlY3RJZGAgaW1wbGVtZW50YXRpb24uXCIsIFwiVGhlIGVudGl0eSB0aGF0IHdhcyBwYXNzZWQ6XCIsIGVudGl0eSwgXCJUaGUgYHNlbGVjdElkYCBpbXBsZW1lbnRhdGlvbjpcIiwgc2VsZWN0SWQudG9TdHJpbmcoKSk7XG4gIH1cbiAgcmV0dXJuIGtleTtcbn1cbmZ1bmN0aW9uIGVuc3VyZUVudGl0aWVzQXJyYXkoZW50aXRpZXMpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGVudGl0aWVzKSkge1xuICAgIGVudGl0aWVzID0gT2JqZWN0LnZhbHVlcyhlbnRpdGllcyk7XG4gIH1cbiAgcmV0dXJuIGVudGl0aWVzO1xufVxuZnVuY3Rpb24gZ2V0Q3VycmVudCh2YWx1ZSkge1xuICByZXR1cm4gaXNEcmFmdDQodmFsdWUpID8gY3VycmVudDIodmFsdWUpIDogdmFsdWU7XG59XG5mdW5jdGlvbiBzcGxpdEFkZGVkVXBkYXRlZEVudGl0aWVzKG5ld0VudGl0aWVzLCBzZWxlY3RJZCwgc3RhdGUpIHtcbiAgbmV3RW50aXRpZXMgPSBlbnN1cmVFbnRpdGllc0FycmF5KG5ld0VudGl0aWVzKTtcbiAgY29uc3QgZXhpc3RpbmdJZHNBcnJheSA9IGdldEN1cnJlbnQoc3RhdGUuaWRzKTtcbiAgY29uc3QgZXhpc3RpbmdJZHMgPSBuZXcgU2V0KGV4aXN0aW5nSWRzQXJyYXkpO1xuICBjb25zdCBhZGRlZCA9IFtdO1xuICBjb25zdCB1cGRhdGVkID0gW107XG4gIGZvciAoY29uc3QgZW50aXR5IG9mIG5ld0VudGl0aWVzKSB7XG4gICAgY29uc3QgaWQgPSBzZWxlY3RJZFZhbHVlKGVudGl0eSwgc2VsZWN0SWQpO1xuICAgIGlmIChleGlzdGluZ0lkcy5oYXMoaWQpKSB7XG4gICAgICB1cGRhdGVkLnB1c2goe1xuICAgICAgICBpZCxcbiAgICAgICAgY2hhbmdlczogZW50aXR5XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgYWRkZWQucHVzaChlbnRpdHkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gW2FkZGVkLCB1cGRhdGVkLCBleGlzdGluZ0lkc0FycmF5XTtcbn1cblxuLy8gc3JjL2VudGl0aWVzL3Vuc29ydGVkX3N0YXRlX2FkYXB0ZXIudHNcbmZ1bmN0aW9uIGNyZWF0ZVVuc29ydGVkU3RhdGVBZGFwdGVyKHNlbGVjdElkKSB7XG4gIGZ1bmN0aW9uIGFkZE9uZU11dGFibHkoZW50aXR5LCBzdGF0ZSkge1xuICAgIGNvbnN0IGtleSA9IHNlbGVjdElkVmFsdWUoZW50aXR5LCBzZWxlY3RJZCk7XG4gICAgaWYgKGtleSBpbiBzdGF0ZS5lbnRpdGllcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzdGF0ZS5pZHMucHVzaChrZXkpO1xuICAgIHN0YXRlLmVudGl0aWVzW2tleV0gPSBlbnRpdHk7XG4gIH1cbiAgZnVuY3Rpb24gYWRkTWFueU11dGFibHkobmV3RW50aXRpZXMsIHN0YXRlKSB7XG4gICAgbmV3RW50aXRpZXMgPSBlbnN1cmVFbnRpdGllc0FycmF5KG5ld0VudGl0aWVzKTtcbiAgICBmb3IgKGNvbnN0IGVudGl0eSBvZiBuZXdFbnRpdGllcykge1xuICAgICAgYWRkT25lTXV0YWJseShlbnRpdHksIHN0YXRlKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gc2V0T25lTXV0YWJseShlbnRpdHksIHN0YXRlKSB7XG4gICAgY29uc3Qga2V5ID0gc2VsZWN0SWRWYWx1ZShlbnRpdHksIHNlbGVjdElkKTtcbiAgICBpZiAoIShrZXkgaW4gc3RhdGUuZW50aXRpZXMpKSB7XG4gICAgICBzdGF0ZS5pZHMucHVzaChrZXkpO1xuICAgIH1cbiAgICA7XG4gICAgc3RhdGUuZW50aXRpZXNba2V5XSA9IGVudGl0eTtcbiAgfVxuICBmdW5jdGlvbiBzZXRNYW55TXV0YWJseShuZXdFbnRpdGllcywgc3RhdGUpIHtcbiAgICBuZXdFbnRpdGllcyA9IGVuc3VyZUVudGl0aWVzQXJyYXkobmV3RW50aXRpZXMpO1xuICAgIGZvciAoY29uc3QgZW50aXR5IG9mIG5ld0VudGl0aWVzKSB7XG4gICAgICBzZXRPbmVNdXRhYmx5KGVudGl0eSwgc3RhdGUpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBzZXRBbGxNdXRhYmx5KG5ld0VudGl0aWVzLCBzdGF0ZSkge1xuICAgIG5ld0VudGl0aWVzID0gZW5zdXJlRW50aXRpZXNBcnJheShuZXdFbnRpdGllcyk7XG4gICAgc3RhdGUuaWRzID0gW107XG4gICAgc3RhdGUuZW50aXRpZXMgPSB7fTtcbiAgICBhZGRNYW55TXV0YWJseShuZXdFbnRpdGllcywgc3RhdGUpO1xuICB9XG4gIGZ1bmN0aW9uIHJlbW92ZU9uZU11dGFibHkoa2V5LCBzdGF0ZSkge1xuICAgIHJldHVybiByZW1vdmVNYW55TXV0YWJseShba2V5XSwgc3RhdGUpO1xuICB9XG4gIGZ1bmN0aW9uIHJlbW92ZU1hbnlNdXRhYmx5KGtleXMsIHN0YXRlKSB7XG4gICAgbGV0IGRpZE11dGF0ZSA9IGZhbHNlO1xuICAgIGtleXMuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICBpZiAoa2V5IGluIHN0YXRlLmVudGl0aWVzKSB7XG4gICAgICAgIGRlbGV0ZSBzdGF0ZS5lbnRpdGllc1trZXldO1xuICAgICAgICBkaWRNdXRhdGUgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChkaWRNdXRhdGUpIHtcbiAgICAgIHN0YXRlLmlkcyA9IHN0YXRlLmlkcy5maWx0ZXIoKGlkKSA9PiBpZCBpbiBzdGF0ZS5lbnRpdGllcyk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHJlbW92ZUFsbE11dGFibHkoc3RhdGUpIHtcbiAgICBPYmplY3QuYXNzaWduKHN0YXRlLCB7XG4gICAgICBpZHM6IFtdLFxuICAgICAgZW50aXRpZXM6IHt9XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gdGFrZU5ld0tleShrZXlzLCB1cGRhdGUsIHN0YXRlKSB7XG4gICAgY29uc3Qgb3JpZ2luYWwzID0gc3RhdGUuZW50aXRpZXNbdXBkYXRlLmlkXTtcbiAgICBpZiAob3JpZ2luYWwzID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgdXBkYXRlZCA9IE9iamVjdC5hc3NpZ24oe30sIG9yaWdpbmFsMywgdXBkYXRlLmNoYW5nZXMpO1xuICAgIGNvbnN0IG5ld0tleSA9IHNlbGVjdElkVmFsdWUodXBkYXRlZCwgc2VsZWN0SWQpO1xuICAgIGNvbnN0IGhhc05ld0tleSA9IG5ld0tleSAhPT0gdXBkYXRlLmlkO1xuICAgIGlmIChoYXNOZXdLZXkpIHtcbiAgICAgIGtleXNbdXBkYXRlLmlkXSA9IG5ld0tleTtcbiAgICAgIGRlbGV0ZSBzdGF0ZS5lbnRpdGllc1t1cGRhdGUuaWRdO1xuICAgIH1cbiAgICA7XG4gICAgc3RhdGUuZW50aXRpZXNbbmV3S2V5XSA9IHVwZGF0ZWQ7XG4gICAgcmV0dXJuIGhhc05ld0tleTtcbiAgfVxuICBmdW5jdGlvbiB1cGRhdGVPbmVNdXRhYmx5KHVwZGF0ZSwgc3RhdGUpIHtcbiAgICByZXR1cm4gdXBkYXRlTWFueU11dGFibHkoW3VwZGF0ZV0sIHN0YXRlKTtcbiAgfVxuICBmdW5jdGlvbiB1cGRhdGVNYW55TXV0YWJseSh1cGRhdGVzLCBzdGF0ZSkge1xuICAgIGNvbnN0IG5ld0tleXMgPSB7fTtcbiAgICBjb25zdCB1cGRhdGVzUGVyRW50aXR5ID0ge307XG4gICAgdXBkYXRlcy5mb3JFYWNoKCh1cGRhdGUpID0+IHtcbiAgICAgIGlmICh1cGRhdGUuaWQgaW4gc3RhdGUuZW50aXRpZXMpIHtcbiAgICAgICAgdXBkYXRlc1BlckVudGl0eVt1cGRhdGUuaWRdID0ge1xuICAgICAgICAgIGlkOiB1cGRhdGUuaWQsXG4gICAgICAgICAgLy8gU3ByZWFkcyBpZ25vcmUgZmFsc3kgdmFsdWVzLCBzbyB0aGlzIHdvcmtzIGV2ZW4gaWYgdGhlcmUgaXNuJ3RcbiAgICAgICAgICAvLyBhbiBleGlzdGluZyB1cGRhdGUgYWxyZWFkeSBhdCB0aGlzIGtleVxuICAgICAgICAgIGNoYW5nZXM6IHtcbiAgICAgICAgICAgIC4uLnVwZGF0ZXNQZXJFbnRpdHlbdXBkYXRlLmlkXT8uY2hhbmdlcyxcbiAgICAgICAgICAgIC4uLnVwZGF0ZS5jaGFuZ2VzXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0pO1xuICAgIHVwZGF0ZXMgPSBPYmplY3QudmFsdWVzKHVwZGF0ZXNQZXJFbnRpdHkpO1xuICAgIGNvbnN0IGRpZE11dGF0ZUVudGl0aWVzID0gdXBkYXRlcy5sZW5ndGggPiAwO1xuICAgIGlmIChkaWRNdXRhdGVFbnRpdGllcykge1xuICAgICAgY29uc3QgZGlkTXV0YXRlSWRzID0gdXBkYXRlcy5maWx0ZXIoKHVwZGF0ZSkgPT4gdGFrZU5ld0tleShuZXdLZXlzLCB1cGRhdGUsIHN0YXRlKSkubGVuZ3RoID4gMDtcbiAgICAgIGlmIChkaWRNdXRhdGVJZHMpIHtcbiAgICAgICAgc3RhdGUuaWRzID0gT2JqZWN0LnZhbHVlcyhzdGF0ZS5lbnRpdGllcykubWFwKChlKSA9PiBzZWxlY3RJZFZhbHVlKGUsIHNlbGVjdElkKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHVwc2VydE9uZU11dGFibHkoZW50aXR5LCBzdGF0ZSkge1xuICAgIHJldHVybiB1cHNlcnRNYW55TXV0YWJseShbZW50aXR5XSwgc3RhdGUpO1xuICB9XG4gIGZ1bmN0aW9uIHVwc2VydE1hbnlNdXRhYmx5KG5ld0VudGl0aWVzLCBzdGF0ZSkge1xuICAgIGNvbnN0IFthZGRlZCwgdXBkYXRlZF0gPSBzcGxpdEFkZGVkVXBkYXRlZEVudGl0aWVzKG5ld0VudGl0aWVzLCBzZWxlY3RJZCwgc3RhdGUpO1xuICAgIHVwZGF0ZU1hbnlNdXRhYmx5KHVwZGF0ZWQsIHN0YXRlKTtcbiAgICBhZGRNYW55TXV0YWJseShhZGRlZCwgc3RhdGUpO1xuICB9XG4gIHJldHVybiB7XG4gICAgcmVtb3ZlQWxsOiBjcmVhdGVTaW5nbGVBcmd1bWVudFN0YXRlT3BlcmF0b3IocmVtb3ZlQWxsTXV0YWJseSksXG4gICAgYWRkT25lOiBjcmVhdGVTdGF0ZU9wZXJhdG9yKGFkZE9uZU11dGFibHkpLFxuICAgIGFkZE1hbnk6IGNyZWF0ZVN0YXRlT3BlcmF0b3IoYWRkTWFueU11dGFibHkpLFxuICAgIHNldE9uZTogY3JlYXRlU3RhdGVPcGVyYXRvcihzZXRPbmVNdXRhYmx5KSxcbiAgICBzZXRNYW55OiBjcmVhdGVTdGF0ZU9wZXJhdG9yKHNldE1hbnlNdXRhYmx5KSxcbiAgICBzZXRBbGw6IGNyZWF0ZVN0YXRlT3BlcmF0b3Ioc2V0QWxsTXV0YWJseSksXG4gICAgdXBkYXRlT25lOiBjcmVhdGVTdGF0ZU9wZXJhdG9yKHVwZGF0ZU9uZU11dGFibHkpLFxuICAgIHVwZGF0ZU1hbnk6IGNyZWF0ZVN0YXRlT3BlcmF0b3IodXBkYXRlTWFueU11dGFibHkpLFxuICAgIHVwc2VydE9uZTogY3JlYXRlU3RhdGVPcGVyYXRvcih1cHNlcnRPbmVNdXRhYmx5KSxcbiAgICB1cHNlcnRNYW55OiBjcmVhdGVTdGF0ZU9wZXJhdG9yKHVwc2VydE1hbnlNdXRhYmx5KSxcbiAgICByZW1vdmVPbmU6IGNyZWF0ZVN0YXRlT3BlcmF0b3IocmVtb3ZlT25lTXV0YWJseSksXG4gICAgcmVtb3ZlTWFueTogY3JlYXRlU3RhdGVPcGVyYXRvcihyZW1vdmVNYW55TXV0YWJseSlcbiAgfTtcbn1cblxuLy8gc3JjL2VudGl0aWVzL3NvcnRlZF9zdGF0ZV9hZGFwdGVyLnRzXG5mdW5jdGlvbiBmaW5kSW5zZXJ0SW5kZXgoc29ydGVkSXRlbXMsIGl0ZW0sIGNvbXBhcmlzb25GdW5jdGlvbikge1xuICBsZXQgbG93SW5kZXggPSAwO1xuICBsZXQgaGlnaEluZGV4ID0gc29ydGVkSXRlbXMubGVuZ3RoO1xuICB3aGlsZSAobG93SW5kZXggPCBoaWdoSW5kZXgpIHtcbiAgICBsZXQgbWlkZGxlSW5kZXggPSBsb3dJbmRleCArIGhpZ2hJbmRleCA+Pj4gMTtcbiAgICBjb25zdCBjdXJyZW50SXRlbSA9IHNvcnRlZEl0ZW1zW21pZGRsZUluZGV4XTtcbiAgICBjb25zdCByZXMgPSBjb21wYXJpc29uRnVuY3Rpb24oaXRlbSwgY3VycmVudEl0ZW0pO1xuICAgIGlmIChyZXMgPj0gMCkge1xuICAgICAgbG93SW5kZXggPSBtaWRkbGVJbmRleCArIDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGhpZ2hJbmRleCA9IG1pZGRsZUluZGV4O1xuICAgIH1cbiAgfVxuICByZXR1cm4gbG93SW5kZXg7XG59XG5mdW5jdGlvbiBpbnNlcnQoc29ydGVkSXRlbXMsIGl0ZW0sIGNvbXBhcmlzb25GdW5jdGlvbikge1xuICBjb25zdCBpbnNlcnRBdEluZGV4ID0gZmluZEluc2VydEluZGV4KHNvcnRlZEl0ZW1zLCBpdGVtLCBjb21wYXJpc29uRnVuY3Rpb24pO1xuICBzb3J0ZWRJdGVtcy5zcGxpY2UoaW5zZXJ0QXRJbmRleCwgMCwgaXRlbSk7XG4gIHJldHVybiBzb3J0ZWRJdGVtcztcbn1cbmZ1bmN0aW9uIGNyZWF0ZVNvcnRlZFN0YXRlQWRhcHRlcihzZWxlY3RJZCwgY29tcGFyZXIpIHtcbiAgY29uc3Qge1xuICAgIHJlbW92ZU9uZSxcbiAgICByZW1vdmVNYW55LFxuICAgIHJlbW92ZUFsbFxuICB9ID0gY3JlYXRlVW5zb3J0ZWRTdGF0ZUFkYXB0ZXIoc2VsZWN0SWQpO1xuICBmdW5jdGlvbiBhZGRPbmVNdXRhYmx5KGVudGl0eSwgc3RhdGUpIHtcbiAgICByZXR1cm4gYWRkTWFueU11dGFibHkoW2VudGl0eV0sIHN0YXRlKTtcbiAgfVxuICBmdW5jdGlvbiBhZGRNYW55TXV0YWJseShuZXdFbnRpdGllcywgc3RhdGUsIGV4aXN0aW5nSWRzKSB7XG4gICAgbmV3RW50aXRpZXMgPSBlbnN1cmVFbnRpdGllc0FycmF5KG5ld0VudGl0aWVzKTtcbiAgICBjb25zdCBleGlzdGluZ0tleXMgPSBuZXcgU2V0KGV4aXN0aW5nSWRzID8/IGdldEN1cnJlbnQoc3RhdGUuaWRzKSk7XG4gICAgY29uc3QgbW9kZWxzID0gbmV3RW50aXRpZXMuZmlsdGVyKChtb2RlbCkgPT4gIWV4aXN0aW5nS2V5cy5oYXMoc2VsZWN0SWRWYWx1ZShtb2RlbCwgc2VsZWN0SWQpKSk7XG4gICAgaWYgKG1vZGVscy5sZW5ndGggIT09IDApIHtcbiAgICAgIG1lcmdlRnVuY3Rpb24oc3RhdGUsIG1vZGVscyk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHNldE9uZU11dGFibHkoZW50aXR5LCBzdGF0ZSkge1xuICAgIHJldHVybiBzZXRNYW55TXV0YWJseShbZW50aXR5XSwgc3RhdGUpO1xuICB9XG4gIGZ1bmN0aW9uIHNldE1hbnlNdXRhYmx5KG5ld0VudGl0aWVzLCBzdGF0ZSkge1xuICAgIG5ld0VudGl0aWVzID0gZW5zdXJlRW50aXRpZXNBcnJheShuZXdFbnRpdGllcyk7XG4gICAgaWYgKG5ld0VudGl0aWVzLmxlbmd0aCAhPT0gMCkge1xuICAgICAgZm9yIChjb25zdCBpdGVtIG9mIG5ld0VudGl0aWVzKSB7XG4gICAgICAgIGRlbGV0ZSBzdGF0ZS5lbnRpdGllc1tzZWxlY3RJZChpdGVtKV07XG4gICAgICB9XG4gICAgICBtZXJnZUZ1bmN0aW9uKHN0YXRlLCBuZXdFbnRpdGllcyk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHNldEFsbE11dGFibHkobmV3RW50aXRpZXMsIHN0YXRlKSB7XG4gICAgbmV3RW50aXRpZXMgPSBlbnN1cmVFbnRpdGllc0FycmF5KG5ld0VudGl0aWVzKTtcbiAgICBzdGF0ZS5lbnRpdGllcyA9IHt9O1xuICAgIHN0YXRlLmlkcyA9IFtdO1xuICAgIGFkZE1hbnlNdXRhYmx5KG5ld0VudGl0aWVzLCBzdGF0ZSwgW10pO1xuICB9XG4gIGZ1bmN0aW9uIHVwZGF0ZU9uZU11dGFibHkodXBkYXRlLCBzdGF0ZSkge1xuICAgIHJldHVybiB1cGRhdGVNYW55TXV0YWJseShbdXBkYXRlXSwgc3RhdGUpO1xuICB9XG4gIGZ1bmN0aW9uIHVwZGF0ZU1hbnlNdXRhYmx5KHVwZGF0ZXMsIHN0YXRlKSB7XG4gICAgbGV0IGFwcGxpZWRVcGRhdGVzID0gZmFsc2U7XG4gICAgbGV0IHJlcGxhY2VkSWRzID0gZmFsc2U7XG4gICAgZm9yIChsZXQgdXBkYXRlIG9mIHVwZGF0ZXMpIHtcbiAgICAgIGNvbnN0IGVudGl0eSA9IHN0YXRlLmVudGl0aWVzW3VwZGF0ZS5pZF07XG4gICAgICBpZiAoIWVudGl0eSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGFwcGxpZWRVcGRhdGVzID0gdHJ1ZTtcbiAgICAgIE9iamVjdC5hc3NpZ24oZW50aXR5LCB1cGRhdGUuY2hhbmdlcyk7XG4gICAgICBjb25zdCBuZXdJZCA9IHNlbGVjdElkKGVudGl0eSk7XG4gICAgICBpZiAodXBkYXRlLmlkICE9PSBuZXdJZCkge1xuICAgICAgICByZXBsYWNlZElkcyA9IHRydWU7XG4gICAgICAgIGRlbGV0ZSBzdGF0ZS5lbnRpdGllc1t1cGRhdGUuaWRdO1xuICAgICAgICBjb25zdCBvbGRJbmRleCA9IHN0YXRlLmlkcy5pbmRleE9mKHVwZGF0ZS5pZCk7XG4gICAgICAgIHN0YXRlLmlkc1tvbGRJbmRleF0gPSBuZXdJZDtcbiAgICAgICAgc3RhdGUuZW50aXRpZXNbbmV3SWRdID0gZW50aXR5O1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoYXBwbGllZFVwZGF0ZXMpIHtcbiAgICAgIG1lcmdlRnVuY3Rpb24oc3RhdGUsIFtdLCBhcHBsaWVkVXBkYXRlcywgcmVwbGFjZWRJZHMpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiB1cHNlcnRPbmVNdXRhYmx5KGVudGl0eSwgc3RhdGUpIHtcbiAgICByZXR1cm4gdXBzZXJ0TWFueU11dGFibHkoW2VudGl0eV0sIHN0YXRlKTtcbiAgfVxuICBmdW5jdGlvbiB1cHNlcnRNYW55TXV0YWJseShuZXdFbnRpdGllcywgc3RhdGUpIHtcbiAgICBjb25zdCBbYWRkZWQsIHVwZGF0ZWQsIGV4aXN0aW5nSWRzQXJyYXldID0gc3BsaXRBZGRlZFVwZGF0ZWRFbnRpdGllcyhuZXdFbnRpdGllcywgc2VsZWN0SWQsIHN0YXRlKTtcbiAgICBpZiAodXBkYXRlZC5sZW5ndGgpIHtcbiAgICAgIHVwZGF0ZU1hbnlNdXRhYmx5KHVwZGF0ZWQsIHN0YXRlKTtcbiAgICB9XG4gICAgaWYgKGFkZGVkLmxlbmd0aCkge1xuICAgICAgYWRkTWFueU11dGFibHkoYWRkZWQsIHN0YXRlLCBleGlzdGluZ0lkc0FycmF5KTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gYXJlQXJyYXlzRXF1YWwoYSwgYikge1xuICAgIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoYVtpXSA9PT0gYltpXSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgY29uc3QgbWVyZ2VGdW5jdGlvbiA9IChzdGF0ZSwgYWRkZWRJdGVtcywgYXBwbGllZFVwZGF0ZXMsIHJlcGxhY2VkSWRzKSA9PiB7XG4gICAgY29uc3QgY3VycmVudEVudGl0aWVzID0gZ2V0Q3VycmVudChzdGF0ZS5lbnRpdGllcyk7XG4gICAgY29uc3QgY3VycmVudElkcyA9IGdldEN1cnJlbnQoc3RhdGUuaWRzKTtcbiAgICBjb25zdCBzdGF0ZUVudGl0aWVzID0gc3RhdGUuZW50aXRpZXM7XG4gICAgbGV0IGlkcyA9IGN1cnJlbnRJZHM7XG4gICAgaWYgKHJlcGxhY2VkSWRzKSB7XG4gICAgICBpZHMgPSBuZXcgU2V0KGN1cnJlbnRJZHMpO1xuICAgIH1cbiAgICBsZXQgc29ydGVkRW50aXRpZXMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGlkIG9mIGlkcykge1xuICAgICAgY29uc3QgZW50aXR5ID0gY3VycmVudEVudGl0aWVzW2lkXTtcbiAgICAgIGlmIChlbnRpdHkpIHtcbiAgICAgICAgc29ydGVkRW50aXRpZXMucHVzaChlbnRpdHkpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB3YXNQcmV2aW91c2x5RW1wdHkgPSBzb3J0ZWRFbnRpdGllcy5sZW5ndGggPT09IDA7XG4gICAgZm9yIChjb25zdCBpdGVtIG9mIGFkZGVkSXRlbXMpIHtcbiAgICAgIHN0YXRlRW50aXRpZXNbc2VsZWN0SWQoaXRlbSldID0gaXRlbTtcbiAgICAgIGlmICghd2FzUHJldmlvdXNseUVtcHR5KSB7XG4gICAgICAgIGluc2VydChzb3J0ZWRFbnRpdGllcywgaXRlbSwgY29tcGFyZXIpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAod2FzUHJldmlvdXNseUVtcHR5KSB7XG4gICAgICBzb3J0ZWRFbnRpdGllcyA9IGFkZGVkSXRlbXMuc2xpY2UoKS5zb3J0KGNvbXBhcmVyKTtcbiAgICB9IGVsc2UgaWYgKGFwcGxpZWRVcGRhdGVzKSB7XG4gICAgICBzb3J0ZWRFbnRpdGllcy5zb3J0KGNvbXBhcmVyKTtcbiAgICB9XG4gICAgY29uc3QgbmV3U29ydGVkSWRzID0gc29ydGVkRW50aXRpZXMubWFwKHNlbGVjdElkKTtcbiAgICBpZiAoIWFyZUFycmF5c0VxdWFsKGN1cnJlbnRJZHMsIG5ld1NvcnRlZElkcykpIHtcbiAgICAgIHN0YXRlLmlkcyA9IG5ld1NvcnRlZElkcztcbiAgICB9XG4gIH07XG4gIHJldHVybiB7XG4gICAgcmVtb3ZlT25lLFxuICAgIHJlbW92ZU1hbnksXG4gICAgcmVtb3ZlQWxsLFxuICAgIGFkZE9uZTogY3JlYXRlU3RhdGVPcGVyYXRvcihhZGRPbmVNdXRhYmx5KSxcbiAgICB1cGRhdGVPbmU6IGNyZWF0ZVN0YXRlT3BlcmF0b3IodXBkYXRlT25lTXV0YWJseSksXG4gICAgdXBzZXJ0T25lOiBjcmVhdGVTdGF0ZU9wZXJhdG9yKHVwc2VydE9uZU11dGFibHkpLFxuICAgIHNldE9uZTogY3JlYXRlU3RhdGVPcGVyYXRvcihzZXRPbmVNdXRhYmx5KSxcbiAgICBzZXRNYW55OiBjcmVhdGVTdGF0ZU9wZXJhdG9yKHNldE1hbnlNdXRhYmx5KSxcbiAgICBzZXRBbGw6IGNyZWF0ZVN0YXRlT3BlcmF0b3Ioc2V0QWxsTXV0YWJseSksXG4gICAgYWRkTWFueTogY3JlYXRlU3RhdGVPcGVyYXRvcihhZGRNYW55TXV0YWJseSksXG4gICAgdXBkYXRlTWFueTogY3JlYXRlU3RhdGVPcGVyYXRvcih1cGRhdGVNYW55TXV0YWJseSksXG4gICAgdXBzZXJ0TWFueTogY3JlYXRlU3RhdGVPcGVyYXRvcih1cHNlcnRNYW55TXV0YWJseSlcbiAgfTtcbn1cblxuLy8gc3JjL2VudGl0aWVzL2NyZWF0ZV9hZGFwdGVyLnRzXG5mdW5jdGlvbiBjcmVhdGVFbnRpdHlBZGFwdGVyKG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7XG4gICAgc2VsZWN0SWQsXG4gICAgc29ydENvbXBhcmVyXG4gIH0gPSB7XG4gICAgc29ydENvbXBhcmVyOiBmYWxzZSxcbiAgICBzZWxlY3RJZDogKGluc3RhbmNlKSA9PiBpbnN0YW5jZS5pZCxcbiAgICAuLi5vcHRpb25zXG4gIH07XG4gIGNvbnN0IHN0YXRlQWRhcHRlciA9IHNvcnRDb21wYXJlciA/IGNyZWF0ZVNvcnRlZFN0YXRlQWRhcHRlcihzZWxlY3RJZCwgc29ydENvbXBhcmVyKSA6IGNyZWF0ZVVuc29ydGVkU3RhdGVBZGFwdGVyKHNlbGVjdElkKTtcbiAgY29uc3Qgc3RhdGVGYWN0b3J5ID0gY3JlYXRlSW5pdGlhbFN0YXRlRmFjdG9yeShzdGF0ZUFkYXB0ZXIpO1xuICBjb25zdCBzZWxlY3RvcnNGYWN0b3J5ID0gY3JlYXRlU2VsZWN0b3JzRmFjdG9yeSgpO1xuICByZXR1cm4ge1xuICAgIHNlbGVjdElkLFxuICAgIHNvcnRDb21wYXJlcixcbiAgICAuLi5zdGF0ZUZhY3RvcnksXG4gICAgLi4uc2VsZWN0b3JzRmFjdG9yeSxcbiAgICAuLi5zdGF0ZUFkYXB0ZXJcbiAgfTtcbn1cblxuLy8gc3JjL2xpc3RlbmVyTWlkZGxld2FyZS9pbmRleC50c1xuaW1wb3J0IHsgaXNBY3Rpb24gYXMgaXNBY3Rpb24zIH0gZnJvbSBcInJlZHV4XCI7XG5cbi8vIHNyYy9saXN0ZW5lck1pZGRsZXdhcmUvZXhjZXB0aW9ucy50c1xudmFyIHRhc2sgPSBcInRhc2tcIjtcbnZhciBsaXN0ZW5lciA9IFwibGlzdGVuZXJcIjtcbnZhciBjb21wbGV0ZWQgPSBcImNvbXBsZXRlZFwiO1xudmFyIGNhbmNlbGxlZCA9IFwiY2FuY2VsbGVkXCI7XG52YXIgdGFza0NhbmNlbGxlZCA9IGB0YXNrLSR7Y2FuY2VsbGVkfWA7XG52YXIgdGFza0NvbXBsZXRlZCA9IGB0YXNrLSR7Y29tcGxldGVkfWA7XG52YXIgbGlzdGVuZXJDYW5jZWxsZWQgPSBgJHtsaXN0ZW5lcn0tJHtjYW5jZWxsZWR9YDtcbnZhciBsaXN0ZW5lckNvbXBsZXRlZCA9IGAke2xpc3RlbmVyfS0ke2NvbXBsZXRlZH1gO1xudmFyIFRhc2tBYm9ydEVycm9yID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcihjb2RlKSB7XG4gICAgdGhpcy5jb2RlID0gY29kZTtcbiAgICB0aGlzLm1lc3NhZ2UgPSBgJHt0YXNrfSAke2NhbmNlbGxlZH0gKHJlYXNvbjogJHtjb2RlfSlgO1xuICB9XG4gIG5hbWUgPSBcIlRhc2tBYm9ydEVycm9yXCI7XG4gIG1lc3NhZ2U7XG59O1xuXG4vLyBzcmMvbGlzdGVuZXJNaWRkbGV3YXJlL3V0aWxzLnRzXG52YXIgYXNzZXJ0RnVuY3Rpb24gPSAoZnVuYywgZXhwZWN0ZWQpID0+IHtcbiAgaWYgKHR5cGVvZiBmdW5jICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgzMikgOiBgJHtleHBlY3RlZH0gaXMgbm90IGEgZnVuY3Rpb25gKTtcbiAgfVxufTtcbnZhciBub29wMiA9ICgpID0+IHtcbn07XG52YXIgY2F0Y2hSZWplY3Rpb24gPSAocHJvbWlzZSwgb25FcnJvciA9IG5vb3AyKSA9PiB7XG4gIHByb21pc2UuY2F0Y2gob25FcnJvcik7XG4gIHJldHVybiBwcm9taXNlO1xufTtcbnZhciBhZGRBYm9ydFNpZ25hbExpc3RlbmVyID0gKGFib3J0U2lnbmFsLCBjYWxsYmFjaykgPT4ge1xuICBhYm9ydFNpZ25hbC5hZGRFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgY2FsbGJhY2ssIHtcbiAgICBvbmNlOiB0cnVlXG4gIH0pO1xuICByZXR1cm4gKCkgPT4gYWJvcnRTaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIGNhbGxiYWNrKTtcbn07XG52YXIgYWJvcnRDb250cm9sbGVyV2l0aFJlYXNvbiA9IChhYm9ydENvbnRyb2xsZXIsIHJlYXNvbikgPT4ge1xuICBjb25zdCBzaWduYWwgPSBhYm9ydENvbnRyb2xsZXIuc2lnbmFsO1xuICBpZiAoc2lnbmFsLmFib3J0ZWQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKCEoXCJyZWFzb25cIiBpbiBzaWduYWwpKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHNpZ25hbCwgXCJyZWFzb25cIiwge1xuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiByZWFzb24sXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9XG4gIDtcbiAgYWJvcnRDb250cm9sbGVyLmFib3J0KHJlYXNvbik7XG59O1xuXG4vLyBzcmMvbGlzdGVuZXJNaWRkbGV3YXJlL3Rhc2sudHNcbnZhciB2YWxpZGF0ZUFjdGl2ZSA9IChzaWduYWwpID0+IHtcbiAgaWYgKHNpZ25hbC5hYm9ydGVkKSB7XG4gICAgY29uc3Qge1xuICAgICAgcmVhc29uXG4gICAgfSA9IHNpZ25hbDtcbiAgICB0aHJvdyBuZXcgVGFza0Fib3J0RXJyb3IocmVhc29uKTtcbiAgfVxufTtcbmZ1bmN0aW9uIHJhY2VXaXRoU2lnbmFsKHNpZ25hbCwgcHJvbWlzZSkge1xuICBsZXQgY2xlYW51cCA9IG5vb3AyO1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGNvbnN0IG5vdGlmeVJlamVjdGlvbiA9ICgpID0+IHJlamVjdChuZXcgVGFza0Fib3J0RXJyb3Ioc2lnbmFsLnJlYXNvbikpO1xuICAgIGlmIChzaWduYWwuYWJvcnRlZCkge1xuICAgICAgbm90aWZ5UmVqZWN0aW9uKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNsZWFudXAgPSBhZGRBYm9ydFNpZ25hbExpc3RlbmVyKHNpZ25hbCwgbm90aWZ5UmVqZWN0aW9uKTtcbiAgICBwcm9taXNlLmZpbmFsbHkoKCkgPT4gY2xlYW51cCgpKS50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gIH0pLmZpbmFsbHkoKCkgPT4ge1xuICAgIGNsZWFudXAgPSBub29wMjtcbiAgfSk7XG59XG52YXIgcnVuVGFzayA9IGFzeW5jICh0YXNrMiwgY2xlYW5VcCkgPT4ge1xuICB0cnkge1xuICAgIGF3YWl0IFByb21pc2UucmVzb2x2ZSgpO1xuICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgdGFzazIoKTtcbiAgICByZXR1cm4ge1xuICAgICAgc3RhdHVzOiBcIm9rXCIsXG4gICAgICB2YWx1ZVxuICAgIH07XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXR1czogZXJyb3IgaW5zdGFuY2VvZiBUYXNrQWJvcnRFcnJvciA/IFwiY2FuY2VsbGVkXCIgOiBcInJlamVjdGVkXCIsXG4gICAgICBlcnJvclxuICAgIH07XG4gIH0gZmluYWxseSB7XG4gICAgY2xlYW5VcD8uKCk7XG4gIH1cbn07XG52YXIgY3JlYXRlUGF1c2UgPSAoc2lnbmFsKSA9PiB7XG4gIHJldHVybiAocHJvbWlzZSkgPT4ge1xuICAgIHJldHVybiBjYXRjaFJlamVjdGlvbihyYWNlV2l0aFNpZ25hbChzaWduYWwsIHByb21pc2UpLnRoZW4oKG91dHB1dCkgPT4ge1xuICAgICAgdmFsaWRhdGVBY3RpdmUoc2lnbmFsKTtcbiAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfSkpO1xuICB9O1xufTtcbnZhciBjcmVhdGVEZWxheSA9IChzaWduYWwpID0+IHtcbiAgY29uc3QgcGF1c2UgPSBjcmVhdGVQYXVzZShzaWduYWwpO1xuICByZXR1cm4gKHRpbWVvdXRNcykgPT4ge1xuICAgIHJldHVybiBwYXVzZShuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCB0aW1lb3V0TXMpKSk7XG4gIH07XG59O1xuXG4vLyBzcmMvbGlzdGVuZXJNaWRkbGV3YXJlL2luZGV4LnRzXG52YXIge1xuICBhc3NpZ25cbn0gPSBPYmplY3Q7XG52YXIgSU5URVJOQUxfTklMX1RPS0VOID0ge307XG52YXIgYWxtID0gXCJsaXN0ZW5lck1pZGRsZXdhcmVcIjtcbnZhciBjcmVhdGVGb3JrID0gKHBhcmVudEFib3J0U2lnbmFsLCBwYXJlbnRCbG9ja2luZ1Byb21pc2VzKSA9PiB7XG4gIGNvbnN0IGxpbmtDb250cm9sbGVycyA9IChjb250cm9sbGVyKSA9PiBhZGRBYm9ydFNpZ25hbExpc3RlbmVyKHBhcmVudEFib3J0U2lnbmFsLCAoKSA9PiBhYm9ydENvbnRyb2xsZXJXaXRoUmVhc29uKGNvbnRyb2xsZXIsIHBhcmVudEFib3J0U2lnbmFsLnJlYXNvbikpO1xuICByZXR1cm4gKHRhc2tFeGVjdXRvciwgb3B0cykgPT4ge1xuICAgIGFzc2VydEZ1bmN0aW9uKHRhc2tFeGVjdXRvciwgXCJ0YXNrRXhlY3V0b3JcIik7XG4gICAgY29uc3QgY2hpbGRBYm9ydENvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgbGlua0NvbnRyb2xsZXJzKGNoaWxkQWJvcnRDb250cm9sbGVyKTtcbiAgICBjb25zdCByZXN1bHQgPSBydW5UYXNrKGFzeW5jICgpID0+IHtcbiAgICAgIHZhbGlkYXRlQWN0aXZlKHBhcmVudEFib3J0U2lnbmFsKTtcbiAgICAgIHZhbGlkYXRlQWN0aXZlKGNoaWxkQWJvcnRDb250cm9sbGVyLnNpZ25hbCk7XG4gICAgICBjb25zdCByZXN1bHQyID0gYXdhaXQgdGFza0V4ZWN1dG9yKHtcbiAgICAgICAgcGF1c2U6IGNyZWF0ZVBhdXNlKGNoaWxkQWJvcnRDb250cm9sbGVyLnNpZ25hbCksXG4gICAgICAgIGRlbGF5OiBjcmVhdGVEZWxheShjaGlsZEFib3J0Q29udHJvbGxlci5zaWduYWwpLFxuICAgICAgICBzaWduYWw6IGNoaWxkQWJvcnRDb250cm9sbGVyLnNpZ25hbFxuICAgICAgfSk7XG4gICAgICB2YWxpZGF0ZUFjdGl2ZShjaGlsZEFib3J0Q29udHJvbGxlci5zaWduYWwpO1xuICAgICAgcmV0dXJuIHJlc3VsdDI7XG4gICAgfSwgKCkgPT4gYWJvcnRDb250cm9sbGVyV2l0aFJlYXNvbihjaGlsZEFib3J0Q29udHJvbGxlciwgdGFza0NvbXBsZXRlZCkpO1xuICAgIGlmIChvcHRzPy5hdXRvSm9pbikge1xuICAgICAgcGFyZW50QmxvY2tpbmdQcm9taXNlcy5wdXNoKHJlc3VsdC5jYXRjaChub29wMikpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgcmVzdWx0OiBjcmVhdGVQYXVzZShwYXJlbnRBYm9ydFNpZ25hbCkocmVzdWx0KSxcbiAgICAgIGNhbmNlbCgpIHtcbiAgICAgICAgYWJvcnRDb250cm9sbGVyV2l0aFJlYXNvbihjaGlsZEFib3J0Q29udHJvbGxlciwgdGFza0NhbmNlbGxlZCk7XG4gICAgICB9XG4gICAgfTtcbiAgfTtcbn07XG52YXIgY3JlYXRlVGFrZVBhdHRlcm4gPSAoc3RhcnRMaXN0ZW5pbmcsIHNpZ25hbCkgPT4ge1xuICBjb25zdCB0YWtlID0gYXN5bmMgKHByZWRpY2F0ZSwgdGltZW91dCkgPT4ge1xuICAgIHZhbGlkYXRlQWN0aXZlKHNpZ25hbCk7XG4gICAgbGV0IHVuc3Vic2NyaWJlID0gKCkgPT4ge1xuICAgIH07XG4gICAgY29uc3QgdHVwbGVQcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgbGV0IHN0b3BMaXN0ZW5pbmcgPSBzdGFydExpc3RlbmluZyh7XG4gICAgICAgIHByZWRpY2F0ZSxcbiAgICAgICAgZWZmZWN0OiAoYWN0aW9uLCBsaXN0ZW5lckFwaSkgPT4ge1xuICAgICAgICAgIGxpc3RlbmVyQXBpLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgcmVzb2x2ZShbYWN0aW9uLCBsaXN0ZW5lckFwaS5nZXRTdGF0ZSgpLCBsaXN0ZW5lckFwaS5nZXRPcmlnaW5hbFN0YXRlKCldKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB1bnN1YnNjcmliZSA9ICgpID0+IHtcbiAgICAgICAgc3RvcExpc3RlbmluZygpO1xuICAgICAgICByZWplY3QoKTtcbiAgICAgIH07XG4gICAgfSk7XG4gICAgY29uc3QgcHJvbWlzZXMgPSBbdHVwbGVQcm9taXNlXTtcbiAgICBpZiAodGltZW91dCAhPSBudWxsKSB7XG4gICAgICBwcm9taXNlcy5wdXNoKG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIHRpbWVvdXQsIG51bGwpKSk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBjb25zdCBvdXRwdXQgPSBhd2FpdCByYWNlV2l0aFNpZ25hbChzaWduYWwsIFByb21pc2UucmFjZShwcm9taXNlcykpO1xuICAgICAgdmFsaWRhdGVBY3RpdmUoc2lnbmFsKTtcbiAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHVuc3Vic2NyaWJlKCk7XG4gICAgfVxuICB9O1xuICByZXR1cm4gKHByZWRpY2F0ZSwgdGltZW91dCkgPT4gY2F0Y2hSZWplY3Rpb24odGFrZShwcmVkaWNhdGUsIHRpbWVvdXQpKTtcbn07XG52YXIgZ2V0TGlzdGVuZXJFbnRyeVByb3BzRnJvbSA9IChvcHRpb25zKSA9PiB7XG4gIGxldCB7XG4gICAgdHlwZSxcbiAgICBhY3Rpb25DcmVhdG9yLFxuICAgIG1hdGNoZXIsXG4gICAgcHJlZGljYXRlLFxuICAgIGVmZmVjdFxuICB9ID0gb3B0aW9ucztcbiAgaWYgKHR5cGUpIHtcbiAgICBwcmVkaWNhdGUgPSBjcmVhdGVBY3Rpb24odHlwZSkubWF0Y2g7XG4gIH0gZWxzZSBpZiAoYWN0aW9uQ3JlYXRvcikge1xuICAgIHR5cGUgPSBhY3Rpb25DcmVhdG9yLnR5cGU7XG4gICAgcHJlZGljYXRlID0gYWN0aW9uQ3JlYXRvci5tYXRjaDtcbiAgfSBlbHNlIGlmIChtYXRjaGVyKSB7XG4gICAgcHJlZGljYXRlID0gbWF0Y2hlcjtcbiAgfSBlbHNlIGlmIChwcmVkaWNhdGUpIHtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgyMSkgOiBcIkNyZWF0aW5nIG9yIHJlbW92aW5nIGEgbGlzdGVuZXIgcmVxdWlyZXMgb25lIG9mIHRoZSBrbm93biBmaWVsZHMgZm9yIG1hdGNoaW5nIGFuIGFjdGlvblwiKTtcbiAgfVxuICBhc3NlcnRGdW5jdGlvbihlZmZlY3QsIFwib3B0aW9ucy5saXN0ZW5lclwiKTtcbiAgcmV0dXJuIHtcbiAgICBwcmVkaWNhdGUsXG4gICAgdHlwZSxcbiAgICBlZmZlY3RcbiAgfTtcbn07XG52YXIgY3JlYXRlTGlzdGVuZXJFbnRyeSA9IC8qIEBfX1BVUkVfXyAqLyBhc3NpZ24oKG9wdGlvbnMpID0+IHtcbiAgY29uc3Qge1xuICAgIHR5cGUsXG4gICAgcHJlZGljYXRlLFxuICAgIGVmZmVjdFxuICB9ID0gZ2V0TGlzdGVuZXJFbnRyeVByb3BzRnJvbShvcHRpb25zKTtcbiAgY29uc3QgaWQgPSBuYW5vaWQoKTtcbiAgY29uc3QgZW50cnkgPSB7XG4gICAgaWQsXG4gICAgZWZmZWN0LFxuICAgIHR5cGUsXG4gICAgcHJlZGljYXRlLFxuICAgIHBlbmRpbmc6IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCksXG4gICAgdW5zdWJzY3JpYmU6ICgpID0+IHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDIyKSA6IFwiVW5zdWJzY3JpYmUgbm90IGluaXRpYWxpemVkXCIpO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIGVudHJ5O1xufSwge1xuICB3aXRoVHlwZXM6ICgpID0+IGNyZWF0ZUxpc3RlbmVyRW50cnlcbn0pO1xudmFyIGNhbmNlbEFjdGl2ZUxpc3RlbmVycyA9IChlbnRyeSkgPT4ge1xuICBlbnRyeS5wZW5kaW5nLmZvckVhY2goKGNvbnRyb2xsZXIpID0+IHtcbiAgICBhYm9ydENvbnRyb2xsZXJXaXRoUmVhc29uKGNvbnRyb2xsZXIsIGxpc3RlbmVyQ2FuY2VsbGVkKTtcbiAgfSk7XG59O1xudmFyIGNyZWF0ZUNsZWFyTGlzdGVuZXJNaWRkbGV3YXJlID0gKGxpc3RlbmVyTWFwKSA9PiB7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgbGlzdGVuZXJNYXAuZm9yRWFjaChjYW5jZWxBY3RpdmVMaXN0ZW5lcnMpO1xuICAgIGxpc3RlbmVyTWFwLmNsZWFyKCk7XG4gIH07XG59O1xudmFyIHNhZmVseU5vdGlmeUVycm9yID0gKGVycm9ySGFuZGxlciwgZXJyb3JUb05vdGlmeSwgZXJyb3JJbmZvKSA9PiB7XG4gIHRyeSB7XG4gICAgZXJyb3JIYW5kbGVyKGVycm9yVG9Ob3RpZnksIGVycm9ySW5mbyk7XG4gIH0gY2F0Y2ggKGVycm9ySGFuZGxlckVycm9yKSB7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aHJvdyBlcnJvckhhbmRsZXJFcnJvcjtcbiAgICB9LCAwKTtcbiAgfVxufTtcbnZhciBhZGRMaXN0ZW5lciA9IC8qIEBfX1BVUkVfXyAqLyBhc3NpZ24oLyogQF9fUFVSRV9fICovIGNyZWF0ZUFjdGlvbihgJHthbG19L2FkZGApLCB7XG4gIHdpdGhUeXBlczogKCkgPT4gYWRkTGlzdGVuZXJcbn0pO1xudmFyIGNsZWFyQWxsTGlzdGVuZXJzID0gLyogQF9fUFVSRV9fICovIGNyZWF0ZUFjdGlvbihgJHthbG19L3JlbW92ZUFsbGApO1xudmFyIHJlbW92ZUxpc3RlbmVyID0gLyogQF9fUFVSRV9fICovIGFzc2lnbigvKiBAX19QVVJFX18gKi8gY3JlYXRlQWN0aW9uKGAke2FsbX0vcmVtb3ZlYCksIHtcbiAgd2l0aFR5cGVzOiAoKSA9PiByZW1vdmVMaXN0ZW5lclxufSk7XG52YXIgZGVmYXVsdEVycm9ySGFuZGxlciA9ICguLi5hcmdzKSA9PiB7XG4gIGNvbnNvbGUuZXJyb3IoYCR7YWxtfS9lcnJvcmAsIC4uLmFyZ3MpO1xufTtcbnZhciBjcmVhdGVMaXN0ZW5lck1pZGRsZXdhcmUgPSAobWlkZGxld2FyZU9wdGlvbnMgPSB7fSkgPT4ge1xuICBjb25zdCBsaXN0ZW5lck1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGNvbnN0IHtcbiAgICBleHRyYSxcbiAgICBvbkVycm9yID0gZGVmYXVsdEVycm9ySGFuZGxlclxuICB9ID0gbWlkZGxld2FyZU9wdGlvbnM7XG4gIGFzc2VydEZ1bmN0aW9uKG9uRXJyb3IsIFwib25FcnJvclwiKTtcbiAgY29uc3QgaW5zZXJ0RW50cnkgPSAoZW50cnkpID0+IHtcbiAgICBlbnRyeS51bnN1YnNjcmliZSA9ICgpID0+IGxpc3RlbmVyTWFwLmRlbGV0ZShlbnRyeS5pZCk7XG4gICAgbGlzdGVuZXJNYXAuc2V0KGVudHJ5LmlkLCBlbnRyeSk7XG4gICAgcmV0dXJuIChjYW5jZWxPcHRpb25zKSA9PiB7XG4gICAgICBlbnRyeS51bnN1YnNjcmliZSgpO1xuICAgICAgaWYgKGNhbmNlbE9wdGlvbnM/LmNhbmNlbEFjdGl2ZSkge1xuICAgICAgICBjYW5jZWxBY3RpdmVMaXN0ZW5lcnMoZW50cnkpO1xuICAgICAgfVxuICAgIH07XG4gIH07XG4gIGNvbnN0IHN0YXJ0TGlzdGVuaW5nID0gKG9wdGlvbnMpID0+IHtcbiAgICBsZXQgZW50cnkgPSBmaW5kKEFycmF5LmZyb20obGlzdGVuZXJNYXAudmFsdWVzKCkpLCAoZXhpc3RpbmdFbnRyeSkgPT4gZXhpc3RpbmdFbnRyeS5lZmZlY3QgPT09IG9wdGlvbnMuZWZmZWN0KTtcbiAgICBpZiAoIWVudHJ5KSB7XG4gICAgICBlbnRyeSA9IGNyZWF0ZUxpc3RlbmVyRW50cnkob3B0aW9ucyk7XG4gICAgfVxuICAgIHJldHVybiBpbnNlcnRFbnRyeShlbnRyeSk7XG4gIH07XG4gIGFzc2lnbihzdGFydExpc3RlbmluZywge1xuICAgIHdpdGhUeXBlczogKCkgPT4gc3RhcnRMaXN0ZW5pbmdcbiAgfSk7XG4gIGNvbnN0IHN0b3BMaXN0ZW5pbmcgPSAob3B0aW9ucykgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIHR5cGUsXG4gICAgICBlZmZlY3QsXG4gICAgICBwcmVkaWNhdGVcbiAgICB9ID0gZ2V0TGlzdGVuZXJFbnRyeVByb3BzRnJvbShvcHRpb25zKTtcbiAgICBjb25zdCBlbnRyeSA9IGZpbmQoQXJyYXkuZnJvbShsaXN0ZW5lck1hcC52YWx1ZXMoKSksIChlbnRyeTIpID0+IHtcbiAgICAgIGNvbnN0IG1hdGNoUHJlZGljYXRlT3JUeXBlID0gdHlwZW9mIHR5cGUgPT09IFwic3RyaW5nXCIgPyBlbnRyeTIudHlwZSA9PT0gdHlwZSA6IGVudHJ5Mi5wcmVkaWNhdGUgPT09IHByZWRpY2F0ZTtcbiAgICAgIHJldHVybiBtYXRjaFByZWRpY2F0ZU9yVHlwZSAmJiBlbnRyeTIuZWZmZWN0ID09PSBlZmZlY3Q7XG4gICAgfSk7XG4gICAgaWYgKGVudHJ5KSB7XG4gICAgICBlbnRyeS51bnN1YnNjcmliZSgpO1xuICAgICAgaWYgKG9wdGlvbnMuY2FuY2VsQWN0aXZlKSB7XG4gICAgICAgIGNhbmNlbEFjdGl2ZUxpc3RlbmVycyhlbnRyeSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAhIWVudHJ5O1xuICB9O1xuICBhc3NpZ24oc3RvcExpc3RlbmluZywge1xuICAgIHdpdGhUeXBlczogKCkgPT4gc3RvcExpc3RlbmluZ1xuICB9KTtcbiAgY29uc3Qgbm90aWZ5TGlzdGVuZXIgPSBhc3luYyAoZW50cnksIGFjdGlvbiwgYXBpLCBnZXRPcmlnaW5hbFN0YXRlKSA9PiB7XG4gICAgY29uc3QgaW50ZXJuYWxUYXNrQ29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICBjb25zdCB0YWtlID0gY3JlYXRlVGFrZVBhdHRlcm4oc3RhcnRMaXN0ZW5pbmcsIGludGVybmFsVGFza0NvbnRyb2xsZXIuc2lnbmFsKTtcbiAgICBjb25zdCBhdXRvSm9pblByb21pc2VzID0gW107XG4gICAgdHJ5IHtcbiAgICAgIGVudHJ5LnBlbmRpbmcuYWRkKGludGVybmFsVGFza0NvbnRyb2xsZXIpO1xuICAgICAgYXdhaXQgUHJvbWlzZS5yZXNvbHZlKGVudHJ5LmVmZmVjdChcbiAgICAgICAgYWN0aW9uLFxuICAgICAgICAvLyBVc2UgYXNzaWduKCkgcmF0aGVyIHRoYW4gLi4uIHRvIGF2b2lkIGV4dHJhIGhlbHBlciBmdW5jdGlvbnMgYWRkZWQgdG8gYnVuZGxlXG4gICAgICAgIGFzc2lnbih7fSwgYXBpLCB7XG4gICAgICAgICAgZ2V0T3JpZ2luYWxTdGF0ZSxcbiAgICAgICAgICBjb25kaXRpb246IChwcmVkaWNhdGUsIHRpbWVvdXQpID0+IHRha2UocHJlZGljYXRlLCB0aW1lb3V0KS50aGVuKEJvb2xlYW4pLFxuICAgICAgICAgIHRha2UsXG4gICAgICAgICAgZGVsYXk6IGNyZWF0ZURlbGF5KGludGVybmFsVGFza0NvbnRyb2xsZXIuc2lnbmFsKSxcbiAgICAgICAgICBwYXVzZTogY3JlYXRlUGF1c2UoaW50ZXJuYWxUYXNrQ29udHJvbGxlci5zaWduYWwpLFxuICAgICAgICAgIGV4dHJhLFxuICAgICAgICAgIHNpZ25hbDogaW50ZXJuYWxUYXNrQ29udHJvbGxlci5zaWduYWwsXG4gICAgICAgICAgZm9yazogY3JlYXRlRm9yayhpbnRlcm5hbFRhc2tDb250cm9sbGVyLnNpZ25hbCwgYXV0b0pvaW5Qcm9taXNlcyksXG4gICAgICAgICAgdW5zdWJzY3JpYmU6IGVudHJ5LnVuc3Vic2NyaWJlLFxuICAgICAgICAgIHN1YnNjcmliZTogKCkgPT4ge1xuICAgICAgICAgICAgbGlzdGVuZXJNYXAuc2V0KGVudHJ5LmlkLCBlbnRyeSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBjYW5jZWxBY3RpdmVMaXN0ZW5lcnM6ICgpID0+IHtcbiAgICAgICAgICAgIGVudHJ5LnBlbmRpbmcuZm9yRWFjaCgoY29udHJvbGxlciwgXywgc2V0KSA9PiB7XG4gICAgICAgICAgICAgIGlmIChjb250cm9sbGVyICE9PSBpbnRlcm5hbFRhc2tDb250cm9sbGVyKSB7XG4gICAgICAgICAgICAgICAgYWJvcnRDb250cm9sbGVyV2l0aFJlYXNvbihjb250cm9sbGVyLCBsaXN0ZW5lckNhbmNlbGxlZCk7XG4gICAgICAgICAgICAgICAgc2V0LmRlbGV0ZShjb250cm9sbGVyKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBjYW5jZWw6ICgpID0+IHtcbiAgICAgICAgICAgIGFib3J0Q29udHJvbGxlcldpdGhSZWFzb24oaW50ZXJuYWxUYXNrQ29udHJvbGxlciwgbGlzdGVuZXJDYW5jZWxsZWQpO1xuICAgICAgICAgICAgZW50cnkucGVuZGluZy5kZWxldGUoaW50ZXJuYWxUYXNrQ29udHJvbGxlcik7XG4gICAgICAgICAgfSxcbiAgICAgICAgICB0aHJvd0lmQ2FuY2VsbGVkOiAoKSA9PiB7XG4gICAgICAgICAgICB2YWxpZGF0ZUFjdGl2ZShpbnRlcm5hbFRhc2tDb250cm9sbGVyLnNpZ25hbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgKSk7XG4gICAgfSBjYXRjaCAobGlzdGVuZXJFcnJvcikge1xuICAgICAgaWYgKCEobGlzdGVuZXJFcnJvciBpbnN0YW5jZW9mIFRhc2tBYm9ydEVycm9yKSkge1xuICAgICAgICBzYWZlbHlOb3RpZnlFcnJvcihvbkVycm9yLCBsaXN0ZW5lckVycm9yLCB7XG4gICAgICAgICAgcmFpc2VkQnk6IFwiZWZmZWN0XCJcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGF3YWl0IFByb21pc2UuYWxsKGF1dG9Kb2luUHJvbWlzZXMpO1xuICAgICAgYWJvcnRDb250cm9sbGVyV2l0aFJlYXNvbihpbnRlcm5hbFRhc2tDb250cm9sbGVyLCBsaXN0ZW5lckNvbXBsZXRlZCk7XG4gICAgICBlbnRyeS5wZW5kaW5nLmRlbGV0ZShpbnRlcm5hbFRhc2tDb250cm9sbGVyKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IGNsZWFyTGlzdGVuZXJNaWRkbGV3YXJlID0gY3JlYXRlQ2xlYXJMaXN0ZW5lck1pZGRsZXdhcmUobGlzdGVuZXJNYXApO1xuICBjb25zdCBtaWRkbGV3YXJlID0gKGFwaSkgPT4gKG5leHQpID0+IChhY3Rpb24pID0+IHtcbiAgICBpZiAoIWlzQWN0aW9uMyhhY3Rpb24pKSB7XG4gICAgICByZXR1cm4gbmV4dChhY3Rpb24pO1xuICAgIH1cbiAgICBpZiAoYWRkTGlzdGVuZXIubWF0Y2goYWN0aW9uKSkge1xuICAgICAgcmV0dXJuIHN0YXJ0TGlzdGVuaW5nKGFjdGlvbi5wYXlsb2FkKTtcbiAgICB9XG4gICAgaWYgKGNsZWFyQWxsTGlzdGVuZXJzLm1hdGNoKGFjdGlvbikpIHtcbiAgICAgIGNsZWFyTGlzdGVuZXJNaWRkbGV3YXJlKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChyZW1vdmVMaXN0ZW5lci5tYXRjaChhY3Rpb24pKSB7XG4gICAgICByZXR1cm4gc3RvcExpc3RlbmluZyhhY3Rpb24ucGF5bG9hZCk7XG4gICAgfVxuICAgIGxldCBvcmlnaW5hbFN0YXRlID0gYXBpLmdldFN0YXRlKCk7XG4gICAgY29uc3QgZ2V0T3JpZ2luYWxTdGF0ZSA9ICgpID0+IHtcbiAgICAgIGlmIChvcmlnaW5hbFN0YXRlID09PSBJTlRFUk5BTF9OSUxfVE9LRU4pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMjMpIDogYCR7YWxtfTogZ2V0T3JpZ2luYWxTdGF0ZSBjYW4gb25seSBiZSBjYWxsZWQgc3luY2hyb25vdXNseWApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9yaWdpbmFsU3RhdGU7XG4gICAgfTtcbiAgICBsZXQgcmVzdWx0O1xuICAgIHRyeSB7XG4gICAgICByZXN1bHQgPSBuZXh0KGFjdGlvbik7XG4gICAgICBpZiAobGlzdGVuZXJNYXAuc2l6ZSA+IDApIHtcbiAgICAgICAgY29uc3QgY3VycmVudFN0YXRlID0gYXBpLmdldFN0YXRlKCk7XG4gICAgICAgIGNvbnN0IGxpc3RlbmVyRW50cmllcyA9IEFycmF5LmZyb20obGlzdGVuZXJNYXAudmFsdWVzKCkpO1xuICAgICAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIGxpc3RlbmVyRW50cmllcykge1xuICAgICAgICAgIGxldCBydW5MaXN0ZW5lciA9IGZhbHNlO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBydW5MaXN0ZW5lciA9IGVudHJ5LnByZWRpY2F0ZShhY3Rpb24sIGN1cnJlbnRTdGF0ZSwgb3JpZ2luYWxTdGF0ZSk7XG4gICAgICAgICAgfSBjYXRjaCAocHJlZGljYXRlRXJyb3IpIHtcbiAgICAgICAgICAgIHJ1bkxpc3RlbmVyID0gZmFsc2U7XG4gICAgICAgICAgICBzYWZlbHlOb3RpZnlFcnJvcihvbkVycm9yLCBwcmVkaWNhdGVFcnJvciwge1xuICAgICAgICAgICAgICByYWlzZWRCeTogXCJwcmVkaWNhdGVcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghcnVuTGlzdGVuZXIpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBub3RpZnlMaXN0ZW5lcihlbnRyeSwgYWN0aW9uLCBhcGksIGdldE9yaWdpbmFsU3RhdGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIG9yaWdpbmFsU3RhdGUgPSBJTlRFUk5BTF9OSUxfVE9LRU47XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG4gIHJldHVybiB7XG4gICAgbWlkZGxld2FyZSxcbiAgICBzdGFydExpc3RlbmluZyxcbiAgICBzdG9wTGlzdGVuaW5nLFxuICAgIGNsZWFyTGlzdGVuZXJzOiBjbGVhckxpc3RlbmVyTWlkZGxld2FyZVxuICB9O1xufTtcblxuLy8gc3JjL2R5bmFtaWNNaWRkbGV3YXJlL2luZGV4LnRzXG5pbXBvcnQgeyBjb21wb3NlIGFzIGNvbXBvc2UzIH0gZnJvbSBcInJlZHV4XCI7XG52YXIgY3JlYXRlTWlkZGxld2FyZUVudHJ5ID0gKG1pZGRsZXdhcmUpID0+ICh7XG4gIGlkOiBuYW5vaWQoKSxcbiAgbWlkZGxld2FyZSxcbiAgYXBwbGllZDogLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKVxufSk7XG52YXIgbWF0Y2hJbnN0YW5jZSA9IChpbnN0YW5jZUlkKSA9PiAoYWN0aW9uKSA9PiBhY3Rpb24/Lm1ldGE/Lmluc3RhbmNlSWQgPT09IGluc3RhbmNlSWQ7XG52YXIgY3JlYXRlRHluYW1pY01pZGRsZXdhcmUgPSAoKSA9PiB7XG4gIGNvbnN0IGluc3RhbmNlSWQgPSBuYW5vaWQoKTtcbiAgY29uc3QgbWlkZGxld2FyZU1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGNvbnN0IHdpdGhNaWRkbGV3YXJlID0gT2JqZWN0LmFzc2lnbihjcmVhdGVBY3Rpb24oXCJkeW5hbWljTWlkZGxld2FyZS9hZGRcIiwgKC4uLm1pZGRsZXdhcmVzKSA9PiAoe1xuICAgIHBheWxvYWQ6IG1pZGRsZXdhcmVzLFxuICAgIG1ldGE6IHtcbiAgICAgIGluc3RhbmNlSWRcbiAgICB9XG4gIH0pKSwge1xuICAgIHdpdGhUeXBlczogKCkgPT4gd2l0aE1pZGRsZXdhcmVcbiAgfSk7XG4gIGNvbnN0IGFkZE1pZGRsZXdhcmUgPSBPYmplY3QuYXNzaWduKGZ1bmN0aW9uIGFkZE1pZGRsZXdhcmUyKC4uLm1pZGRsZXdhcmVzKSB7XG4gICAgbWlkZGxld2FyZXMuZm9yRWFjaCgobWlkZGxld2FyZTIpID0+IHtcbiAgICAgIGxldCBlbnRyeSA9IGZpbmQoQXJyYXkuZnJvbShtaWRkbGV3YXJlTWFwLnZhbHVlcygpKSwgKGVudHJ5MikgPT4gZW50cnkyLm1pZGRsZXdhcmUgPT09IG1pZGRsZXdhcmUyKTtcbiAgICAgIGlmICghZW50cnkpIHtcbiAgICAgICAgZW50cnkgPSBjcmVhdGVNaWRkbGV3YXJlRW50cnkobWlkZGxld2FyZTIpO1xuICAgICAgfVxuICAgICAgbWlkZGxld2FyZU1hcC5zZXQoZW50cnkuaWQsIGVudHJ5KTtcbiAgICB9KTtcbiAgfSwge1xuICAgIHdpdGhUeXBlczogKCkgPT4gYWRkTWlkZGxld2FyZVxuICB9KTtcbiAgY29uc3QgZ2V0RmluYWxNaWRkbGV3YXJlID0gKGFwaSkgPT4ge1xuICAgIGNvbnN0IGFwcGxpZWRNaWRkbGV3YXJlID0gQXJyYXkuZnJvbShtaWRkbGV3YXJlTWFwLnZhbHVlcygpKS5tYXAoKGVudHJ5KSA9PiBlbXBsYWNlKGVudHJ5LmFwcGxpZWQsIGFwaSwge1xuICAgICAgaW5zZXJ0OiAoKSA9PiBlbnRyeS5taWRkbGV3YXJlKGFwaSlcbiAgICB9KSk7XG4gICAgcmV0dXJuIGNvbXBvc2UzKC4uLmFwcGxpZWRNaWRkbGV3YXJlKTtcbiAgfTtcbiAgY29uc3QgaXNXaXRoTWlkZGxld2FyZSA9IGlzQWxsT2Yod2l0aE1pZGRsZXdhcmUsIG1hdGNoSW5zdGFuY2UoaW5zdGFuY2VJZCkpO1xuICBjb25zdCBtaWRkbGV3YXJlID0gKGFwaSkgPT4gKG5leHQpID0+IChhY3Rpb24pID0+IHtcbiAgICBpZiAoaXNXaXRoTWlkZGxld2FyZShhY3Rpb24pKSB7XG4gICAgICBhZGRNaWRkbGV3YXJlKC4uLmFjdGlvbi5wYXlsb2FkKTtcbiAgICAgIHJldHVybiBhcGkuZGlzcGF0Y2g7XG4gICAgfVxuICAgIHJldHVybiBnZXRGaW5hbE1pZGRsZXdhcmUoYXBpKShuZXh0KShhY3Rpb24pO1xuICB9O1xuICByZXR1cm4ge1xuICAgIG1pZGRsZXdhcmUsXG4gICAgYWRkTWlkZGxld2FyZSxcbiAgICB3aXRoTWlkZGxld2FyZSxcbiAgICBpbnN0YW5jZUlkXG4gIH07XG59O1xuXG4vLyBzcmMvY29tYmluZVNsaWNlcy50c1xuaW1wb3J0IHsgY29tYmluZVJlZHVjZXJzIGFzIGNvbWJpbmVSZWR1Y2VyczIgfSBmcm9tIFwicmVkdXhcIjtcbnZhciBpc1NsaWNlTGlrZSA9IChtYXliZVNsaWNlTGlrZSkgPT4gXCJyZWR1Y2VyUGF0aFwiIGluIG1heWJlU2xpY2VMaWtlICYmIHR5cGVvZiBtYXliZVNsaWNlTGlrZS5yZWR1Y2VyUGF0aCA9PT0gXCJzdHJpbmdcIjtcbnZhciBnZXRSZWR1Y2VycyA9IChzbGljZXMpID0+IHNsaWNlcy5mbGF0TWFwKChzbGljZU9yTWFwKSA9PiBpc1NsaWNlTGlrZShzbGljZU9yTWFwKSA/IFtbc2xpY2VPck1hcC5yZWR1Y2VyUGF0aCwgc2xpY2VPck1hcC5yZWR1Y2VyXV0gOiBPYmplY3QuZW50cmllcyhzbGljZU9yTWFwKSk7XG52YXIgT1JJR0lOQUxfU1RBVEUgPSBTeW1ib2wuZm9yKFwicnRrLXN0YXRlLXByb3h5LW9yaWdpbmFsXCIpO1xudmFyIGlzU3RhdGVQcm94eSA9ICh2YWx1ZSkgPT4gISF2YWx1ZSAmJiAhIXZhbHVlW09SSUdJTkFMX1NUQVRFXTtcbnZhciBzdGF0ZVByb3h5TWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG52YXIgY3JlYXRlU3RhdGVQcm94eSA9IChzdGF0ZSwgcmVkdWNlck1hcCkgPT4gZW1wbGFjZShzdGF0ZVByb3h5TWFwLCBzdGF0ZSwge1xuICBpbnNlcnQ6ICgpID0+IG5ldyBQcm94eShzdGF0ZSwge1xuICAgIGdldDogKHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpID0+IHtcbiAgICAgIGlmIChwcm9wID09PSBPUklHSU5BTF9TVEFURSkgcmV0dXJuIHRhcmdldDtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IFJlZmxlY3QuZ2V0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpO1xuICAgICAgaWYgKHR5cGVvZiByZXN1bHQgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgY29uc3QgcmVkdWNlciA9IHJlZHVjZXJNYXBbcHJvcC50b1N0cmluZygpXTtcbiAgICAgICAgaWYgKHJlZHVjZXIpIHtcbiAgICAgICAgICBjb25zdCByZWR1Y2VyUmVzdWx0ID0gcmVkdWNlcih2b2lkIDAsIHtcbiAgICAgICAgICAgIHR5cGU6IG5hbm9pZCgpXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKHR5cGVvZiByZWR1Y2VyUmVzdWx0ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgyNCkgOiBgVGhlIHNsaWNlIHJlZHVjZXIgZm9yIGtleSBcIiR7cHJvcC50b1N0cmluZygpfVwiIHJldHVybmVkIHVuZGVmaW5lZCB3aGVuIGNhbGxlZCBmb3Igc2VsZWN0b3IoKS4gSWYgdGhlIHN0YXRlIHBhc3NlZCB0byB0aGUgcmVkdWNlciBpcyB1bmRlZmluZWQsIHlvdSBtdXN0IGV4cGxpY2l0bHkgcmV0dXJuIHRoZSBpbml0aWFsIHN0YXRlLiBUaGUgaW5pdGlhbCBzdGF0ZSBtYXkgbm90IGJlIHVuZGVmaW5lZC4gSWYgeW91IGRvbid0IHdhbnQgdG8gc2V0IGEgdmFsdWUgZm9yIHRoaXMgcmVkdWNlciwgeW91IGNhbiB1c2UgbnVsbCBpbnN0ZWFkIG9mIHVuZGVmaW5lZC5gKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlZHVjZXJSZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICB9KVxufSk7XG52YXIgb3JpZ2luYWwgPSAoc3RhdGUpID0+IHtcbiAgaWYgKCFpc1N0YXRlUHJveHkoc3RhdGUpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMjUpIDogXCJvcmlnaW5hbCBtdXN0IGJlIHVzZWQgb24gc3RhdGUgUHJveHlcIik7XG4gIH1cbiAgcmV0dXJuIHN0YXRlW09SSUdJTkFMX1NUQVRFXTtcbn07XG52YXIgbm9vcFJlZHVjZXIgPSAoc3RhdGUgPSB7fSkgPT4gc3RhdGU7XG5mdW5jdGlvbiBjb21iaW5lU2xpY2VzKC4uLnNsaWNlcykge1xuICBjb25zdCByZWR1Y2VyTWFwID0gT2JqZWN0LmZyb21FbnRyaWVzKGdldFJlZHVjZXJzKHNsaWNlcykpO1xuICBjb25zdCBnZXRSZWR1Y2VyID0gKCkgPT4gT2JqZWN0LmtleXMocmVkdWNlck1hcCkubGVuZ3RoID8gY29tYmluZVJlZHVjZXJzMihyZWR1Y2VyTWFwKSA6IG5vb3BSZWR1Y2VyO1xuICBsZXQgcmVkdWNlciA9IGdldFJlZHVjZXIoKTtcbiAgZnVuY3Rpb24gY29tYmluZWRSZWR1Y2VyKHN0YXRlLCBhY3Rpb24pIHtcbiAgICByZXR1cm4gcmVkdWNlcihzdGF0ZSwgYWN0aW9uKTtcbiAgfVxuICBjb21iaW5lZFJlZHVjZXIud2l0aExhenlMb2FkZWRTbGljZXMgPSAoKSA9PiBjb21iaW5lZFJlZHVjZXI7XG4gIGNvbnN0IGluamVjdCA9IChzbGljZSwgY29uZmlnID0ge30pID0+IHtcbiAgICBjb25zdCB7XG4gICAgICByZWR1Y2VyUGF0aCxcbiAgICAgIHJlZHVjZXI6IHJlZHVjZXJUb0luamVjdFxuICAgIH0gPSBzbGljZTtcbiAgICBjb25zdCBjdXJyZW50UmVkdWNlciA9IHJlZHVjZXJNYXBbcmVkdWNlclBhdGhdO1xuICAgIGlmICghY29uZmlnLm92ZXJyaWRlRXhpc3RpbmcgJiYgY3VycmVudFJlZHVjZXIgJiYgY3VycmVudFJlZHVjZXIgIT09IHJlZHVjZXJUb0luamVjdCkge1xuICAgICAgaWYgKHR5cGVvZiBwcm9jZXNzICE9PSBcInVuZGVmaW5lZFwiICYmIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcImRldmVsb3BtZW50XCIpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihgY2FsbGVkIFxcYGluamVjdFxcYCB0byBvdmVycmlkZSBhbHJlYWR5LWV4aXN0aW5nIHJlZHVjZXIgJHtyZWR1Y2VyUGF0aH0gd2l0aG91dCBzcGVjaWZ5aW5nIFxcYG92ZXJyaWRlRXhpc3Rpbmc6IHRydWVcXGBgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb21iaW5lZFJlZHVjZXI7XG4gICAgfVxuICAgIHJlZHVjZXJNYXBbcmVkdWNlclBhdGhdID0gcmVkdWNlclRvSW5qZWN0O1xuICAgIHJlZHVjZXIgPSBnZXRSZWR1Y2VyKCk7XG4gICAgcmV0dXJuIGNvbWJpbmVkUmVkdWNlcjtcbiAgfTtcbiAgY29uc3Qgc2VsZWN0b3IgPSBPYmplY3QuYXNzaWduKGZ1bmN0aW9uIG1ha2VTZWxlY3RvcihzZWxlY3RvckZuLCBzZWxlY3RTdGF0ZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiBzZWxlY3RvcjIoc3RhdGUsIC4uLmFyZ3MpIHtcbiAgICAgIHJldHVybiBzZWxlY3RvckZuKGNyZWF0ZVN0YXRlUHJveHkoc2VsZWN0U3RhdGUgPyBzZWxlY3RTdGF0ZShzdGF0ZSwgLi4uYXJncykgOiBzdGF0ZSwgcmVkdWNlck1hcCksIC4uLmFyZ3MpO1xuICAgIH07XG4gIH0sIHtcbiAgICBvcmlnaW5hbFxuICB9KTtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oY29tYmluZWRSZWR1Y2VyLCB7XG4gICAgaW5qZWN0LFxuICAgIHNlbGVjdG9yXG4gIH0pO1xufVxuXG4vLyBzcmMvZm9ybWF0UHJvZEVycm9yTWVzc2FnZS50c1xuZnVuY3Rpb24gZm9ybWF0UHJvZEVycm9yTWVzc2FnZShjb2RlKSB7XG4gIHJldHVybiBgTWluaWZpZWQgUmVkdXggVG9vbGtpdCBlcnJvciAjJHtjb2RlfTsgdmlzaXQgaHR0cHM6Ly9yZWR1eC10b29sa2l0LmpzLm9yZy9FcnJvcnM/Y29kZT0ke2NvZGV9IGZvciB0aGUgZnVsbCBtZXNzYWdlIG9yIHVzZSB0aGUgbm9uLW1pbmlmaWVkIGRldiBlbnZpcm9ubWVudCBmb3IgZnVsbCBlcnJvcnMuIGA7XG59XG5leHBvcnQge1xuICBSZWR1Y2VyVHlwZSxcbiAgU0hPVUxEX0FVVE9CQVRDSCxcbiAgVGFza0Fib3J0RXJyb3IsXG4gIFR1cGxlLFxuICBhZGRMaXN0ZW5lcixcbiAgYXN5bmNUaHVua0NyZWF0b3IsXG4gIGF1dG9CYXRjaEVuaGFuY2VyLFxuICBidWlsZENyZWF0ZVNsaWNlLFxuICBjbGVhckFsbExpc3RlbmVycyxcbiAgY29tYmluZVNsaWNlcyxcbiAgY29uZmlndXJlU3RvcmUsXG4gIGNyZWF0ZUFjdGlvbixcbiAgY3JlYXRlQWN0aW9uQ3JlYXRvckludmFyaWFudE1pZGRsZXdhcmUsXG4gIGNyZWF0ZUFzeW5jVGh1bmssXG4gIGNyZWF0ZURyYWZ0U2FmZVNlbGVjdG9yLFxuICBjcmVhdGVEcmFmdFNhZmVTZWxlY3RvckNyZWF0b3IsXG4gIGNyZWF0ZUR5bmFtaWNNaWRkbGV3YXJlLFxuICBjcmVhdGVFbnRpdHlBZGFwdGVyLFxuICBjcmVhdGVJbW11dGFibGVTdGF0ZUludmFyaWFudE1pZGRsZXdhcmUsXG4gIGNyZWF0ZUxpc3RlbmVyTWlkZGxld2FyZSxcbiAgcHJvZHVjZSBhcyBjcmVhdGVOZXh0U3RhdGUsXG4gIGNyZWF0ZVJlZHVjZXIsXG4gIGNyZWF0ZVNlbGVjdG9yLFxuICBjcmVhdGVTZWxlY3RvckNyZWF0b3IyIGFzIGNyZWF0ZVNlbGVjdG9yQ3JlYXRvcixcbiAgY3JlYXRlU2VyaWFsaXphYmxlU3RhdGVJbnZhcmlhbnRNaWRkbGV3YXJlLFxuICBjcmVhdGVTbGljZSxcbiAgY3VycmVudDMgYXMgY3VycmVudCxcbiAgZmluZE5vblNlcmlhbGl6YWJsZVZhbHVlLFxuICBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlLFxuICBmcmVlemUsXG4gIGlzQWN0aW9uQ3JlYXRvcixcbiAgaXNBbGxPZixcbiAgaXNBbnlPZixcbiAgaXNBc3luY1RodW5rQWN0aW9uLFxuICBpc0RyYWZ0NSBhcyBpc0RyYWZ0LFxuICBpc0ZTQSBhcyBpc0ZsdXhTdGFuZGFyZEFjdGlvbixcbiAgaXNGdWxmaWxsZWQsXG4gIGlzSW1tdXRhYmxlRGVmYXVsdCxcbiAgaXNQZW5kaW5nLFxuICBpc1BsYWluLFxuICBpc1JlamVjdGVkLFxuICBpc1JlamVjdGVkV2l0aFZhbHVlLFxuICBscnVNZW1vaXplLFxuICBtaW5pU2VyaWFsaXplRXJyb3IsXG4gIG5hbm9pZCxcbiAgb3JpZ2luYWwyIGFzIG9yaWdpbmFsLFxuICBwcmVwYXJlQXV0b0JhdGNoZWQsXG4gIHJlbW92ZUxpc3RlbmVyLFxuICB1bndyYXBSZXN1bHQsXG4gIHdlYWtNYXBNZW1vaXplMiBhcyB3ZWFrTWFwTWVtb2l6ZVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlZHV4LXRvb2xraXQubW9kZXJuLm1qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@reduxjs/toolkit/dist/redux-toolkit.modern.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@reduxjs/toolkit/node_modules/redux-thunk/dist/redux-thunk.mjs":
/*!*************************************************************************************!*\
  !*** ./node_modules/@reduxjs/toolkit/node_modules/redux-thunk/dist/redux-thunk.mjs ***!
  \*************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   thunk: () => (/* binding */ thunk),\n/* harmony export */   withExtraArgument: () => (/* binding */ withExtraArgument)\n/* harmony export */ });\n// src/index.ts\nfunction createThunkMiddleware(extraArgument) {\n  const middleware = ({ dispatch, getState }) => (next) => (action) => {\n    if (typeof action === \"function\") {\n      return action(dispatch, getState, extraArgument);\n    }\n    return next(action);\n  };\n  return middleware;\n}\nvar thunk = createThunkMiddleware();\nvar withExtraArgument = createThunkMiddleware;\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlZHV4anMvdG9vbGtpdC9ub2RlX21vZHVsZXMvcmVkdXgtdGh1bmsvZGlzdC9yZWR1eC10aHVuay5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0Esd0JBQXdCLG9CQUFvQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJRSIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uL25vZGVfbW9kdWxlcy9AcmVkdXhqcy90b29sa2l0L25vZGVfbW9kdWxlcy9yZWR1eC10aHVuay9kaXN0L3JlZHV4LXRodW5rLm1qcz9kY2RhIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy9pbmRleC50c1xuZnVuY3Rpb24gY3JlYXRlVGh1bmtNaWRkbGV3YXJlKGV4dHJhQXJndW1lbnQpIHtcbiAgY29uc3QgbWlkZGxld2FyZSA9ICh7IGRpc3BhdGNoLCBnZXRTdGF0ZSB9KSA9PiAobmV4dCkgPT4gKGFjdGlvbikgPT4ge1xuICAgIGlmICh0eXBlb2YgYWN0aW9uID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHJldHVybiBhY3Rpb24oZGlzcGF0Y2gsIGdldFN0YXRlLCBleHRyYUFyZ3VtZW50KTtcbiAgICB9XG4gICAgcmV0dXJuIG5leHQoYWN0aW9uKTtcbiAgfTtcbiAgcmV0dXJuIG1pZGRsZXdhcmU7XG59XG52YXIgdGh1bmsgPSBjcmVhdGVUaHVua01pZGRsZXdhcmUoKTtcbnZhciB3aXRoRXh0cmFBcmd1bWVudCA9IGNyZWF0ZVRodW5rTWlkZGxld2FyZTtcbmV4cG9ydCB7XG4gIHRodW5rLFxuICB3aXRoRXh0cmFBcmd1bWVudFxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@reduxjs/toolkit/node_modules/redux-thunk/dist/redux-thunk.mjs\n");

/***/ })

};
;